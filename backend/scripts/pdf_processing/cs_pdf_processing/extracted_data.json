[
    {
        "author": "Ambrus Barna",
        "supervisor": "Ș.l.dr.ing. Turos László-Zsolt",
        "year": "2023",
        "abstract": "This paper describes in detail a system and its architecture for managing direction change and\nbraking signals on scooters and bicycles, using a sensor with an accelerometer and gyroscope on\nthe back of the hand. The project aims to provide a solution for direction signals on the crank\nwithout removing the hand from the handlebars, thus avoiding the resulting accidents. The user is\nable to indicate a change of direction by gestures such as turning the hand sideways, so that it is\nnot necessary to take the hand completely off the steering wheel, thus maintaining the balance of\nthe vehicle. Brake signals are automatic as a result of acceleration sensing. The system uses two\nmicrocontrollers (ESP32 and ESP8266), one of which processes the sensor data, while the other\nruns a web server and lights the corresponding LEDs. The web server is responsible for the\ncommunication between the microcontrollers and also runs a web page that acts as a user interface.\nOn the web page, active signals such as turn signals and brake signals are displayed and can be\nswitched on and off. Communication between the different components is wireless using WiFi\ntechnology.",
        "keywords": [
            "microcontroller",
            "WiFi",
            "gyroscope",
            "accelerometer"
        ],
        "hash_code": 9426250888,
        "department": "cs"
    },
    {
        "author": "Bács Bernát",
        "supervisor": "Conf. dr. ing. Kutasi Dénes Nimród,, Ș.l. dr. ing. Szabó László Zsolt",
        "year": "2023",
        "abstract": "This thesis presents the implementation of a smart home control system. The system mainly\nperforms home automation tasks such as temperature control, watering of plants and automatic\nmovement of shutter, thus facilitating the user's daily life. Nowadays, IoT devices are playing an\nincreasingly important role for people, and we can't imagine our lives without them. Since most\npeople have an internet connection at home, building such an IoT system is easier, cheaper and\nmore efficient because there is no need for wires to communicate between devices.\nThe system I developed and built consists of a central computer with a touch screen display\nconnected to it, where you can follow and intervene in the automation processes, you can see\nstatistics about the temperature in the room, for example. Several sensors are connected to this\ncentral part via Bluetooth or MQTT communication protocols, which provide data and perform\nthe automation tasks. In my thesis I document the design and construction of this system in detail,\nillustrating each part with diagrams.",
        "keywords": [
            "IoT",
            "Home-automation",
            "Raspberry Pi",
            "MQTT"
        ],
        "hash_code": 6375406094,
        "department": "cs"
    },
    {
        "author": "Bakó József",
        "supervisor": "Conf. dr. ing. Bakó László",
        "year": "2023",
        "abstract": "Measuring temperature has always played an important role in human life due to the\ncuriosity of it’s nature. With the advance of the world and the temperatures measuring\ntechnologies, this task has become a trivial problem, regardless of what we measure the\ntemperature of.\nThe scope of this project is to create a heat follower robot and a mobile application for\ncontrolling it, which identifies the temperature extremes in a closed area and approaches it, as\nwell. As for the app, my aim is to establish a Bluetooth connection between this and the robot\nand show a picture of it’s view to the user. Also, I want it to make manual control possible.",
        "keywords": [
            "temperature measurement",
            "bluetooth",
            "application",
            "robot control."
        ],
        "hash_code": 2616592750,
        "department": "cs"
    },
    {
        "author": "Bartha Álmos",
        "supervisor": "Ș.l. dr. ing. Hajdu Szabolcs",
        "year": "2024",
        "abstract": "The aim of the thesis is to create a system that can be integrated between a computer and the\nattached network. The system should be capable of monitoring and processing packets passing\nbetween the computer and the network, and modifying specified packets. One of the data packets\nto be modified is the NTP packet, with the goal of having the computer synchronize its internal\nclock according to the modified packets from the integrated system, rather than the time received\nfrom the actual servers. The second type of packet to be modified is the DNS packet, with the goal\nof having the computer receive a falsified response modified by the integrated system for certain\ndomain names, containing an internally selected IPv4 address instead of the server's response.\nAnother important task of the system is monitoring the passing traffic. The primarily observed\npackets are TLS, FTP, and HTTP packets, with the aim of extracting and transparently displaying\nrelevant content. Since FTP and HTTP packets are not encrypted, information such as passwords\nand usernames can also be extracted.\nTo achieve these goals, a Raspberry Pi is integrated between the computer and the network,\nimplementing the aforementioned tasks in Python. This program uses the Scapy library to monitor\nnetwork traffic, modify network packets, and display their content. It forwards packets arriving at\none attached network interface to another attached network interface while processing them and\nsaving the relevant fields.",
        "keywords": [
            "Raspberry",
            "Python",
            "Traffic Monitoring",
            "Scapy",
            "DNS",
            "NTP"
        ],
        "hash_code": 9552242341,
        "department": "cs"
    },
    {
        "author": "Benedek Szabolcs",
        "supervisor": "dr. Márton Gyöngyvér",
        "year": "2021",
        "abstract": "................................................................................................................................. 3\n1. Bevezető .......................................................................................................................... 4\n2. Célkitűzések .................................................................................................................... 4\n3. Elméleti háttér ................................................................................................................... 5\n3.1. Laravel .......................................................................................................................... 5\n3.1.1. Modell-nézet-vezérlő (MVC) .................................................................................. 5\n3.2. Google Maps API.......................................................................................................... 6\n4. Háttérkutatás – Hasonló alkalmazás ............................................................................. 7\n4.1. BlaBlaCar ..................................................................................................................... 7\n5. Követelmény specifikáció ............................................................................................... 7\n5.1. Felhasználói követelmények .......................................................................................... 7\n5.2. Funkcionális követelmények ......................................................................................... 8\n5.3. Nem funkcionális követelmények .................................................................................. 9\n6. Rendszer leírása ............................................................................................................. 9\n6.1. Architektúra ................................................................................................................ 10\n6.2. Front-end .................................................................................................................... 10\n6.3. Back-end ..................................................................................................................... 11\n6.4. Adatbázis .................................................................................................................... 12\n6.5. Többnyelvűsítés .......................................................................................................... 13\n6.6. Szekvenciális diagram ................................................................................................. 14\n7. Az alkalmazás funkcionalitásai .................................................................................... 15\n7.1. Bejelentkezés .............................................................................................................. 15\n7.1.1. Bejelentkezés regisztrációval ................................................................................ 16\n7.1.2. Bejelentkezés Facebook profillal .......................................................................... 16\n7.2. Fuvarok böngészése .................................................................................................... 17\n7.2.1. Fuvar lefoglalása .................................................................................................. 18\n7.3. Fuvar létrehozása ........................................................................................................ 18\n7.4. Fuvar keresése............................................................................................................. 20\n7.5. Aktív fuvarok .............................................................................................................. 20\n7.6. Előzmények – útitársak értékelése ............................................................................... 21\n7.7. Chat ............................................................................................................................ 22\n7.7.1. Cloud Firestore ..................................................................................................... 24\n7.8. Értesítések ................................................................................................................... 25\n7.9. Jelszó visszaállítása ..................................................................................................... 26\n7.10. Profil adatok módosítása ........................................................................................... 28\n8. Kutatómunka - Google Maps API ............................................................................... 28\n8.1. Google Térkép ............................................................................................................ 29\n8.2. Használata ................................................................................................................... 29\n8.3. Directions Service – Útvonal Tervezés ........................................................................ 31\n8.3.1. Directions-hoz intézett kérés ................................................................................. 32\n8.3.2. Directions-tól kapott válasz................................................................................... 34\n8.3.2.1. geocoded_waypoints ...................................................................................... 37\n8.3.2.2. routes ............................................................................................................. 37\n8.4. Google Maps segítségével beépített funkcionalitások .................................................. 38\n9. Jövőbeli terveim ........................................................................................................... 46\n10. Összegzés ...................................................................................................................... 46\n11. Ábrajegyzék .................................................................................................................. 47\n12. Bibliográfia ................................................................................................................... 48\nExtras\nSite-ul web creat în cadrul lucrării a primit numele “The Ride”, și își propune să creeze\no platformă receptivă și bine concepută pentru persoanele care doresc să călătorească, să facă\nnavetă și să exploreze. Ideea a venit din faptul că există o serie de grupuri pe Facebook care\nfacilitează autostopul online, care oferă căutarea însoțitorilor de călătorie, însă nu există multe\naplicații de acest tip, așa că m-am gândit să creez una.\nUn aspect important a fost ca website-ul meu să ofere ceva în plus față de aplicațiile\nsimilare, cum ar fi Blablacar, care este utilizat pe scară largă și în țara noastră. Ca companie\ninternațională, Blablacar poate fi utilizat în orice țară, ceea ce îl face impersonal. Grupurile\nFacebook sunt mai răspândite în comparație cu alte aplicații ride sharing, datorită aspectului\npersonal al platformei.\nPlatforma „The Ride” oferă oportunitatea de a crea o comunitate, încercând totodată să\nofere un mediu personal, prietenos, unde căutarea rutelor poate fi implementată între localitățile\ndin România și Ungaria.\nÎn cadrul aplicației mi-am stabilit și obiectivul de a putea complet planifica o rută,\nvizualizând în detaliu traseul creat. Aplicația oferă așadar, în mod corespunzător rută între\ndestinațiile specificate. Acest funcționalități au fost create folosind Google Maps API, pe care\nvor prezenta amănunțit în cadrul lucrării.\nCuvinte cheie: voiaj, construirea comunității, receptivitate, Google Maps\n1\nKivonat\nA dolgozat keretein belül elkészített weboldal a „The Ride” nevet kapta, és célja az\nutazni és ismerkedni vágyók számára, egy reszponzív, jól kinéző platform létrehozása volt. Az\nötlet abból fakadt, hogy nagyon sok Facebook csoport létezik az online stoppolás, online útitárs\nkeresés megkönnyítésére, viszont alkalmazás nem sok, így az itt látott hiány kitöltésének\nlehetősége felkeltette az érdeklődésemet.\nFontos szempont volt, hogy az én weboldalam valamivel többet nyújtson a hasonló\nalkalmazásokhoz képest, például a hazánkban is széles körben által használt Blablacar-nál. A\nBlablacar, mivel nemzetközi cég, bármelyik országban használható, ezért személytelen, a\nFacebook csoportok pedig azért elterjedtebbek, mint az útitárskereső alkalmazások, mert\nszemélyesek.\nA „The Ride” platformján lehetőséget teremtettem a közösségépítésre, és igyekeztem\nszemélyes, barátságos környezetet biztosítani, ahol az útvonalkeresést romániai és\nmagyarországi települések között lehet megvalósítani.\nAz alkalmazással azt a célt is kitűztem, hogy az útvonalat, egy fuvar létrehozásakor,\nlehessen megtervezni, hogy az alkalmazás fuvart tudjon ajánlani a felhasználók számára.\nFontosnak tartottam azt is, hogy megjelenítsem, egy létező fuvar esetében, településről-\ntelepülésre lebontva az útvonalat. Ezeket és az ezekhez hasonló funkcionalitásokat a Google\nMaps API segítségével oldottam meg.\nKulcsszavak: utazás, közösségépítés, reszponzívitás, Google Maps\n2\nAbstract\nThe web application built for the exam has been named „The Ride” and the purpose behind\nis to create a well designed and responsive platform for people who want to travel, commute and\nexplore. The inspiration behind the idea was the fact that there are a number of Facebook groups\nmeant to simplify the search for ride sharing, however, there are not that many individual\napplications built for this purpose. This was the source of inspiration behind my web application.\nAn important factor for the project was that it must provide an added value compared to\nsimilar solutions, for example Blablacar that is currently available in our country. Facebook groups\nare more widespread compared to other ride sharing applications due to the personal aspect of the\nsocial media platform. Blablacar is an international company whose application is used in multiple\ncountries, which is the reason why building a community is more difficult there. „The Ride”, on\nthe other hand, is only available for regions in Romania and Hungary, which meant to build a\nstronger, more familiar connection with the local users.\nMy goal for the application was to be able to create the entire route when adding a new\nride, as well as to provide a breakdown of locations that the ride is passing through. It’s crucial\nthat the users are provided with good recommendations for rides. This functionality is built with\nthe help of Google Maps APIs which will be discussed further in the exam paper.",
        "keywords": [
            "traveling",
            "social building",
            "responsivity",
            "Google Maps 3"
        ],
        "hash_code": 8426592258,
        "department": "cs"
    },
    {
        "author": "Berkeczi Arnold",
        "supervisor": "Dr. habil Szilágyi László, profesor universitar",
        "year": "2022",
        "abstract": "Nowadays medical image processing is a dynamically evolving science and industry. The\nrapid development of computers makes it possible to implement increasingly complex\nprocedures. However, it is also possible for the computer to trigger the more tedious part of a\nhuman expert’s work and enable the doctor to focus only on cases where the computer has\nfound something abnormal or suspicious. With this thesis, I also want to follow this trend. I\npropose to implement a machine learning procedure that can efficiently and accurately\nsegment brain tissues based on MRI scans of six-month-old infants.\nDuring the implementation, I worked with the data published at the iSeg-2017 competition.\nFrom the OpenCV machine learning library, I found the discrete AdaBoost classifier to be the\nmost suitable for segmentation, and I added a post-processing to improve the results of the\nclassifier. In addition, I implemented software with a graphical user interface that can be used\nto launch segmentation tasks, visualize the results, and manage the inventory of performed\noperations. The average accuracy of the implemented segmentation procedure was slightly\nabove 85%.",
        "keywords": [
            "magnetic resonance imaging",
            "machine learning",
            "discrete AdaBoost algorithm",
            "medical image segmentation 3"
        ],
        "hash_code": 787015244,
        "department": "cs"
    },
    {
        "author": "Blénesi Áron",
        "supervisor": "Dr. Szántó Zoltán",
        "year": "2021",
        "abstract": "The technologies we use in our everyday lives make our lives a lot easier: with a simple mobile\ndevice,wecanpaybillsorevenmakeavideocallwhileweareonthetrain. Inadditiontothese,new\ndemandshaveemerged,suchasgettingthroughthevirtualworldtoplaceswehaveneverbeento.\nIn this dissertation, we present the creation of a complete 3D model of the main building of the\nSapientia EMTE, which also includes a web UI presented in another dissertation, thus creating a\nvirtualtouroftheuniversity. Thedevelopedmodelisincorporatedintothewebapplicationasastatic\nelement. The structural structure of the model was based on the real layout plans and architectural\nplans of the main building. In contrast to series of photograph based approaches, this method allows\ntheusertobetterperceivethespatiallocationofelements.\nThe model was created using Blender, an open source modeling software. The developed model\nallowsustoreachanypoint,fromanyangle,thusgivingtheusertheopportunitytonavigatefreely. At\nthe same time, we have planned different routes between the most important points of the university,\nwhichhelpustogettothesecretariat,departmentsorlaboratoryrooms,moreeasily. Wealsoplaceda\nvirtual billboard at certain points in the model. Information about various universities and events can\nbedisplayedonthese.",
        "keywords": [
            "3dmodel",
            "blender",
            "virtualtour 7"
        ],
        "hash_code": 5146342377,
        "department": "cs"
    },
    {
        "author": "Bocsárdi András-Levente",
        "supervisor": "Prof. dr. ing. habil. Szilágyi László",
        "year": "2023",
        "abstract": "The topic of this thesis is the classification of brain tumours using convolutional\nneural networks. In the first half of the paper, I will describe neural networks based\non the literature, starting from simple M-P neurons to convolutional neural\nnetworks, covering their structure and their training. In the second half of the\npaper, I present three models I developed that classified brain tumours into four\ngroups with an accuracy of over 85%. The first model I implemented was a simple\nconvolutional neural network. With the second model I achieved only moderate\nperformance improvements by changing the architecture and preventing\noverfitting. For both models I tuned the hyperparameters. The best performing\nmodel was the third one, implemented with transfer learning and using VGG16 as\nthe base model. This model achieved the best accuracy (96%). In developing the\nthree models, I used methods to continuously improve the performance of neural\nnetworks by understanding the different mechanisms of action. The model I\ndeveloped could form the basis for an application that provides practicing\nradiologists with rapid preclassification in seconds, making their job easier.",
        "keywords": [],
        "hash_code": 2333422661,
        "department": "cs"
    },
    {
        "author": "Bustya Balázs",
        "supervisor": "Conf. dr. ing. Brassai Sándor Tihamér",
        "year": "2021",
        "abstract": "Artificial neural networks have gained great popularity for their accuracy in image processing,\ndata mining, classification tasks, and decision-making systems in which previously only humans\nwere able to make the right decisions. However, neural networks cannot yet completely replace\nhumans, because humans design them depending on the given task. Hardware accelerators are\nused to increase the performance of neural networks. There have been plenty of studies on\nhardware accelerators in recent years. One of the options are FPGA circuits. The main advantages\nof FPGAs used for hardware acceleration are parallelism, low power consumption and flexibility.\nImplementing neural networks on FPGA is a very time consuming and difficult task, that can only\nbe performed by experienced professionals. The framework we have developed provides solution\nto this problem. The purpose of the framework is to accelerate and facilitate the implementation\nof neural networks \"running\" on an FPGA, to accelerate neural networks, to study optimization\noptions in terms of size and performance, and to automate the programming process. The\nparameterizable neural network models, implemented by the high-level synthesis discussed in the\ndissertation, serve as the basis of the framework, that generates the code of the neural networks\nmodelled in C ++ optimized by directives. The Vivado HLS tool generates the IP core of the neural\nnetwork from this code. It automatically integrates into a system built in Vivado. The Vivado tool\ngenerates the bit file needed to program the FPGA and programs the circuit. The paper includes\nthe implementation of a multilayer perceptron neural network and a radial basis function network,\nhardware implementations of nonlinear activation functions, comparison of fixed-point and\nfloating-point number representations.",
        "keywords": [
            "neural networks",
            "FPGA",
            "framework",
            "high-level synthesis",
            "MLP",
            "RBF"
        ],
        "hash_code": 3129534222,
        "department": "cs"
    },
    {
        "author": "Bálint Adolf",
        "supervisor": "Conf. dr. ing. Lefkovits László",
        "year": "2023",
        "abstract": "The topic of my paper is documenting and tracking the game of backgammon game in\nwhich I dealt with game programming, image processing, and real-time game tracking of game\nprogres. Backgammon and image processing cover two areas of particular interest to me.. The\nRomanian Backgammon Federation organizes various national and international competitions,\nwhere tracking and automatic arbitration are of particular interest.\nThe Python programming language allows for the creation of virtual versions of backgammon,\nwhich gives the game a new dimension by interactively playing it on the computer. The goal of\ngame programming was to enable two players to compete against each other on the computer\nand record the game for later replay.\nOpenCV (Open Source Computer Vision Library) is a popular library used in image processing.\nWith its help, the computer can recognize shapes and process images, allowing for capturing the\nsequential playing positions. My goal in the field of image processing, was to extract still frames\nfrom a video and identify the position of pieces, thus tracking the game's progress.\nTherefore, my objective was to create an application by combining Python and OpenCV that\nautomatically evaluates the board game.The software to be made must recognize the positions of\npieces and tracks the players' moves, allowing for virtual gameplay between two individuals.",
        "keywords": [
            "backgammon",
            "image processing",
            "OpenCV",
            "Python"
        ],
        "hash_code": 1412288822,
        "department": "cs"
    },
    {
        "author": "Bíró Apor",
        "supervisor": "Conf. dr. ing. Brassai Sándor Tihamér",
        "year": "2024",
        "abstract": "",
        "keywords": [
            "CNN",
            "Deep learning",
            "Object detection",
            "Android",
            "Plant Seeds In the present",
            "Artificial Intelligence enjoys a lot of attention not only in Computer Science",
            "but also in many other sciences. A few examples out of these sciences are social sciences",
            "medicine or even agricultural sciences. Nowadays our smartphones spend more time in our hands than in our pockets. New ideas",
            "new solutions",
            "and new innovations are constantly born to combine agricultural sciences and computer technology. In this diploma work I wanted to incorporate different CNN based object detection algorithms into an Android application that recognizes different cultivated plant seeds through the camera of the smartphone",
            "in real- time. In addition to object detection",
            "it performs calculations of the seeds area",
            "mass",
            "and size with a reference value. The 2"
        ],
        "hash_code": 891645564,
        "department": "cs"
    },
    {
        "author": "Csiki Krisztina",
        "supervisor": "Șef. lucr. Dr. ing. Turos László-Zsolt",
        "year": "2023",
        "abstract": "Nowadays, using sensors has become so popular that we do not even notice how easy it is\nfor us to measure the world around us. Today we have the possibility and the technology to\nmeasure the physical, chemical and the biological characteristics of the world around us.\nThe goal of my thesis was to build a scalable system for sensors, created with the help of\nan Arduino, which helps in the integration of new sensors in the system for users, who may face\na challenge when integrating a new sensor in an environment with Arduino and microcontrollers.\nAt the beginning I had to create a text-based protocol, written with ASCII code, which\nprovides for the user an interface for dynamic configuration of the sensors and for the collective\ndata forwarding.\nSeveral different sensors have been integrated into the sensor system, with which it is\npossible to measure different physical quantities and monitor changes in values, but also an\ninterface for the collected data.\nFor the better understanding of the real-time data collected by the sensors with the help of\nthe Arduino I have also created a desktop application,, through which the real-time data\nmeasured by the sensors connected to the Arduino can be displayed, and it is also possible to\nsave and review the data. The communication between the application and the sensors is realized\nby serial communication.\nI designed the application to be used for laboratory purposes.",
        "keywords": [
            "Arduino",
            "protocol",
            "sensors",
            "desktop application"
        ],
        "hash_code": 3708994830,
        "department": "cs"
    },
    {
        "author": "Csorvasi Endre",
        "supervisor": "Conf.dr.ing Domokos József",
        "year": "2022",
        "abstract": "The paper is about a web application that provides a solution for companies in the\ncomplex task of inventory management.\nNowadays, for every kind of task, there is an object or tool that helpsto perform this\ntask, thus simplifying people's lives. The use of objects, tools has also become common\nwithin companies, as it has allowed them to increase productivity. Because of the many\nobjects used, keeping track of them has become an increasing challenge for companies.\nDue to the virus situation, a large number of companies have given employees the\nopportunity to work remotely .\nTo address these problems, I have created awebapplication that allowscompanies to\neasily keep track of which objects are in the possession of an employee. The application\nshould be available to users in multiple roles. The administrator, who is responsible for the\napplication, whose job is tomanageobjects,users anduserrequests. Usersaretheemployees\nwho can view the objects and request the tools they need. These requests canbeaccepted or\nrejected by the administrators.\nThanks to the webapplication ,itis easy toaccessand doesnotneed tobeconfigured\nfor each employee. All you need to access it is the Internet and a web browser.",
        "keywords": [
            "web application",
            "inventory management",
            "layered architecture 7"
        ],
        "hash_code": 3490846224,
        "department": "cs"
    },
    {
        "author": "Czimbalmos Ákos",
        "supervisor": "Ș.l.dr.ing Turos László-Zsolt",
        "year": "2023",
        "abstract": "The purpose of the document Wireless Sensor Networks Modelling is to demonstrate the\nuse of routing protocols in the design and operation of networks. Routing protocols play a key\nrole in the selection and routing of data packets to reach their destination through the network.\nRouting protocols are based on different algorithms, which have different characteristics and\noperating principles. The aim of this documentation is to create a model to visualise the\napplication of routing protocols, the propagation of packets and the evaluation of data. It also\nprovides a means to compare the performance and efficiency of different routing protocols.\nRouting protocols are critical to the operation of wireless networks. A thorough understanding of\nthe algorithms and their implementations will allow for a better understanding of the operation of\nnetworks, the detection of potential failures, and efficient planning, optimisation and operation.\nThe documentation helps to understand the operation, advantages and limitations of different\nrouting protocols, and helps to simulate networks by providing detailed code for simulations\nwritten in the OMNeT++ framework. Three routing protocols are described, a data-centric one\n(Gossiping), a hierarchical one (LEACH) and a location-based one (GAF), their comparison,\nconclusions drawn and the performance and efficiency of the routing protocols under study.",
        "keywords": [
            "network",
            "protocol",
            "routing"
        ],
        "hash_code": 2506844218,
        "department": "cs"
    },
    {
        "author": "Czirják Márk",
        "supervisor": "Conf. univ. dr. ing. Bakó László, -",
        "year": "2024",
        "abstract": "The central theme of my thesis is SCADA systems, detailing their structure, components,\nand areas of use, as well as the CAN communication protocol used in the industry and embedded\nsystems. It also covers the integration and design of their interconnection, similar to modern\nautomotive applications.\nThe theoretical aim of my thesis is to present the tools necessary for designing and\noperating a system composed of electronic control units, such as microcontrollers, sensors, and\nactuators. My practical aim is the implementation of uniquely tasked control units with unified\nCAN communication, discussing the design phases and demonstrating their operation.\nAchieving both of these goals involves designing and building four control units capable\nof operating as a coherent system, using each other's information, exchanging information between\nthem, storing and processing data, in the presence of a graphical user interface that provides\ncontinuous feedback on the current state of the system.\nThus, my thesis encompasses the theoretical foundations required for creating a system\nusing electronic control units and CAN communication, the technologies used, the selection of\nhardware and software elements, their integration, and the phases of design and practical\nimplementation.",
        "keywords": [
            "SCADA",
            "CAN",
            "ECU",
            "embedded system"
        ],
        "hash_code": 6162401404,
        "department": "cs"
    },
    {
        "author": "Dali Szilárd István",
        "supervisor": "Dr. Szabó László Zsolt",
        "year": "2024",
        "abstract": "The aim of the thesis is to design a web application in order to help the organization process\nof the Annual Student Scientific Conference. This application will help students and organizers\nduring the process of uploading and review of conference papers.\nA previous similar application existed at Sapientia University in Tărgu Mureș, but was\ndeveloped with outdated technologies.\nThe goal was to implement an application, which is based on modern technologies and\nprovides a responsive user interface. In addition to this, it was also a goal customize the application\nfrom an administration interface according to annual needs. Menus and pages for new content are\nconfigurable from the admin dashboard.\nThe application has been successfully implemented and assures uploading of papers on a\ntime based schedule and the review process within deadlines. In addition, new functionalities were\nadded , e.g. task management for the reviewers.\nThe project is designed and developed using modern technologies that ensure the safe, fast\nand smooth operation of the application. The following technologies were used: React.JS,\nExpress.JS, MySQL.",
        "keywords": [
            "Student Annual Conference",
            "conference management",
            "React.JS",
            "Express.JS"
        ],
        "hash_code": 2568934650,
        "department": "cs"
    },
    {
        "author": "Tamás Demény-Székely Adorján",
        "supervisor": "Dr.Ing. Vajda",
        "year": "2022",
        "abstract": "Nowadays, geopositioning can be done on even the smallest devices, such as a smart\nwatch or a smart phone. Each of the GPS applications uses the reverse geocoding feature of the\nmap application to give the user accurate information about their location. To be able to do this,\nthe map application must be backed by a serious database that stores geographic data for millions\nof points around the world.\nThere are many applications that can provide very accurate map data to users. The most known\napplications are Google Maps, Bing Maps, Apple Maps, and the open source OpenStreetMap.\nOne of the great advantages of OpenStreetMap is that it is open source, but it is also one of it’s\nweaknesses, because being open source, anyone can update the data in its database.\nOpenStreetMap allows for local installation through software called Nominatim, this means that\ncompanies can become independent from big companies who provide Map APIs for huge\namount of money. Installing such a server requires a huge amount of disk space, and the amount\nof data continues to grow after installation due to updates.\nThe aim of this dissertation is to develop a software system that allows the Nominatim\nweb server data to be updated automatically, but also allows the user to manage the update\nprocess. The software system consists of two main components, a web application that tests the\ndata. A server collection that allows you to update the data in the database. The web application\nis an ASP.NET Core application implemented with an MVC architectural pattern. This testing\napplication allows the user to test the differences between two Nominatim servers. The server\ncollection consists of three ubuntu servers with Nominatim software installed. Their job is to\nupdate the data in the database.",
        "keywords": [
            "Nominatim",
            "automatic update",
            "OSM database"
        ],
        "hash_code": 9070755036,
        "department": "cs"
    },
    {
        "author": "Dénes Loránd",
        "supervisor": "Dr. Szilágyi László",
        "year": "2023",
        "abstract": "A significant proportion of biological phenomena can be traced back to genetics,\nwhich is based on gene sequences. Decoding these gene sequences represents a\nsubstantial challenge in the field of biological sciences. According to a bold estimate, this\ntask could potentially engage the scientific community for the next five hundred years.\nThe aim of my thesis is to implement a simple gene sequence classification\nalgorithm and integrate this algorithm into a software, equipped with a graphical user\ninterface. This may represent a small step toward the solution of decoding gene\nsequences.\nThis implemented algorithm performs classification based on similarity data from\ngene sequence pairs within a larger sequence dataset. This methodology allows us to\nsimultaneously process large amount of protein sequences and grouping these sequences\nbased on their similarity. This is made possible by working with sparse matrices which\neliminates unnecessary operations, such as addition and multiplication with zero. At the\nsame time, this method has significant memory efficiency, because we only store the\nnone zero values.\nThis method treats the input sequence dataset as a graph. Each protein is assigned\na node within the graph, and the initial edges between the nodes are received as input\ndata from the SCOP95 database. These values were created using the BLAST algorithm\nand they’re form a sparse matrix. This algorithm is a modified form of Markov\nclustering, in which the two main operations, inflation and expansion, work against each\nother. Connected subgraphs remaining in the equilibrium state, defining the final result of\nthe clustering. The main parameter of the algorithm is the inflation rate, which\ndetermines how much the algorithm separates groups from each other.\nThe graphical user interface provides the opportunity to perform the classification\non the 11,944-element SCOP95 dataset or on its subparts, using various settings and can\ndisplay these resulting protein groups. Furthermore, from any group, we can select two\nsequences and observe the results of their alignment, which is implemented using the\nNeedleman-Wunsch algorithm.\nThe algorithm could process up to one million protein sequences in a few hours,\nbut unfortunately an appropriate real dataset was not available for this purpose.",
        "keywords": [
            "Markov clustering",
            "graph",
            "sparse matrix",
            "efficient algorithm",
            "bioinformatics",
            "protein sequence"
        ],
        "hash_code": 8386069326,
        "department": "cs"
    },
    {
        "author": "Dobri Ervin",
        "supervisor": "Dr. Iclănzan Dávid,, conferențiar",
        "year": "2021",
        "abstract": "Flat foot is one of the most common orthopedic problems, which in the absence of gradual treatment\nand correction can also result in serious health problems later on. This unpleasant orthopedic lesion\ncanbetreatedefficientlywithpersistentexerciseofthefoot,withphysiotherapy.\nUnfortunately, most children are bored with the monotony of physiotherapy, in order to crea-\nte consistent perseverance they need the constant supervision, persuasion and encouragement of the\nphysiotherapist and parents. On the other hand, children love to play, so putting physiotherapy in a\nplayfulframeworkcanmaketherehabilitationprocesseasierforeveryoneandincreaseitsefficiency.\nInthedissertationIpresentaself-developed“seriousgame”framework,withthehelpofwhichvi-\ndeogamescanbecontrolledwiththephysiotherapyexercisesusedinthetreatmentoftheflatfoot: the\ngamesarecontrolledbythemovementofthefootinsteadofpressingakey/button. Thesystemdetects\nthe exercises in (near) real time from signals summing up the muscle activity provided by the EMG\n(Electromyography)bandplacedonthechild’sleg,andthensimulatesthekeystrokecorrespondingto\ntheexerciseinthecurrentlyrunninggame,therebycontrollingit.",
        "keywords": [
            "seriousgames",
            "machinelearning",
            "neuralnetworks; 8"
        ],
        "hash_code": 3763886581,
        "department": "cs"
    },
    {
        "author": "Erdős József",
        "supervisor": "Conf.dr.ing. Domokos József",
        "year": "2022",
        "abstract": "The new innovations of the 21st century are making our daily lives easier, one of them\nbeing food ordering apps, which were mainly used during the quarantine period in our region.\nIn my thesis, I will compare several food ordering apps, their usage, and I will also present an\napplication developed by me, that has been in real use for more than three months in the\nvillages near Odorheiu Secuiesc, Cristuru Secuiesc and Gheorgheni.\nI used several technologies to create the application. The restaurant's internal system\nwas written in Node.js/Express.js. The API that serves the mobile app was written in Node.js\nand finally for the mobile application I used React Native.\nIn my thesis I will present in detail how the application works and how to use it. It is\nimportant to mention that I wanted to create a user interface by using the knowledge I gained\nat the university, which provides a ready-to-use system for the users, that is rather simple and\neasy to use. Another interesting aspect is that I made the application available in small\nvillages where online food ordering was not yet available.\n1. Bevezető 1\n2. Szakirodalmi tanulmány 2\n2.2.1. Miért előnyei vannak a natív alapú applikációt fejlesztésnek? 3\n2.2.2. Milyen hátrányai vannak a natív alapú applikációt fejlesztésnek? 3\n1.1. Hamm 4\n1.1.1. Az alkalmazás működésének bemutatása 4\n1.1.3. Közösségi felületeken történő aktivitás és hirdetések 6\n1.1.4. Következtetések 6\n1.2. Deligo 6\n1.2.1. Az alkalmazás működésének bemutatása 7\n1.2.2. Közösségi felületeken történő aktivitás és hirdetések 7\n1.2.3. Következtetések 8\n1.3. Ospătarul 8\n1.3.1. Az alkalmazás működésének bemutatása 8\n1.3.2. Közösségi felületeken történő aktivitás 9\n1.3.3. Következtetések 10\n3. Elméleti megalapozás 10\n3.1. Szerver 10\n3.2. Webszerverek 10\n3.4. Adatbázis szerverek 11\n3.5. E-mail szerverek 11\n3.6. Adatbázis 11\n3.7. Application Programming Interface (API) 13\n3.8. NPM 14\n3.9. Node.js 15\n3.10. Express.js 15\n3.11. MVC (Model-View-Controller) 16\n3. ábra - MVC controller felépítése 16\n4. Részletes tervezés és gyakorlati megvalósítás 18\n4.1. Node.js és Express.js telepítése 18\n4.2. Adatbázis (ER) Diagram 22\n4.2.1. Fő adatbázis tábla kapcsolatok: 23\n4.3. Use case diagram - Telefonos mobilalkalmazás 26\n4.4. Az applikáció rövid bemutatása 26\n4.5. Use case diagram - Étterem belső rendszere 28\n4.6. Az étterem belső rendszerének rövid bemutatása 28\n4.7. Az étterem belső rendszeréhez tartozó diagramok 30\n4.7.1. Activity diagram - kategória 30\n4.7.2. Activity diagram - allergén, csomagolás 31\n4.7.3. Activity diagram - extra, variáns 32\n4.7.4. Activity diagram - termék 33\n4.7.5. Activity diagram - rendelések 34\n4.7.6. Sequence diagram - bejelentkezés 35\n4.7.7. Sequence diagram - termék létrehozása 36\n4.7.8. Sequence diagram - rendelések kezelése 37\n4.8. Étterem belső rendszerének a felépítése 37\n4.8.1. Adatbázis konfigurálása 38\n4.9. Kódrészletek bemutatása 42\n4.9. API 49\n4.9.1. Sequence diagram - API regisztráció 52\n4.9.2. Rendelés létrehozásának a bemutatása 54\n4.9.3. Rendelés elküldésekor SMS értesítés az étteremnek 57\n4.9.4. Rendelés elküldésekor e-mail értesítés az étteremnek és a felhasználónak 57\n5. Applikáció 59\n5.1.1. State diagram 59\n6. Rendszer tesztelése 59\n6.1.1. Regisztráció 59\n6.1.2. Bejelentkezés 61\n6.1.3. Termék létrehozása 62\n6.1.4. Alkategória létrehozása 63\n6.1.5. Kategória létrehozása 66\n6.1.6. Extra feltétek 67\n6.1.7. Allergének 67\n6.1.8. Csomagolás 68\n6.1.9. Variáns 68\n6.1.10. Termék összeállítása: 70\n6.1.11. Városok és szállítási címek manuális feltöltése 71\nKövetkeztetések, továbbfejlesztési lehetőségek 78\n8. Köszönetnyilvánítás 79\n9. Függelékek 80\n10. Irodalomjegyzék 81\n1. Bevezető\nA dolgozat témája a számítástechnika tágabb szakterülethez tartozik, hiszen a\npiackutatás és tervezéstől a szoftverfejlesztés és info-kommunikációs technológiák területén\nát több tudományterületet is érint. Ugyanakkor a számítástechnika tágabb értelemben vett\nterületén is több témát érint: modern adatbázis kezelő rendszerek, operációs rendszerek,\nwebprogramozási és mobil eszközök programozási technológiáját.\nA választott államvizsga témám az érdeklődési körömet tükrözi. Az elmúlt 2 évben\nnagyon sokat foglalkoztatott az adatbázis rendszerek világa és a natív alkalmazásfejlesztés\nIOS és Android rendszerekre. Az egyetemi tanulmányaim alatt SQL lekérdező nyelvet\ntanultam Oracle adatbázis-kezelő rendszerben. Viszont natív alkalmazás fejlesztést nem volt\nlehetőségem tanulni. Webprogramozás tantárgyból egy év alatt sikerült megtanulnom a\nJavaScript alapjait,így belemélyültema JavaScript-enalapulónatív applikációfejlesztésbe.A\nmai világrajellemző,hogymindenki alehetőleggyorsabban szeretnéelvégezni afeladatátígy\na mobil applikációk fejlesztése rohamosan megnőtt az elmúlt pár évben. Már nem elég egy\nátlagos mobil applikáció, előre meg kell tervezni hozzá azadatbázistés ahozzá tartozóAPI-t\nami jelentősen befolyásolja az applikáció gyorsaságát. Továbbáaz utóbbiévekben egyretöbb\nvilághírű szoftvercég kezdte el fejleszteni a saját natív applikáció szoftver megoldásait.Ezen\nszoftverek tanulmányozásával kiderült, hogy applikáció fejlesztéssel szeretnék foglalkozni.\nTöbb választási lehetőség is adott, de mivel a React Native a JavaScript alap programozási\nnyelve, ezért erre esett a választásom.\nAz államvizsga dolgozatom témája egy ételrendelő alkalmazás amely IOS ésAndroid\nrendszereken is fut. Gyakorlatban is igazolni szeretném, hogy egy applikáció gyorsasága az\nelőre jól megtervezett adatbázis és a hozzá tartozó JavaScript-en alapuló API-tól függ. Egy\nolyan applikációt szeretnék tervezni, ahol azétteremtulajdonosokegy webesfelületről tudják\nmódosítani a saját profiljukat, illetve az étlapjukat. Nem utolsó sorban több funkcionalitással\nrendelkező applikációt szeretnék megtervezni. Ugyanakkor szeretném a tiszta kód elmélet\nalapján elkészíteni az applikációt, a webes belsőrendszert, illetveaz applikációhozszükséges\nAPI-t.\n1\nAz államvizsga témának a kimeneteleként az alábbi eredmények várhatóak:\n- Egy olyan komplex MySQL adatbázis megtervezése, amely 50-60 adatbázis táblából\náll;\n- Egy étterem belső rendszerének a felhasználói felületének a megtervezése;\n- Az étterem belső rendszerének a megvalósítása amely Node.js-en alapszik és\nExpress.js keretrendszert használ;\n- Az applikáció felhasználói felület megtervezése;\n- Az applikációhoz szükséges API, amely Node.js-en alapszik és Express.js\nkeretrendszert használ;\n- Az étterem belső applikáció megtervezése ahol csak a rendelések jelennek meg és\nemlékeztetőt küld az elfelejtett rendeléskor;\n- Az étterem belső applikációjához lévő API megtervezése, amely Node,js-en alapszik\nés Express.js keretrendszert használ;\nMunkám eredményeként olyan rendszert szeretnék fejleszteni, mely segítségével\nhibamentesen elindítható Székelyudvarhelyen és Székelykeresztúron. Továbbá a szoftver\nrészletes dokumentációja is fontos szerepet játszik a következő fejlesztések végett. Nem\nutolsó sorban a lehető legtöbb fejlesztést szeretném automatizálni. Pl. számla generálás,\nautomatikus üzenetküldés, push üzenetek küldése, stb.\n2. Szakirodalmi tanulmány\nA rohamosan fejlődő technológiának köszönhetően a mobil applikációk berobbantak\naz elmúlt 5 évben. Ezt bizonyítja, hogy átlagban naponta a Google Play áruházba 3739\napplikációt tesznek közzé. Jelenleg a Google Play áruháznak van a legkedvezőbb ajánlata az\napplikáció publikáláshoz, ezért sokan ki is használják ezt. Egyszeri alkalomra 20 USD-t kell\nfizetni és végtelen applikációt feltölthetünk az áruházba. Emellett még nagyon sok szempont\nközre játszik ehhez a magas napi publikáció számhoz, mégpedig az, hogy egy átlagos\nszámítógépen is fejleszthetünk Androidra applikációt. Míg az IOS fejlesztésre be kell\nszereznünk étlagos áron felüliszámítógépet. Ahogyemlítettem multinacionális vállalkozások\nkidolgozták a natív alapú applikáció fejlesztést. Ez azt jelenti, hogyegyprogramozási kóddal\n2\nfejleszthetünk Android és IOS platformokra applikációt. Kutatásokból kiderült, hogy a\nmultinacionális cégek is egyre nagyobb számban natív alapú applikációkat fejlesztenek.\n2.2.1. Miért előnyei vannak a natív alapú applikációt fejlesztésnek?\nTöbb szempont miatt előnyös a natív applikációk fejlesztése:\n1. A legnagyobb előnye az, hogy egy kóddal fejleszthetjük több platformra\n2. Gyorsan fejleszthető az applikáció\n3. A natív applikáció fejlesztésének nagy közönsége van, ez azt jelenti, hogy előre kész\ncsomagokat telepíthetünk amit csak alkalmazni kell\n4. Sok tutorial videót találhatunk a világhálón.\n2.2.2. Milyen hátrányai vannak a natív alapú applikációt fejlesztésnek?\n1. A legnagyobb hátránya akkor jelentkezik, ha specifikus effekteket szeretnénk\nbeépíteni (pl. animációk)\nA következőkben bemutatott applikációk is native alapúan készültek. A\nkövetkezőkben bemutatott applikációkat felmérésszerűen bemutattam olyan személyeknek,\nakik nem használták még az alkalmazást. A visszajelzéseket mindegyik applikáció\nkiértékelése után bemutatom. Az alábbitáblázatbankiemeltemalegmodernebb nativealapú\nfejlesztésű technológiákat:\nNév Programozási nyelv Tulajdonos\nReact Native JavaScript Facebook\nFlutter C, C++, Dart Google\nIonic JavaScript Drifty\nXamarin C# Microsoft\n1. táblázat – Native applikáció fejlesztési lehetőségek [14]\nA következő 3 alfejezetben 3 helyi jelentőségű hasonló alkalmazást mutatok be: Hamm,\nDeligo és Ospătarul.\n3\n1.1. Hamm\nA Hamm ételrendelő alkalmazást egy csíkszeredai üzletember indította Startup\npályázattal. AszékhelyeCsíkszeredában találhatóés többvárosban,faluban érhetőela Hamm\nalkalmazás mintpéldáulGyergyószentmiklós,Székelykeresztúr, Székelyudvarhelyésezeknek\na városoknak a környező települései. Az alkalmazás 2020 nyarán indult és jelenleg is\nmegtalálható a piacon. 2021-ben indította a cég a futár szolgálatát, amely által több éttermet\nsikerült a rendszeréhez csatolnia. Az éttermek mellett ma már a helyi termelők, cukrászdák,\nboltok és kávézók isregisztrálhatnak azalkalmazásba. Vendégkéntislehetételt rendelni,nem\nkötelező a regisztráció vagy a bejelentkezés, de a fejlesztésük még nem stabil. Vendégként\nvaló vásárláskor több hibát is felfedezhetünk az applikációban.\nTöbb szerződési lehetőség van a Hamm rendszer csatlakozásakor:\n1. az étterem vállalja az étel kihordást és csak a beérkező rendelések alapján fizet\n2. a hamm futárszolgálata kiszállítja a megrendelt ételt és a rendelésért, illetve a futár\ndíjáért is fizet az étterem\n3. legutolsó sorban lehetőség van a telefonon lévő rendeléseket a hamm futárszolgálatra\nbízni, ebben az esetben csak a szállítási díjért kell fizetni\nVárosokra lebontva a Hamm alkalmazás 3 településen van jelen:\nGyergyószentmiklós: összesen 14 étterem található meg az alkalmazásban\nSzékelyudvarhely: összesen 27 étterem található megaz alkalmazásban\nSzékelykeresztúr: összesen 1 étterem található megaz alkalmazásban\n1.1.1. Az alkalmazás működésének bemutatása\nAz alkalmazás megnyitásakor a felhasználónak lehetősége van bejelentkezni vagy\nregisztrálni. A következőkben bemutatom a regisztráció, bejelentkezés, vásárlás és a profil\nadatok megadásának lehetőségeit.\n1. Regisztráció: regisztrációkor a következő adatokat kell kitölteni: telefonszám, e-mail\ncím, név,jelszóés legvégülazadatvédelmitájékoztatóelfogadása.Sikeresregisztráció\nután egy megerősítő oldal jelenik meg, ahová az sms-ben kapott kódot kell beírni.\nMiután megerősítettük a telefonszámunkat egy város választó oldal töltődik be. A\n4\nkiválasztott város után láthatjuk az főoldalt ahol az éttermek, helyi termelők, kávézók\nés cukrászdák jelennek meg.\n2. Bejelentkezés: azelső sikeresbejelentkezés vagyregisztrációután kikell választanunk\nazt a város/falu-t ahonnan ételt szeretnénk rendelni. Ez a lépés csak egyszer jelenik\nmeg, mivel a telefon elmenti a kiválasztott várost, így a következő belépéskor már\nautomatikusan az éttermek, helyi termelők, kávézók és cukrászdák jelennek meg.\nAbban az esetben ha más városból szeretnénk rendelni lehetőségünk van utólagos\nváros módosításra. A város módosítása történhet manuális módon illetve\nhelymeghatározás alapján.\n3. Vásárlási folyamat: fontos megjegyezni, hogy egy vásárlás csak 1 étteremtől\nlehetséges. A vásárlási folyamat hasonlóan működik mint más ételrendelő\napplikációkban. Ki kell választanunk azt az éttermet amelyiktől rendelni szeretnénk\nmajd az étlapon lévő terméket a kosárba kell helyezni. Mielőtt a terméket a kosárba\ntesszük lehetőségünk van extra feltételeket is hozzá rendelni, abban az esetben ha az\nételhez hozzá vannak rendelveextra feltételek.Hakiválasztottuka megrendelnikívánt\nételt akkor a rendelés elküldése felületen meg kell adnunk a szállítási címet és kikell\nválasztanunk a fizetési eszközt. Fizetés megtörténhet a futárnál való fizetés során,\nilletve lehetőségünk van a bankkártyás fizetésre is. Extra opciókat is rejt az\nalkalmazás, például ki lehet választani, hogy szeretnénk-e müanyag evőeszközöket a\nrendelés mellé.\n4. Rendelés elküldése: sikeres rendeléskor automatikusan generálódik a számla és a\nbónusz pont. A számlát e-mailben kapjuk meg és a bónusz pont a vásárlási összegtől\nfüggően hozzá íródik az egyenlegünkhöz. A rendelés állapotát isfolyamatosantudjuk\nkövetni az alkalmazáson belül, illetve másnapra véleményt lehet küldeni az elkészült\nételről és az étteremről.\n5. Profil: új szállítási címet tudunk létrehozni/módosítani, vissza tudjuk nézni az előző\nrendeléseket, kedvenc ételeket is meg lehet jelölni, ismerőst hívhatunk meg,\nmódosíthatjuk a nevünket/e-mail címetés nemutolsó sorbannyelvválasztási lehetőség\nis van.\n5\n1.1.3. Közösségi felületeken történő aktivitás és hirdetések\nA Hamm alkalmazás jelen van Facebookon és Instagramon is. Jelentősen sok reklám\nfut a Facebookon ésazInstagramon. A helyirádióban isfolyamatosanhirdetnek. A közösségi\nfelületeken nem tanító posztjaik vannak, ezért ez meg is látszik a követési számokban.\nGyakran hirdetnek nyereményjátékokat, melyek legnagyobb része a helyi termelőkkel való\negyüttműködés eredménye.\n1.1.4. Következtetések\nÉn azt gondolom, hogy az applikáció felülete nem a legmodernebb és a túlságosan\nerőltetve van a piros szín, amely elveszi a felhasználói élményt. Fejlesztői szemmel\ntökéletesen látható, hogy ez egy natív alkalmazás. A legszembetűnőbbanavigációműködése\npl. IOS eszközökön és az oldalak betöltése navigáció közben.\nA kutatásokból kiderült, hogy az emberek nagy többségben ellenzi a piros színt a\nHamm alkalmazáson belül. Alegérdekesebb kutatás,hogyegyátlagembernehezenboldogult\nel az alkalmazás használatával, míg egy fejlesztőnek ez nem okozott gondot. Az átlag\nembernek nehézkessé vált a termék keresése és a rendelés elküldése.\n1.2. Deligo\nA Deligo ételrendelő alkalmazás úgyszintén egy csíkszeredai üzletember ötlete. A\nszékhelye Csíkszeredában található és csak Csíkszereda és a környező falvaiban elérhető az\nalkalmazás. Az alkalmazás 2020 elején indult és jelenleg is megtalálható a piacon. A deligó\nszolgáltatásnál vásárlás és futárszolgálat is jelen van. Az alkalmazásban csak a legnagyobb\ncsíkszeredai éttermek szerepelnek. A kosarat vendégként össze lehet állítani, de a\nmegrendeléshez szükséges a regisztráció vagy a bejelentkezés. Minden rendelés után %-ban\nfizetni kell. Ez általában 5-15%. Összesen 11 étterem csatlakozott a deligóhozviszontezek a\nCsíkszeredai legjobb éttermek.\n6\n1.2.1. Az alkalmazás működésének bemutatása\nAz alkalmazás megnyitásakor a főoldal jelenik meg. A főoldalon egy görgethető\nlistában megjelennek az aznapi napi menük és alatt a 11 étterem. A következőkben\nbemutatom a regisztráció, bejelentkezés, vásárlás és a profil adatok megadásának lehetőségeit.\n1. Regisztráció: regisztrációkor a következő adatokat kell megadni: név, e-mail cím,\ntelefonszám, jelszó és jelszó újra. Sikeres regisztráció után a főoldalra navigál az\nalkalmazás és lehetőségünk van feliratkozni a hírlevélre. Nem kell a telefonszámot\nmegerősíteni és város választó sem jelenik meg, mivel automatikusan Csíkszereda\nállítódik be regisztráció után. A főoldal ugyanúgy jelenik meg mint a regisztráció előtt.\n2. Bejelentkezés: sikeres bejelentkezés után nincs város választó, mivel Csíkszereda\nválasztódik ki alapértelmezetten.\n3. Vásárlási folyamat: fontos megjegyezni, hogy itt is egy rendelés csak 1 étteremtől\nlehetséges. A vásárlási folyamat hasonlóan működik mint aHamm alkalmazásban.Ki\nkell választanunk azt az éttermet amelyiktől rendelni szeretnénk majd a terméket a\nkosárba kell tenni. Mielőtt a termék kosárba kerül lehetőségünk van megadni extra\nfeltételeket a termék mellé illetve írhatunk megjegyzést ha allergiásak vagyunk\nvalamelyik összetevőre. Miután kiválasztottuk az extra feltételt és megjegyzést is\nírtunk, akkor kosárba kell tennünk a terméket. Ha végeztünk a kosár összeállítással a\nmegrendelői felületre kell navigálni, ahol ki tudjuk választani a szállítási címet és az\nextra lehetőség közül a műanyag evőeszköz igénylését.\n4. Rendelés elküldése: sikeres rendeléskor automatikusan generálódik a számla. A\nszámlát e-mailben kapjuk meg. Nincs lehetőség követni a rendelés állapotát és\nvéleményt adni a termékről/étteremről.\n5. Profil: új szállítási címet tudunk létrehozni/módosítani, vissza tudjuk nézni az előző\nrendeléseket, módosíthatjuk a nevet, e-mail címet és nyelvválasztási lehetőség is van.\n1.2.2. Közösségi felületeken történő aktivitás és hirdetések\nA Deligó alkalmazás jelen van Facebookon és Instagramon is. Sok reklám fut a\nFacebookon. A Hammal ellentétben a rádióban nem hirdetnek. Nagyon kevés a követési\nbázisuk a közösségi felületeken. Nagyon sok nyereményjátékot szerveznek értékes\nnyereményekkel.\n7\n1.2.3. Következtetések\nÉn azt gondolom, hogy az applikáció felülete és működése jóval alább marad a\nHamm-tól. Az applikáció működése néha már idegesítőenrossz. Fejlesztőiszemmel aDeligó\nalkalmazáson is látszik, hogy egy natív alkalmazás.\nA kutatásokból kiderült, hogy az emberek 90%-a nem rendelne az applikációból az\nalkalamzás rossz működése miatt. Egyszerűbb volt egy rendelést leadni a Hamm\nalkalmazásból mint a Deligóból.\n1.3. Ospătarul\nAz Ospătarul ételrendelő alkalmazás egy sepsiszentgyörgyi üzletember ötlete. A\nszékhelye Sepsiszentgyörgyön található és Sepsiszentgyörgyön és környező falvaiban, illetve\nCsíkszereda és környező falvaiban érhető el az alkalmazás. Az ospătarul futárszolgálattal is\nrendelkezik, amely által több éttermet sikerült a rendszeréhez csatolnia. Az alkalmazásban\ncsak kizárólag éttermek találhatóak meg. Vendégkéntnem lehetségesavásárlás,előttebekell\nregisztrálni.\nTöbb szerződési lehetőség van az Ospătar rendszer csatlakozásakor:\n1. az étterem vállalja az étel kihordást és csak a beérkező rendelések alapján fizet\n2. az ospătar futárszolgálata szállítja ki a megrendelt ételt, a rendelések illetve a futár\ndíjáért is fizet\n3. lehetőség van atelefonon lévőrendeléseket azospătar futárszolgálatra bízni,ebben az\nesetben csak a szállítási díjért kell fizetni\nVárosok ahol jelen van az Ospătarul alkalmazás:\nSepsiszentgyörgy: összesen 32 étterem található meg az alkalmazásban\nCsíkszereda: összesen 3 étterem található meg az alkalmazásban\n1.3.1. Az alkalmazás működésének bemutatása\nAz alkalmazás megnyitásakor a felhasználónak lehetősége van bejelentkezni,\nregisztrálni vagy vendégként használni az alkalmazást. Vendégként csak nézelődni lehet, a\n8\nkosárba helyezés funkcióhoz már szükséges a bejelentkezés. A következőkben bemutatom a\nregisztráció, bejelentkezés, vásárlás és a profil adatok megadásának lehetőségeit.\n1. Regisztráció: regisztrációkor a következő adatokat kell kitölteni: keresztnév,\ncsaládnév, e-mail, telefonszám, jelszó és jelszó megerősítése. A felhasználási\nfeltételek elfogadása nem jelenik meg a regisztrációs oldalon. Sikeres regisztrációkor\ne-mailben érkezett linkre kell kattintani, majd meg kell erősíteni az e-mail címünket.\nEz a link aböngészőbenjelenikmeg, miutánsikerülmegerősíteni aze-mail címet,egy\nsikeres megerősítés üzenetet kapunk.\n2. Bejelentkezés: az első bejelentkezéskor meg kell erősítenünk azt a telefonszámot,\namelyet regisztrációkor megadtunk. Sikeres megerősítés után a főoldalra navigál az\nalkalmazás, ahol automatikusan Sepsiszentgyörgy város van beállítva. A második\nbejelentkezéskor nem kell újra megerősíteni a telefonszámot.\n3. Vásárlási folyamat: mint más ételrendelő alkalmazásoknál itt is egyrendelés csak egy\nétteremtől lehetséges. Miután kiválasztottuk, hogy melyik étteremtől szeretnénk\nrendelni rákattintunk a nevére és megjelenik az étlap lista. Hasonlóan működik az\nextra feltétel hozzáadása mint más applikációkban. Miután összeállítottuk a\nkosarunkat a megrendelői felület megnyitása előtt ki kell választanunk a szállítási\ncímet. A megrendelői felületen lehetőségünk van időzíteni a rendelés szállítási idejét,\nkiválaszthatjuk a fizetési módot, amely bankkártyás fizetés vagy fizetés a futárnak\nlehetséges. Lehetőségünk van nem kérni rendelés mellé az evőeszközt.\n4. Rendelés elküldése: sikeres rendeléskor automatikusan generálódik a számla. A\nszámlát e-mailben kapjuk meg. Nincs lehetőség követni a rendelés állapotát.\n5. Profil: módosíthatjuk az összes adatot, amelyet regisztrációkor megadtunk.Lehetőség\nvan beállítani város szerint a push üzeneteket és szállítási címeket módosíthatunk és\nhozhatunk létre.\n1.3.2. Közösségi felületeken történő aktivitás\nAz Ospătarul jelen van Facebookon és Instagramon is. Kevés hirdetésük van a\nFacebookon és az Instagramon viszont rádióban annál többet hirdetnek. A 3 bemutatott\nételrendelő alkalmazásokat összehasonlítva az Ospătarul hirdet legkevésbé\nnyereményjátékokat. A közösségi platformokon megfigyelhető, hogy egy időben profi szintű\n9\nbejegyzési voltak, amelyet egy ügynökség végzett. A szerződés bomlásával a bejegyzések\nminősége romlott, amely arra ad következtetést, hogy az Ospătarul csapata végzia bejegyzés\nlétrehozását.\n1.3.3. Következtetések\nAzt gondolom, hogy az applikáció felülete nem a legmodernebb. A 3 applikációt\nösszehasonlítva a második helyezést adnám az Ospătarulnak. Fejlesztői szemmel tökéletesen\nlátható, hogy ez is egy natív alkalmazás.\n3. Elméleti megalapozás\n3.1. Szerver\nA szerver olyan számítógép vagy szoftver, ami más számítógépek számára a rajta\ntárolt adatok felhasználását a szerver erőforrásainak kihasználását vagy szolgáltatások\nelérését teszi lehetővé. A szervereket úgy tervezik, hogy éveket tudjanak menni kikapcsolás\nnélkül és hiba esetén futás közben az alkatrészeket lehessen cserélni. Egy átlagos\nszámítógépet nem nevezhetünk szerverznek mert nem arra a célra lettek tervezve. A szerver\nalaplapok jóval több RAM-ot tudnak kezelni, mint egy hagyományos számítógép. A\nhagyományos számítógépek 32-64 GB RAM-ot kezel míg a szerverek akár 500-800 GB\nRAM-ot is kezelni tudnak.\nA szervereket többféleképpen csoportosíthatjuk:\n1. Webszerverek\n2. Adatbázis szerverek\n3. E-mail szerverek\n3.2. Webszerverek\nOlyan szerver, amely HTTP protokollon keresztül elérhetővé teszi a helyileg tárolt\nweblapokat és adatokat a felhasználók számára. A webhosting cégek által üzemeltetett\nszerverek, amelyetmásnévenadatközpontoknak (datacenter)nevezetthelyekenhoznak létre.\nA webszerver egyetlen célja, hogy honlapot tároljon és ha egy felhasználó érkezik azt\nmegmutassa neki. Egy webszerver egyszerre több ezer kérést is kell tudjon kezelni egy\nidőpontban. Az, hogy egy webszerver hány kérést tud kezelni az sok tényezőtől függ. A\n10\nlegtöbb webszerveren állandóan fut három fajta szoftver. A szervereken általában Linux és\nWindows operációs rendszer fut. A világon a szervereken 96.3%-ban Linux operációs\nrendszer fut.\n1. HTTP - a honlapok fenntartását szolgálja\n2. FTP - fájlok letöltését/feltöltését szolgálja\n3. ADATBÁZIS - az oldal működéséhez elengedhetetlen adatokat, információkat tárolja\n3.4. Adatbázis szerverek\nAz adatbázis szerver egy olyan Cloud szerver, amelyen már telepítve van egy\nadatbázis kezelő rendszer. Fő feladata, hogy a nagy mennyiségű adatot biztonságba tárolja,\ngyorsan, könnyen elérhetővé tétele. Mint más szerverek esetében az adatbázis szervereken is\náltalában Linux és Windows operációs rendszer fut.\n3.5. E-mail szerverek\nLényegében egy számítógépes rendszer, amely e-maileket küld és fogad. E-mail\nküldéskor egy szerveren megy át, hogy elérje avégsőcélját. Ezafolyamat gyors éshatékony\nde jelentősen bonyolult folyamatból tevődik össze.\n3.6. Adatbázis\nAdatbázisnak nevezzük a nagy mennyiségű, azonos jellemzőkkel és struktúrával\nrendelkező nagy adatmennyiséget. Röviden az adatbázisokat úgy jellemezhetjük, mint a\nszámítógépen tárolt adatok összességét. Az adatbázist különböző műveletek (karbantartás,\ntárolás, lekérdezés, szerkesztés, módosítás, törlés, stb.) elvégzésére alkalmas szoftvereszköz\nkezel, vagyis az adatbázis kezelő rendszer. Ezek a szoftverek teszik lehetővé, hogy az\nadatbázisba beírjuk, majd ezután az adatbázisból kinyerjük a számunkra szükséges\ninformációkat. Fontos különbséget tenni az adatbázis és az adatbázis kezelő rendszer között,\nmivel két különböző dologról beszélünk. Az adatbázis a nagy mennyiségű adatok tárolását\nteszi lehetővé, míg az adatbázis kezelőrendszeraz adott adatbáziskezelésére, működtetésére,\nrendszer- és felhasználói szintű folyamatainak szervezésére szolgál. [26]\n11\nTudni kell, hogy nem minden adathalmazt tekintünk adatbázisnak. Ahhoz, hogy\nadatbázisról beszéljünk meg kell feleljen néhány feltételnek a rendszer:\n- az adatok valamilyen rendszer szerint kell legyenek tárolva;\n- a rendszernek képes kell lennie nagyok sok adat tárolására;\n- az adathalmazon elvégzett műveletek (adatfelvitel, adatmódosítás, adatlekérdezés)\ngyorsan elvégezhetőnek kell lennie;\n- az adatok párhuzamosan (osztott) is elérhetőek kell legyenek;\n- az adatok kezelése biztonságos kell legyen:\n✔ szabályozhatók a hozzáférési jogosultságok;\n✔ biztonságosak a tranzakciók osztott hozzáférése esetén;\n✔ hatékonyan menthetők az adatok.\nAz adatbázistalkotó adatok közöttikapcsolatokatazadatmodell írjale, amelymegadja\na tárolt adatok típusát, a többi adattal való kapcsolatot és az adott adaton végrehajtható\nműveletek listáját. Az adatmodellek eltérései alapján többféle adatmodellt különböztetünk\nmeg.\nA négy legelterjedtebb adatmodell:\n- relációs adatmodell: táblázatokban ábrázolja az adatok kapcsolatrendszerét;\n- rangsorolt adatmodell: faszerkezetben ábrázolja az adatokat (egy gyökér könyvtárból\nelérhető az összes adat, pl.: DOS könyvtár szerkezete);\n- hálós adatmodell: a rangsorolt adatmodell továbbfejlesztett változata, a bonyolult\nkapcsolatok ábrázolását már jobban lehetővé teszi;\n- objektumorientált adatmodell: az objektumorientált programozás módszertanának egy\nrésze, összezárja az adatot annak tulajdonságaival és a rajta végezhető műveletekkel,\namelyet úgynevezett zártságnak nevezünk.\nAz adatbázisok célja az adatok megbízható, hosszú távon tartós, strukturált adatok\ntárolása és gyors hozzáférhetőségének biztosítása.\n12\n3.7. Application Programming Interface (API)\nAz API alkalmazásprogramozási felületet, amely hozzáférést biztosít a szoftveres és\nhardveres erőforrások utasításkészletéhez. Az API a szoftverfejlesztők munkáját könnyíti\nmeg. Az API 1980 óta segít a szoftverfejlesztésben, de a web API-kat csak a 2000-es évek\nkörnyékén hozták létre. Az API-kat három nagy csoportba csoportosíthatjuk:\nWebhely APIk:\nMindenki számára ismert a weboldalakon elhelyezett Google térkép. Ebben az esetben\na webfejlesztők a weboldalakon használják a Google térkép APIját. Amennyiben a Google\nfrissíti ezt az APIt úgy frissül mindegyik webhelyen a térkép. A web APIkat két nagy\ncsoportba sorolhatjuk: RPC API és REST API.\nREST API (Representational State Transfer)\nA REST API HTTP protokollra épül és kliensekből és szerverekből áll. A kliensek\nkéréseket indítanak a szerver felé majd a szerver ezt feldolgozva a megfelelő választ küldi\nvissza. Könnyen bővíthető és rugalmas. A visszaküldött választ megkaphatjuk a következő\nadat formátumokra: JSON, XML, Text, HTML.\nA következő példában bemutatom a különböző kéréseket.\n➔ GET: adatbázisból való lekérdezés\n➔ POST: adatbázisba létrehozás\n➔ PUT: adatbázisban összes adat adatának a cseréje\n➔ PATCH: adatbázisban egy adat adatainak cseréje\n➔ DELETE: adatbázisból való törlés\nGET: Tételezzük fel, hogy egy terméket szeretnénk vásárolni és a következő linket töltjük be\nhttps://www.emag.ro/termek/id/108.\nEbben az esetben egy olyan GET kérést küldünk a szerver felé, ahol a 108-as azonosítójú\ntermék adatait szeretnénk megkapni. Válaszként egy adat formátumot kapunk.\n1. ábra: Adat formátum válasz\nPOST: Tételezzük fel, hogy egy terméket szeretnénk megvásárolni és a következő kérést\nküldjük el: https://www.emag.ro/vasarlas/108.\n13\nA lenti képen látható, hogy a headerben elküldünk egy egyedi token-t, amely azonosítja a\nvásárlót. A REST API a token alapján megkeresi a felhasználó adatait (szállítási cím, név,\ntelefonszám…) és az alapján létrehozza az adatbázisba az új vásárlást. A megvalósítás\nrészben lépésről lépésre bemutatom a folyamatot.\n2. ábra - Egyedi token küldése\n3.8. NPM\nAz NPM vagy más néven Node Package Manager az alapértelmezett csomagkezelő a\nJavaScript futásidejű Node.js fájljához. Az NPM két részből tevődik össze:\n1. parancssori felület eszköz csomagok közzétételéhez illetve letöltéséhez\n2. egy olyan online tárhely, amely JavaScript csomagokat tárol\nTöbb mint 1.3 millió NPM csomag található az npmjs.comweboldalán. A fejlesztők\nkönnyen kereshetnek olyan csomagokat amelyekre szükségünk van. Vannak olyan csomagok\namelyeknek hetente több milliós letöltöttségük van. A hivatalos weboldalon információkat\ntalálhatunk meg a kiválasztott csomagról, ezek a következők lehetnek: forráskód, verziószám,\ndokumentáció és a csomag mérete. Ahogy fentebb említettem az NPM egy parancssori\neszközt is támogat amely által gyorsan és egyszerűen telepíthetőek vagy eltávolíthatóak a\ncsomagok.\nA parancssori eszközt nem kell telepíteni külön a számítógépre mert a Node.js fájlban\nbe van építve. A Node.js telepítése után az NPM csomagokat használhatjuk MacOS, Windows\nés Linux operációs rendszereken. A következőkben bemutatom a leggyakrabban használt\nparancsokat amelyet egyszerűen használhatóak a terminálon keresztül.\nnpm -- version - ezzel a paranccsal tudjuk ellenőrizni, hogy a Node.js és az NPM telepítése\nsikeres volt-e illetve a jelenlegi verzió számot kapjuk meg\nnpm install [CSOMAG_NEVE] - a kiválasztott csomagtelepítése\nnpm install [CSOMAG_NEVE1] [CSOMAG_NEVE2]- több csomagotis telepíthetünk\negyetlen parancs segítségével, úgy hogy a csomag neveit szóközzel választjuk el\nnpm i [CSOMAG_NEVE]- az install szót helyettesíthetjük i-vel telepítés során\n14\nnpm uninstall [CSOMAG_NEVE] - ezzel a paranccsal eltávolíthatjuk a feltelepített csomagot\nabban az esetben ha felel meg az igényünknek\nnpm un [CSOMAG_NEVE] - az uninstall szót helyettesíthetjükun-al\nAz NPM csomagok segítségével a fejlesztők több napot is meg tudnak spórolni az\nadott csomag telepítésével. Az NPM csomagok mind megtalálhatóak a GitLab-on is, ez azért\nnagyon fontos mert ha egy adott csomagot szeretnénk telepíteni előtte le tudjuk ellenőrizni,\nhogy az adott csomag mennyire stabil. Ha a csomag használata közben hibát találunk azt\nkönnyedén jelezhetjük a szerzőnek a GitLab-on keresztül. Saját NPM csomagot bárkinek\nlehetősége van létrehozni és publikálni.\n3.9. Node.js\nA Node.js egy szoftver rendszer, amelyet webszerverek készítésére hozták létre. A\nprogramok JavaScriptben írhatók és aszinkron. A Node.js a Google v8 JavaScript motorból áll\nés számos beépített könyvtárból áll. Ryan Dahl készítette és 2009 januárjában látott\nnapvilágot. A fokozatos növekedésében pedig Joyent, Dahl munkaadója segítette.\n3.10. Express.js\nAz Express.js egy Node.js-en alapuló keretrendszer amelyet a webalkalmazások\nhátterében használnak. Az Express.js keretrendszer nem rendelkezik szükségtelen csomagok,\nkönyvtárak gyűjteményével. Az Express.js-ben készített alkalmazásunkat teljesen testre\ntudjuk szabi, mivel nincs egy meghatározott struktúra amelyet követni kellene. Az Express.js\nkeretrendszert leginkább olyan BACKEND programozásra fejlesztették mivel gyors és\nmegkönnyíti a HTTP kéréseken és válaszokon történő kommunikációt.\nAz Express.js legfőbb előnyei:\n1. Egy olyan keretrendszer amellyel gyorsabban készíthetünk szerveroldali webes\nalkalmazásokat\n2. Az Express.js Node.js-ben készült ezért olyan tulajdonságokat örökölt mint a\nméretezhetőség, rugalmasság, gyorsaság, egyszerűség\n3. Használhatunk különböző csomagokat illetve olyan keretrendszereket\nhasználhatunk mint a Bootstrap a HTML és a CSS-nél\n4. Több millió NPM csomagot használhatunk amelyek Express.js\nkeretrendszerrel kompatibilisek\n5. Az egyik leghíresebb BACKEND keretrendszer a programozók körében\n6. JavaScriptben programozható\n7. Könnyen tanulható\nAz Express.js hátrányai:\n15\n1. Nem optimalizált amely azt jelenti, hogy nagy terhelésnek kitett programok\nesetén nem ajánlatos\n2. Nem biztonságos mivel leginkább BACKEND programozásra készítették így\ntelepíteni kell olyan csomagokat amelyek erre a célra lettek készítve\n3. Nehézkes a hibaüzenetek értelmezése\n3.11. MVC (Model-View-Controller)\nAz MVC egy tervezési minta a webprogramozásban, amelyetszéleskörűen\nalkalmaznak. Az MVC célja különválasztani a funkcionalitás logikát a felhasználói felülettől.\nEz annak a legfontosabb előnye, hogy úgy módosítható meg az egyes kódrészletek, hogy más\nrészekre hatással lenne.\nAModelrészben az adatbázis adatokkal kapcsolatosprogramozás történik, aView részben\ntörténik meg a felhasználói felületek programozása. Ezalatt érthetjük a különböző kinézetű\noldalakakat, szövegeket, űrlapokat stb… A Controller szerepe, hogy a Model és a View részt\nközötti kapcsolatokat összekösse. A következő ábrán látható egy átlagos alkalmazás statikus\nfelépítése:\n3. ábra - MVC controller felépítése\n16\nA következő példában egy általános regisztrációs folyamatot mutatok be\n4. ábra: MVC funkcionális folyamata\n1. A felhasználóelküld egykérést aweboldalon amelyenkitöltötte aregisztrációsűrlapot\nés a regisztráció gombra kattint, amely az index.php fájlban található\n2. A program feldolgozza a kérést és egy alkalmazás példányt futtat\n3. A program megkapja a részletes információkat, az űrlapon kitöltött értékekkel\n4. A program megkeresi azt a kontrollert amely a regisztrációfolyamathozszükséges.A\nregisztráció folyamat egy post kérés, amelyet más néven a REST API-nak nevezzük.\n5. A program példányosítja a kért regisztrációs kontroller és ha a szerver oldali\nvalidációnak megfelelnek a feltételek lefut a fügvény.\n6. A program létrehoz egy új sort az adatbázisban az értékkel\n7. A program kapcsolatban áll a Users modellel\n8. A program kiolvasása az adatbázisból azokat az értékeket amelyek szükségesek a\nprofil oldal megjelenítésére\n9. Abbanazesetben haafelhasználónak e-mailtiskell küldeni regisztrációutánelindula\nfolyamat\n10.Összeáll a háttérben lévő folyamatok összessége\n17\n11. A program befejezi a háttérben lévő kommunikációt és a felhasználónak betöltődik a\nprofil oldal és elindul az e-mail küldés is\n4. Részletes tervezés és gyakorlati megvalósítás\n5. ábra: Full architect diagram\nA fenti diagram az alkalmazás működését ábrázolja a felhasználó és a pincér között. A\nfelhasználó kommunikálását piros nyilak mutatják, a pincérnek a kék nyilak majd legutolsó\nsorban a zöld nyílak pedig a szerverhez való kapcsolódást mutatják. Az étterem belső\nrendszere, az adatbázis és az API amely kiszolgálja a pincért és a felhasználót az a szerverhez\nkapcsolódik. Röviden bemutatom a pincér és a felhasználó közötti kommunikációt.\n1. Felhasználó: A felhasználó összeállította a kosár tartalmát és amint a megrendelés\ngombra kattintott egy kérés(request)-t indított az API felé. Az API kapcsolódik az\nadatbázishoz és küldött utasításokat elvégzi. Ebben az esetben létrehoz egy új sort az\norders táblába és értesíti az éttermet az új rendelésről. Amint megtörtént az étterem\nértesítése és az adatbázisba való írás egy válasz(response)-t küld vissza az\napplikációnak. A válasz lehet sikeres vagy sikertelen így az applikáció egy új oldalt\ntölt be, ebben az esetben egy sikeres megrendelés oldalra navigál az alkalmazás.\n2. Pincér: Ahogy említettem amikor egy új rendelés érkezik a pincér értesítést kap, majd\nbelép az étterem belső rendszerébe amely egy Node.js-en alapuló Express.js\nkeretrendszer. A belső rendszer kapcsolódik az adatbázishoz, a megrendelés felületre\nnavigál és amint a beérkező rendelést elfogadja az API segítségével egy visszaigazolt\ne-mailt küld a felhasználó e-mail címére.\n4.1. Node.js és Express.js telepítése\n1. Legelső lépés a node.js telepítése. A böngészőben rá kell keresni a “download\nnode.js” kifejezésre, majd a node.js hivatalos oldalán ki kell választanunk azt az\n18\noperációs rendszert amelyen szeretnénk dolgozni. Miután kiválasztottuk az operációs\nrendszer le kell tölteni a telepítő fájlt és fel kell telepíteni a számítógépünkre.\n6. ábra: Node.js hivatalos oldala\nNode.js hivatalos oldala: https://nodejs.org/en/download\nSikeres telepítéskor a következő két parancsot kell futtatni ellenőrzés szempontjából.\n1. node -v node verziónak az ellenőrzése\n2. npm -v npm verziónak az ellenőrzése\nHa netalán olyan hibakódot kapunk, hogy az npm vagy node nem található, akkor újra kell\nellenőrizni a telepítést, mert máskülönben nem lehet tovább haladni.\n7. ábra: node és npm telepítés ellenőrzése\n2. Második lépésa projekt létrehozása. Ki kell választanunk azt a könyvtárat, ahol\nszeretnénk a projektet tárolni (Pl. Dokumentumok/Államvizsga). Miután\nkiválasztottuk a könyvtárat nem marad más hátra mint a node.js konfiguráció. Ezt\nmegtehetjük Terminálon keresztül. Fontos ismernünka következő parancsokat:\na. cd - belépés könyvtárba\nb. cd .. - kilépés a könyvtárból\nc. mkdir - könyvtár létrehozása\n19\n8. ábra: Belépés a Dokumentum könyvtárba\n9. ábra: Államvizsga könyvtár létrehozása a Dokumentum könyvtár alatt\n10. ábra: Belépés a létrehozott Államvizsga könyvtárba\n11. ábra: npm init parancs futtatása\nAz npm init parancssor futtatásával meg tudjuk adni a programunknak az alapadatokat\namelyből automatikusan egy package.json generálódik.\n12. ábra: Telepítés ellenőrzése\n20\nA következő lépés az Express.js keretrendszer telepítése. Az “npm install express” paranccsal\ntudjuk telepíteni.\n13. ábra: Express.js telepítése\n21\n4.2. Adatbázis (ER) Diagram\n22\n4.2.1. Fő adatbázis tábla kapcsolatok:\n1. Termékek: A fő termék tábla a “Products” amelyben a következő adatok mentődnek\nel:\na. productImagePath - termék fénykép címe\nb. active - elérhető vagy elfogyott termék jelölés napi menü esetében\nc. isDailyMenu - termék napi menü azonosítása\nd. upsell - termék megkülönböztetése marketing célból\ne. soldOut - elérhető vagy elfogyott termék jelölés\nf. startTime - napi menü termék rendelési idejének a kezdete\ng. endTime - napi menü termék rendelési idejének a vége\nh. restaurantId - az étteremhez rendelt termék azonosítása\nA “Products” táblához kapcsolódik a “ProductTranslations” táblába ahol magyar,\nromán és angol nyelven mentődik a termék neve és leírása. A “Products” táblához hozzá\nkapcsolódik a “ProductHasAllergens” tábla, mely azonosítja a termékhez hozzá rendelt\nallergént. Miután az előbb bemutatott táblákba sorok íródtak a legvégén egy “ProductFinals”\ntáblába gyűjtöm össze az adatokat több fontos táblából. A következőket tartalmazza a tábla:\na. price - termék ára\nb. active - elérhető vagy elfogyott termék jelölés\nc. productId - termék azonosító kulcs (primary key)\nd. variantId - variáns azonosító kulcs (secondary key)\ne. boxId - termékhez rendelt csomagolási ár azonosító kulcs (secondary key)\n2. Variánsok: A fő variáns tábla a “Variants” amelyben a következő adatok mentődnek:\na. sku - variáns rövid elnevezése\nb. maxOption - kötelezően választandó extra feltétek\nc. restaurantId - az étteremhez rendelt termék azonosítása\nd. categoryId - variáns kategóriába sorolása a kategória azonosító kulccsal\nA táblához hozzá kapcsolódik a “Categories” tábla, amely azonosítja a variáns\nkategóriáját. A “Variants” táblához kapcsolódik a “ProductVariantsExtras” tábla, amelyben a\nvariánshoz rendelt opcionális vagy kötelező extra feltétek mentődnek.\n3. Extrák: A fő extra tábla az “Extras” tábla, amelyben a következők mentődnek el:\na. extraType - kötelezően vagy opcionálisan választható extra feltétel azonosítása\nb. sauces - szósz azonosítása\nc. price - ár\nd. restaurantId - az étteremhez rendelt extra azonosítása\nAz “Extra” táblához kapcsolódik az “ExtraTranslations” tábla, ahol magyar, román és\nangol nyelven mentődik az extra neve. Az “Extra” táblához még hozzákapcsolódik az\n“ExtraHasAllergens” tábla, amely azonosítja az extrának a hozzá rendelt allergént.\n4. Kategóriák: a fő kategória tábla a “Categories” amelyben a következő adatok\nmentődnek el:\na. order - az alkalmazásban megjelenő kategória sorrendjének megjelenítése\nb. active - az alkalmazásban megjelenítendő kategóriák\n23\nc. upsell - kosár növelő marketinghez szükséges információ\nd. restaurantId - az étteremhez rendelt kategória azonosítása\nA “Categories” táblához kapcsolódik a “CategoriesTranslations” tábla ahol magyar,\nromán és angol nyelven mentődnek a kategória nevek. A “Categories” táblához kapcsolódik a\n“CategoryProperties” amelyben a fő kategóriához rendelt alkategória nevei összesítődnek.\nA “CategoryProperties” táblához hozzá kapcsolódik a “Properties” tábla, amelyben az\nalkategóriák vannak tárolva.\n5. Rendelések: a fő rendelés tábla az “Orders” amelybena következő adatok mentődnek\nel:\na. totalPrice - rendelés végösszege;\nb. cutlery - műanyag csomagolás igénylés a rendelés mellé;\nc. take - elvitelre vagy szállításra tett rendelés azonosítása;\nd. deletedMessage - étterem rendelésének törlésének az oka;\ne. messageCourier - üzenet a futárnak;\nf. encodedKey - rendelési azonosító szám titkosítása;\ng. deliveryPrice - szállítási költség;\nh. restaurantId - étterem azonosítója;\ni. orderStatusId - rendelés státusz kulcsa (secondary key);\nj. orderDeliveryAddress - elmentett szállítási cím kulcsa (secondary key);\nk. userId - regisztrált felhasználó kulcsa (secondary key);\nl. locationId - város/falu azonosító kulcsa (secondary key);\nAz “Orders” táblához kapcsolódik az “OrderStatuses” tábla, amely azonosítja a\nrendelés állapotát. Az “OrderStatuses” táblához kapcsolódik az “OrdersStatusesTranslations”\ntábla, amely tartalmazza az 5 különböző rendelési státusz állapotot magyar, román és angol\nnyelven. Emellett az “Orders” táblához még kapcsolódik az “OrdersItem” tábla, amelynek\nszerepe a több étel rendelés esetén az ételek megkülönböztetése.\nAz “OrderItem” táblához kapcsolódik az “OrderItemExtras” tábla melyben mentődnek\nazok az extra feltétek, amelyek a termékhez lettek rendelve.\n6. Felhasználók: a felhasználó tábla a “Users” amelybena következő adatok mentődnek:\na. email - felhasználó e-mail címe;\nb. password - felhasználó jelszava;\nc. fullName - felhasználó teljes neve;\nd. phoneNumber - felhasználó telefonszáma;\ne. resetToken - jelszó módosításhoz szükséges link;\nf. resetTokenExpiartion - jelszó módosításásának az időkorlátja a kiküldés\nkezdetétől;\ng. role - jogosultság kezelés;\nh. newsletter - regisztrációkor megadott marketing hírlevélhez engedély kérés;\nA “Users” táblához hozzá kapcsolódik a “UserDeliveryAddresses” amelyben a\nfelhasználó által elmentett szállítási címek tárolódnak.\n24\n7. Étterem: az étterem tábla a “Restaurants” amelyben az összes információ megtalálható\nmint például e-mail cím, telefonszám, jelszó, minimális rendelési összeg, profilkép,\nborítókép stb…\n4.3. Use case diagram - Telefonos mobilalkalmazás\n14. ábra: Use case diagram - Telefonos mobilalkalmazás\n25\n4.4. Az applikáció rövid bemutatása\nAz applikáció React Native programozási nyelvben íródott, ezért elérhető Android és\nIOS operációs rendszereken. Az alkalmazás egy kis százalékát én készítettem majd átadtam a\nfejlesztését egy fejlesztőnek mert az API és az étterem belső rendszerének a fejlesztése\nnagyon időigényes volt és emellett tökéletesen kellett működnie, mivel Székelykeresztúron és\nSzékelyudvarhelyen több mint 500 felhasználó használta az alkalmazást naponta. Mivel a\nmunkatapasztalatom legnagyobb része szoftvertesztelőként szerepel így könnyedén tudtam\nmenedzselni az alkalmazás fejlesztését/fejlődését. A 3 bemutatott ételrendelő alkalmazást\nelemezve egy olyan prototípus alkalmazást állítottam össze, ahol sikerült az elemzést és a\nnegatív visszajelzéseket kiküszöbölni.\nA legelső szempont az operációs rendszereken futó egyedi animációk és beépített\nelemek használata volt. Sikerült elérnem azt, hogy a felhasználók teljes mértékben azt\ngondolták, hogy ez egy egyedileg fejlesztett applikáció.\nA következő legfontosabb lépés a vendégként lévő rendelési lehetőség célkitűzése\nvolt. A Foodnet alkalmazáson belül a rendelés lehetséges regisztrációval, illetve regisztráció\nnélkül is. Természetesen a regisztráció után újra lehetséges a bejelentkezés. Lehetőséget\nadtam az elfelejtett jelszó kérésére, ahol a felhasználó az e-mail címére kérve egy megerősítő\nszámkód kombinációt kell megadnia a jelszó végleges módosítása érdekében. Amennyiben az\ne-mail cím nem létezik a rendszerben ugyanúgy tovább navigál a számkód kombináció\nmegadása felületre, annak érdekében, hogy a hackerek ne tudják kideríteni, hogy az e-mail\ncím létezik vagy sem. Regisztrációkor vagy az első bejelentkezés után egy város választó\njelenik meg, amely kiválasztása után többször már nem jelenik meg. A város módosítására\ntermészetesen lehetőség van. A főoldalon megjelennek azok az éttermek, amelyek a\nkiválasztott városban pillanatnyilag elérhetőek.\nTermék kosárba helyezése csak 1 étteremtől lehetséges. Ha netán egy új étteremtől\nszeretnénk egy ételt vásárolni egy figyelmeztető ablak jelenik meg. Itt törölhetjük a kosár\ntartalmát vagy vissza navigálhatunk arra az étteremre, amelytől termékünk van a kosárban.\nTermék kiválasztásakor egy extra feltétel jelenik meg, ahol a termék mellé extra kérést is\nhozzá csatolhatunk illetve az étterem belső rendszerén beállított extra feltételek jelennek meg.\nRendelés elküldése felületen csak azok a falvak-városok jelennek meg, ahová az\nétterem szállít. Rendelés elküldése előtt írhatunk megjegyzést a futárnak, kiválaszthatjuk,\nhogy kérünk-e műanyag evőeszközt vagy akár a helybeni elvitel bejelölésére is lehetőségünk\nvan. Rendelés elküldésekor megjelenik a Köszönjük felület ezáltal is garantáljuk a\nfelhasználónak, hogy a rendelését sikeresen elküldte. Abban az esetben, ha be vagyunk\njelentkezve láthatjuk a rendelés állapotát, illetve a rendelési adatokat.\nA bejelentkezett felhasználók számára az alkalmazás biztosít egy profil felületet, ahol\nmódosíthatjuk az alapadatokat, új szállítási címet hozhatunk létre és törölhetjük a teljes\nprofilunkat is.\n26\n4.5. Use case diagram - Étterem belső rendszere\n15. ábra: Use case diagram - Étterem belső rendszere\n4.6. Az étterem belső rendszerének rövid bemutatása\nAz étterem belső rendszeréhez csak azok a felhasználók férnek hozzá, akikkel\nszerződés van kötve. Külső felhasználó nem tud regisztrálni a belső rendszerbe, illetve új\nfiókot csak a szuper felhasználó tud létrehozni, erre azért van szükség, mert a belső rendszer\ntitkosított bárki ne tudjon hozzáférni, nézelődni. Sikeres bejelentkezés után a főoldalra navigál\naz alkalmazás, amely a termék lista.\nA következőkben bemutatom, hogy hogyan lehet egy új terméket létrehozni egy\nteljesen új fiók alatt. Fontos megjegyezni, hogy az alkategóriák kivételével bármi módosítható\nutólagosan.\n1. Termék létrehozása előtt az első szempont a kategóriák felépítése. Egy fő kategóriához\nhozzá kell kötelezően kapcsolni egy alkategóriát. Pl. a Pizza kategórián belül az\nétteremnek többféle méretű pizzája van ezért létre kell hozni egy pizza alkategóriát,\namely tartalmazza a különböző méreteket: kicsi pizza, nagy pizza, családi pizza, party\npizza.\nAz alkategória létrehozása után létre lehet hozni a fő pizza kategóriát, ahol meg kell\nadni a hozzá tartozó alkategóriát, amely ebben az esetben a pizza alkategória. A\nkövetkező lépéshez kötelezően rendelkeznie kell az étteremnek 2 fő kategóriának,\nennek érdekében létrehoztam egy Hamburger kategóriát amely tartalmaz egy csirke és\negy sertés alkategóriát.\n2. A második lépés az extra feltétek létrehozása. Extra feltét létrehozásához szükség van\nmegadni a megnevezését illetve az árát. Jelen esetben létrehoztam a következő extra\nfeltéteket: Gomba, Kukorica, Ketchup, Majonéz, Mustár.\n27\n3. A harmadik lépés a variáns létrehozása. Variáns meghatározása: egy termék csak egy\nvariánshoz kapcsolódhat. A variáns tartalmazza a termék kategóriába sorolását, illetve\na hozzá rendelt opcionális vagy kötelezően választandó extrákat.\nA fentebb említett példa alapján létrehozzuk a Pizza kategóriához kapcsolódó\ntermék-variánsokat. Tételezzük fel, hogy az étteremnek van Prosciutto pizzája 4\nkülönböző méretben. A következőkben létrehozom a Prosciutto kicsi pizzát. A variáns\nnevének megadom a prosciutto kicsi nevet, majd kiválasztom a pizza kategóriát és\nazon belül a kicsi pizza alkategóriát. Itt hozzá tudjuk rendelni a harmadik pontban\nlétrehozott extrákat. Jelen esetben hozzá rendelem kötelező extra feltételként a\nKetchup-ot és a Majonézt. Kiválasztom a kötelezően választandó extra értékét 1-re\nmajd kiválasztom a Ketchup és a Majonéz dobozból a kötelező feliratú switch-et, majd\na Mentés gombra kattintok. Ugyan ebből a termékből létrehozok egy nagy\nalkategóriájú prosciutto pizzát amelyhez nem rendelek hozzá extra feltétet.\n4. A negyedik lépés az Allergének feltöltése, mivel minden termékhez kötelezően meg\nkell adni legalább 1 allergént. Az allergének feltöltése gyors és egyszerű. Be kell írni\naz allergén nevét majd a mentés gombra kell kattintani. Jelen esetben létre hozom a\nkövetkező allergéneket: Tojás, Szója, Tej, Nem tartalmaz allergént, Glutén.\n5. Az ötödik lépés a csomagolási árak feltöltése. A csomagolás feltöltéséhez meg kell\nadnunk a csomagolás árát és a megnevezését, majd a mentés gombra kattintva\nmenthető. A megnevezést az csak az étterem belső rendszerén belül látható, az\nalkalmazásban csomagolásként fog megjelenni. Létrehozok egy kis csomagolást 1\nRON értékben és egy nagy csomagolást 2 RON értékben.\n6. Az utolsó lépés a termék létrehozása. A termék létrehozás oldalt megnyitva a bal\noldali részen a termék adatait adhatjuk meg (név, leírás, termék fénykép) a jobb oldali\nrészen pedig a csomagolást és az allergéneket rendelhetőek hozzá a termékhez. Ha az\noldalon lejjebb görgetünk akkor egy lenyíló listában szűrhetünk a variánsra. A\nfentiekben végigvitt példát bemutatva a Pizza Prosciutto termék adatait kitöltve majd\na kiválasztott variáns kategóriák közül kijelöljük az aktuális variánst (prosciutto kicsi)\nmajd itt a dobozban találhatunk egy ár mezőt, ahol lehetőségünk van beárazni a\nterméket. Miután kitöltöttük a termék adatait a mentés gombra kattintva létrehozzuk a\nterméket majd a program a Főoldalra navigál.\n4.7. Az étterem belső rendszeréhez tartozó diagramok\nAz Activity diagramot felosztottam több csoportokra, mivel a teljes Activity diagram túl nagy\nlenne és ezáltal egyben átláthatatlan is.\nKategória csoport: Ezen a diagramon megtalálható a fő kategória és az alkategória\nösszekapcsolása.\nAllergén, csomagolás csoport: Ezen a diagramon megtalálható az allergén és\ncsomagolás szerkesztés illetve új létrehozásának a lépései.\n28\nExtra, variáns:Ezen a diagramon megtalálható az extra feltétel és variáns szerkesztés\nilletve új létrehozásának a lépései.\nTermék: Ezen a diagramon megtalálható a termék szerkesztésilletve új létrehozásának\na lépései.\nRendelések: Ezen a diagramon megtalálható a rendelésekneka kezelése, beleértve a\nrendelés megtekintése, törlése és az új státuszba való sorolásának a lépése\n4.7.1. Activity diagram - kategória\n16. ábra: Activity diagram - Kategória\n29\n4.7.2. Activity diagram - allergén, csomagolás\n17. ábra: Activity diagram - Allergén és csomagolás\n30\n4.7.3. Activity diagram - extra, variáns\n18. ábra: Activity diagram - Extra és variáns\n31\n4.7.4. Activity diagram - termék\n19. ábra: Activity diagram - Termék létrehozás-szerkesztése\n32\n4.7.5. Activity diagram - rendelések\n20. ábra: Activity diagram - Rendelések\n33\n4.7.6. Sequence diagram - bejelentkezés\n21. ábra: Sequence diagram - Bejelentkezés\n4.7.7. Sequence diagram - termék létrehozása\n34\n22. ábra: Sequence diagram - Termék létrehozása\n4.7.8. Sequence diagram - rendelések kezelése\n23. ábra: Sequence diagram - Rendelések kezelése\n4.8. Étterem belső rendszerének a felépítése\nadmin/controllers/products mappa: ebben a mappábantalálható az összes olyan fájl, amely a\ntermék összeállításához szükséges logikát tartalmazzák. Pl.: csomagolás hozzárendelése\ntermékhez, variáns létrehozása, extrák hozzárendelése variánsokhoz, allergének létrehozása…\nadmin/controllers mappa: ebben a fájlban olyan fájlokvannak amelyek felelősek a\nbejelentkezéshez, a rendelések kezeléséhez, keresések a felületen, validációk, hibaüzenet\nmegjelenítése.\nadmin/controllers/routes mappa:ebben a fájlban találhatóaka routok. Különböző felületeknek\na betöltési linkje.\ni18n: ebben a mappában található a statikus szöveg fordításához szükséges .json fájlok.\n35\nimages: a feltöltött termék illetve étterem borító/profil képei ebbe a mappába mentődnek el,\namelyet majd egy link segítségével tudok megjeleníteni az alkalmazásban és a belső\nrendszeren.\nmiddleware: ebben a mappában olyan fájlok találhatóak meg amely a programon belül több\nhelyen használok. Pl.: bejelentkezés ellenőrzése, többnyelvűség\nviews: itt találhatóak meg a felépített HTML oldalak .ejs fájlokban\n4.8.1. Adatbázis konfigurálása\nAz adatbázis konfigurálásához létrehoztam az utilsés amodelsmappát.\nModels mappa: itt tárolom az összes adatbázis táblákatnév szerint megnevezve. Összesen 49\ntáblám van amely ezt azt jelenti, hogy 49 javascript fájlnak kell lennie. Az összes fájlnak egy\na felépítése csak a tábla nevei változnak.\nTermék tábla felépítése:\n24. ábra: Termék tábla felépítése\nRövid kód magyarázat:\nA fenti képen látható, hogy az első két sorban importáltam a Sequelize csomagot, majd a\ncsomag által megadott követelménye alapján felépítettem a “Product” táblát. Az objecten\n36\nbelül konfiguráltam a következő oszlopokat: id, productImagePath, active, isDailyMenu,\nsoldOut.\nAz id objecten belül lévő tulajdonságok megnevezése:\ntype: az oszlop típusának a meghatározása, jelen esetben az id oszlop int típusú\nautoIncrement: ennek segítségével tudjuk növelni az aktuális id értékét plusz 1-el, aminek\nköszönhetően nem fogunk hibát kapni, hogy egy meglévő értékű id-t szeretnénk a táblába\nbeszúrni\nallowNull: ezt a tulajdonságot használva megmondjuk,hogy az id értéke nem lehet null\nbeszúráskor\nprimaryKey: ezzel megjelöljük, hogy az id oszlop lesz a táblában az elsődleges kulcs\nA legutolsó sorban exportáltam a Product változót, hogy a továbbiakban tudjam használni a\nProduct táblát bármely fájlba.\nAdatbázis kapcsolat: util/database.js\n25. ábra: Adatbázishoz való kapcsolódás\nRövid kód magyarázat:\nA fenti képen látható, hogy itt is importáltam az első sorban a Sequelize csomagot és alatta\ninicializáltam az üres db változót (adatbázis). A következő sorban a csomag által megadott\nminutasítást követtem és megadtam a saját hálózaton futó MySQL adatbázis adatait. Itt is\nlátható, hogy a legvégén exportálom a sequelize-t, mert a program futtatásakor meg kell adni,\nhogy melyik adatbázishoz kapcsolódjon.\n37\nTöbb tábla összekapcsolása: util/database/Products.js\n26. ábra: Adatbázis táblák összekapcsolása\nRövid kód magyarázat:\nA fájlnak a tetején importáltam az adatbázis táblákat, majd létrehoztam egy products\nfüggvényt, ahol összekapcsolom a táblákat 1:N kapcsolattal.\nFő fájl: util/database-config\n38\n27. ábra: Adatbázis kapcsolatok konfigurálása\nRövid kód magyarázat:\nLétrehoztam egy összesítő fájlt, ahol a fentebb bemutatott kódrészletek összesülnek. Ebben a\nfájlban meghívom azt a függvényt ahol a táblákat. A legutolsó sorban látható, hogy\nexportáltam a databaseConfig függvényt. Ezáltal már csak a databaseConfig függvényt meg\nkell hívni a programunk fő fájljában és kész is az adatbázisra való kapcsolódás.\nAz adatbázis kapcsolatunk több fájlból tevődik össze, és így sikerült elérni a clean code\nhasználatát.\nFájl: allamvizsga/index.js\nA program fő fájla az index.js. Ebben a fájlban állíthatóak be globálisan az NPM csomagok,\nvagy pl. az adatbázisra való kapcsolódás. A fájl tetején importáltam az eddigiekben\nbemutatott adatbázishoz kapcsolódó függvényeket, majd a fő adatbázis konfigurált függvényt\n(databaseConfig) meghívtam a program futtatása előtt.\nconst express = require(\"express\");\nconst sequelize = require(\"./util/database\");\nconst { databaseConfig } = require(\"./util/database-config\");\nconst db = require(\"./util/database\");\ndatabaseConfig();\nconst PORT = process.env.PORT || 3000;\nsequelize\n.sync()\n.then((result) => {\napp.listen(PORT, () => console.log(`Server started on port ${PORT}`));\n})\n.catch((err) => {\nconsole.log(err);\n});\n39\n4.9. Kódrészletek bemutatása\nA következőkben bemutatok olyan kódrészleteket, amely az alkalmazás felépítéséhez\nszükséges. A bemutatott kódrészletben legtöbb esetben await-et használok, amely mindig\nmegvárja az előző program lefutását, így ennek segítségével több adatbázis beszúrás\nmegtörténhet egy függvényen belül úgy, hogy a program nem dob hibát. A kódrészletek a\nkövetkezők:\n1. olyan változók deklarálása, amelyet a felhasználói felületről kapunk meg\n2. adatbázisból való lekérdezések, amelyeknek az eredményét változókba tárolom\n3. több adatbázis táblába való adatb beszúrása\n4. felhasználói felület betöltése új létrehozás esetében\n5. meglévő csomagolásnak a szerkesztésének a betöltése\n1.\n28. ábra: Változók bemutatása\nA függvényen belül a változók deklarálásával kezdtem. Itt kétféle változót láthatunk. A\nlegtöbb változó értékét a felhasználó felületről kapjuk meg, amint meghívódik a függvény,\nviszont az utolsó deklarált változónak nincs kezdeti érték adva, ami azt jelenti, hogy a\nfüggvényen belül majd értéket adunk és ezt a változót használjuk több helyen. Így követni\ntudjuk a tiszta kód elméletet.\n40\nreq.body[.elem_neve] jelentése: afelhasználófelületentöbbHTML típusú elemtalálható(.ejs\nfájlban), így azokat egyedileg megnevezve elérhetjük az értékét a logikai fájlokban (.js).\n.filter jelentése: egy beépített JavaScript metódus, amely létrehoz egy új tömböt és ebből a\ntömbből szűrhetünk olyan adatokra amelyekre szükségünk lesz a továbbiakban.\n2.\n28. ábra: Lekérdezések megvalósítása\nAz első lekérdezésben létrehozok egy új box változót,amelyet egyenlővé teszek a lekérdezett\nadatokkal. A Sequelize szintaxisát követve lekérdezem azokat a csomagolásokat, amely az\nétteremhez van rendelve.\nAmikor a felhasználó belép a rendszerbe globálisan elmentem az ID-ját, így tudom\nazonosítani, hogy melyik étteremtől szeretném megkapni az adatokat. Sequelize szintaxis\nkonvertálása MySQL nyelvre a következő:\nSELECT * FROM Box WHERE restaurantId = restaurantId;\nA második lekérdezésnél is hasonlóan járok el mint az elsőnél, csak itt az allergéneket\nkérdezem le, emellett összekapcsolom az AllergenTarnsaltion táblával. Sequelize szintaxis\nkonvertálása MySQL nyelvre a következő:\n41\nSELECT * FROM Allergen\nINNER JOIN AllergenTranslation\nON Allergen.id = AllergenTranslation.allergenId\nWHERE restaurantId = restaurantId;\n3.\n29. ábra: Adatbázisba való beszúrás\nLétrehoztam egy olyan függvényt, amelynek csak annyi szerepe van, hogy Product és a\nProductTranslation táblába szúrjon be sorokat. Mivel több adatbázis táblába kerül sor a\nbeszúrásra, ezért azawait-et használom, mely garantálja, az egymás utáni lefutást.\nLétrehoztam egy product változót, amelyet egyenlővé tettem az adatbázisba való beszúrással.\nTermészetesen követtem a Sequelize .create() függvény szintakszisát. A változók\nkódrészletnél létrehoztam egy productId változót, amelynek most értéket adok, ez nem más,\n42\nmint a beszúrt termék id-ja (product.id). Ennek azért van nagy jelentősége, mert ahol\nszükségem van az aktuális beszúrt termék id-ra ott tudok hivatkozni a productId változóra.\nJelen esetben szükségem van az aktuális termék id-ra a ProductTranslation táblában a\nproductId oszlop értékéhez, így máris használhatom a productId változót.\nSequelize szintaxis konvertálása MySQL nyelvre a következő (tételezzük fel, hogy az id\negyenlő 1-el, mivel az első sor a táblában és az 1-es id étterem hozza létre a terméket):\nINSERT INTO Product(id, productImagePath, active, isDailyMenu, upsell, restaurantId)\nVALUES(1, “termék fénykép url címe”, 1, 0, 1, 1);\nINSERT INTO ProductTranslation(title, languageId, description, productId)\nVALUES(“Pizza Prosciutto”, 1, “Termék leírása magyarul”, 1);\nINSERT INTO ProductTranslation(title, languageId, description, productId)\nVALUES(“Pizza Prosciutto”, 1, “Termék leírása románul”, 2);\nINSERT INTO ProductTranslation(title, languageId, description, productId)\nVALUES(“Pizza Prosciutto”, 1, “Termék leírása angolul”, 3);\n4.\n30. ábra: Oldal betöltés konfigurációja\nMagyarázat:\nLétrehoztam egy getAddBox függvényt amelyben a res.render-el megmondom, hogy melyik\nHTML fájlt töltse be az oldal megnyitásakor.\n43\nres.render(“product-conf/edit-box”: HTML fájl betöltésének az elérhetősége, azaz melyik\nHTML fájl töltődjön be, amikor az oldal betöltődik\npageTitle: megnevezem az oldal nevét, ebben az esetben “Add Product”\nediting: megadom, hogy az oldal betöltésekor szerkesztés vagy létrehozás fog történni\npath: fejlesztőnek segítség, hogy a függvény hovátartozik\n5.\n31. ábra: Komplex kódrészlet magyarázata\nAz első 3 sorban deklaráltam három különböző változót.\nPélda link: http://localhost:3000/admin/edit-box/1?edit=true\n44\n1. req.query.edit:segítségével a linkből lehet értékeket kiolvasni. A fenti linken látható,\nhogy a kérdőjel után megtalálható az edit kulcs, amelynek érték van megadva\n2. req.params.boxId:segítségével ugyancsak a linkbőllehet értéket kiolvasni. Ebben az\nesetben a csomagolás szerkesztés link úgy van felépítve, hogy …edit-box/boxId, így a\nreq.params.boxId-vel megkapjuk az aktuálisan szerkesztett csomagolást\nA következőkben készítettem egy validációt. Abban az esetben ha valaki rossz szándékkal\nszeretné használni a belső rendszert és átírja a linket egy más csomagolás id-ra, ha nem az\naktuálisan belépett felhasználóhoz tartozik a csomagolás akkor dobja vissza a csomagolás\nlista oldalra. Sequelize szintaxis konvertálása MySQL nyelvre a következő:\nSELECT * FROM Box\nWHERE Box.id = linkben megtalálahtó id AND Box.restaurantId = belépett felhasználó;\nAmennyiben a belépett felhasználóhoz tartozik a csomagolás lekérdezem a csomagolást, id és\nrestaurantId azonosítása alapján majd átadom az adatokat a HTML fájlnak. Ennek a lépésnek\nazért van szükség mert a felhasználói felületen a csomagolás szerkesztésekor automatikusan\nki kell tölteni az ott megjelenő (ár, megnevezés) mezőket.\n4.9. API\nAz API struktúra hasonlóan van felépítve mint az étterem belső rendszere, csak annyi\nkülönbséggel, hogy a HTML fájl betöltés helyett egy JSON response eredmény érkezik\nválaszként. Az adatbázis műveletek elvégzéséhez a Sequelize csomag felelős.\nA feldolgozott válaszok (reponse) visszaküldésénél beépítettem egy response értéket, amellyel\njelzi az alkalmazásnak, hogy sikeres a kérés (request) vagy nem.\nRegisztráció folyamat bemutatása\nTételezzük fel, hogy a felhasználó az applikációban kitöltötte a kötelező\nmezőket és a regisztráció gombra kattintott.\nAz applikáció feldolgozza az adatokat és elküld egy kérést (request) az API felé,\namely az adatbázisba beír egy új sort, ha az e-mail cím nem létezik és ennek\nfüggvényében egy választ (response) küld vissza.\n45\n32. ábra: Feldolgozott adatok küldése az API-nak\n33. ábra: Sikeres regisztráció válasz küldése\nA fenti képen látható, hogy a regisztráció sikeres volt és az API választ küld az\napplikációnak. A felhasználó azonosítása érdekében egy JWT token generálódik. A\ntokenbe több információt is beépíthető. Jelen esetben a felhasználó ID-ját építettem be,\namellyel a későbbiekben azonosítani tudom a különböző felhasználói tevékenységeket\n(rendelés elküldése, profil módosítása…).\nA JWT token dekódolása esetén láthatjuk, hogy egy user object-be építettem be az\nID-t, amelynek az értéke 1.\n46\n34. ábra: JSON WEB Token enkódolása és dekódolása\nAbban az esetben ha a felhasználó létezik az adatbázisban a következő választ küldöm\naz applikációnak amely által egy hibaüzenet jeleníthető meg az alkalmazásban.\n35. ábra: Validáció tesztelése API-n keresztül\n47\n4.9.1. Sequence diagram - API regisztráció\n36. ábra: Sequence diagram - API regisztráció\nVárosok listázásának bemutatása\nA város listázás API megírásának a lekérdezését más formában írtam meg, mint a fentebb\nbemutatott kódokban, mivel beszeretném mutatni, hogy a Sequelize-ba kétféleképpen írható\nmeg az SQL lekérdezés. Mivel az alkalmazás többnyelvű ezért először szükségem van arra,\nhogy megtudjam milyen nyelven használja a felhasználó az alkalmazást. Ezt mutatom be a\nkövetkezőkben:\n48\n37. ábra: Városok listázásának kód bemutatása\nrouter.get(“/:lang”...: definiálom, hogy a kérés (request) egy get típusú és az URL-ből egy\nértéket szeretnék megkapni\nlet lang = req.params.lang:deklarálom egy változóba az URL-ből érkező értéket\nAz if else ágban annak függvényében, hogy milyen értékű a langváltozó annak függvényében\nalanguageCode-nak értéket adok. A languageCode-nak az SQL lekérdezésekor lesz szerepe.\nAbban az esetben, ha a languageCode értéke nem ro, hu vagy en visszatérítek egy 404-es\nválaszt, mivel ez azt jelenti, hogy valaki rossz szándékból hívja meg az API url-t.\nSQL kód írása Sequelize csomagon belül\n38. ábra: SQL kód írása Sequelize csomagon belül\nA fenti képen látható, hogy az előzőekben bemutatott lekérdezéstől ez különböző. A\nSequelize csomag lehetőséget ad SQL nyelvű kód használatára is.\n49\nA lekérdezés eredményét locations változóba tárolom, amelyet majd a sikeres kérés lefutására\nküldök vissza. Itt látható alanguageCode változóamelyet template literals segítségével\nhasználok fel az SQL lekérdezésben. A languageCode-ot a LocationNameTranslations\ntáblában használom fel, ahol megadom, hogy azokat az értékeket adja vissza ahol a\nlanguageId értéke egyenlő a languageCode-al.\nSQL lekérdezés visszatérítése:\n39. ábra: SQL lekérdezés visszatérítése\nTöbb értéket is visszatérítek annak érdekében, hogy az alkalmazás értelmezni tudja az érkező\nválaszt a szervertől. Látható, hogy az utolsó érték a locations változó, amely tartalmazza az\nSQL lekérdezés tartalmát.\n4.9.2. Rendelés létrehozásának a bemutatása\nA tesztelői idők tapasztalatai alapján egy program tesztelésének az első prioritása a szerver\nvalidáció. Bármilyen adatbázis mentés előtt nagyon fontos, hogy ellenőrizzük a weboldalról\nvagy az applikációtól megkapott adatokat. A következőkben bemutatom a rendeléskor\nelküldött szállítási cím ellenőrzését:\n40. ábra: Rendelés ellenőrzésének kód bemutatása\nAuserDeliveryIdegy tömb amely tartalmazza az összesszállítási címet a felhasználótól. Ezt a\ntömböt a validáció előtt töltöttem fel értékekkel. Abban az esetben ha egy olyan szállítási cím\nérték kerül elküldésre amely nem létezik a tömbben egy 400-as választ küldök így a rendelés\nelküldése sikertelen lesz.\nNem bejelentkezett felhasználó rendelésének a mentése:\n50\nA fentiekben bemutattam, hogy hogyan tudjuk a felhasználót azonosítani token alapján. Ebből\nkövetkezik, hogy ha felküldötttoken-ek nincs értékeakkor egy olyan felhasználó küldi a\nrendelést amely nincs regisztrálva/belépve.\n41. ábra: Nem bejelentkezett felhasználó kezelése\nA fenti képen látható, hogy egy if ágban ellenőrzöm a felhasználó típusát és ha nincs token\nakkor a rendelés elküldése felületről a kitöltött mezőket felhasználva mentem a szállítási cím\ntáblába az adatokat.\n42. ábra: Új rendelése mentése az adatbázisba\nA következő lépés a fő rendelés táblába (Order) az adatok mentése. Itt a következők\nmentődnek: végösszeg, csomagolás igénylése, fizetés rendelés típusa, műanyag evőeszközök\nigénylése, étterem kulcsa, helység kulcsa, futárnak üzenet, szállítási cím, szállítási költség,\nrendelés státusza, rendelés azonosító kódja, melyik nyelven küldött rendelés.\n51\nLátható, hogy a rendelés létrehozását egy tömbbe mentem, mivel szükségünk lesz a rendelés\nID a OrderItem és az OrderItemExtra táblába.\n43. ábra: Rendelés mentéséhez szükséges altáblákba való mentése\nA fő rendelés tábla mellett szükségünk van két kisegítő táblára amelyben a rendelt ételek\ninformációja és a rendelt ételekhez csatolt extra feltételek mentődnek el.\nrendelt ételek információja (OrderItem) tábla: ebbe a táblába elmentődnek a rendelt termékek\nezek pontosabban az adminon összeállított variánsok. A termékeket egy tömben kapom meg,\nígy egymap() függvénnyel végig megyek a tömbön és elmentem minden egyes elem értékét.\nA következők mentődnek el:\n● a termékhez fűzött extra kérés szövegben\n● termékhez rendelt csomagolási ár\n● variáns ID, amely a termék azonosító kulcsa\n● rendelt mennyiség\n● rendelés azonosító, amelyet a fentebb mentett rendelés tömbből kapok meg\n● termék ára\nrendelt ételekhez csatolt extra feltételek (OrderItemExtra) tábla: ebbe a táblába a rendelt\nételekhez csatolt extra feltételek mentődnek, amely kapcsolatban van az OrderItem táblával.\nAz extra feltételeket itt is egy tömbben kapom meg, így amap() függvénnyel végig megyek a\ntömbön és elmentem minden egyes elem értékét. A következők mentődnek el:\n● rendelt mennyiség\n● rendelt termék azonosító kulcsa\n● az extra feltét azonosító kulcsa\n● extra feltét ára\n52\n4.9.3. Rendelés elküldésekor SMS értesítés az étteremnek\nAz SMS küldéshez a https://www.smso.roszolgáltatást választottam mert a legolcsóbb és\nemellett megbízható. Az smso.ro weboldalán belépve egy használati utasítás található. Sajnos\nNode.js-re nem fejlesztettek még kész csomagot ezért a Node.js beépített post request-et\nkellett használjam.\n44. ábra: SMS küldés megvalósítása - 1\nElső lépésként készítettem egy sendSms függvényt amelyben felépítettem azt a tömböt\namelyben meghatároztam a következőket:\n● body: azt az üzenetet amelyet az étterem fog megkapni\n● to: a telefon számot amelyre az SMS kell érkezzen\n● sender: küldés típusát ezt az smso.ro tájékoztatóban található meg\nMivel az SMS küldés post típusú ezért a request.post beépített függvényt használtam. Itt is fel\nkellett építeni egy tömböt amely a következő\n● headers: az smso.ro tájékoztatóban generálódott egy titkos kulcs, mely azonosította a\nfiókomat\n● url: meghívni kívánt API\n● body: az előre elkészített tömb ahol összeállítottam a küldéshez szükséges\ninformációkat\n● json: bejelöltem, hogy JSON típust kell küldenem\n4.9.4. Rendelés elküldésekor e-mail értesítés az étteremnek és a felhasználónak\nVálasztáskor az első szempont a megbízhatóság és a lehető legtöbb ingyenes e-mail küldés\nkeret volt, ezért ahttps://www.mailgun.com szolgáltatástválaszottam. A mailgun.com\nszolgáltatás multinacionális cég ezért Node.js-re telepíthető kész csomag, mely a ‘mailgun-js’.\n53\nA mailgun.js oldalán regisztrálva szükséges volt konfigurálni az e-mail domaint, majd ki kell\ngenerálni különböző kulcsokat. A mailgun fiókban Node.js-re példakód található, mely a\nkövetkező:\n45. ábra: SMS küldés megvalósítása - 2\n46. ábra: SMS küldés megvalósítása - 2\nBelinkeltem a mailgun csomagot majd két külön változóban tároltam a titkos kulcsot. A\nmailgun utasításait követve konfiguráltam egy tömböt a titkos kulcsokkal.\nAz SMS küldéshez hasonlóan elkészítettem az e-mail sablont, amely HTML felépítésű, majd\negy új tömbben konfiguráltam a következő adatokat:\n● from: melyik e-mail címről érkezik az e-mail\n● to: kinek érkezik az e-mail\n● subject: levelek közt figyelemfelkeltő cím\n● html: felépített e-mail sablon\nEzt követően a mailgun tájékoztató oldaláról kimásoltam a függvényt, amely meghívja az\ne-mail küldést.\nA Foodnet rendelés elküldés API végén visszatérítettem az applikációnak a sikeres rendelés\nelküldés üzenetet és ezáltal az applikáció betöltötte a SIKERES RENDELÉS oldalt.\n54\n5. Applikáció\nAz applikációt nem én fejlesztettem, csak megterveztem a működését. Mivel írtam már róla a\nMegvalósítás fejezetben ezért csak egy state diagramot csatolok az applikációban való\nrendelésről.\n5.1.1. State diagram\n47. ábra: Mobilalkalmazás state diagram\n6. Rendszer tesztelése\n6.1.1. Regisztráció\nAz étterem belső rendszeréhez egy új étterem csatlakozásának lehetőségére csak a szuper\nfelhasználónak van engedélye. A regisztráció egyedi, mivel API hívás szükséges az új étterem\nregisztrálásához. Az API meghívásakor egy egyedi kódot kell megadni, amely 100%-osan\nvédi a belső rendszerhez való csatlakozást.\n48. ábra: Titkosított étterem regisztrálása\n55\nA fenti képen látható, hogy az étterem e-mail címét, jelszavát és a titkosított kód megadása\nután létrehozza a felhasználót és a háttérben beállítja az étteremnek az alap információit\nilletve a nyitvatartási időt, amely a felhasználói felületen módosíthatóak.\nAdatbázisba beszúrt értékek:\n● Restaurants táblába beszúrt e-mail és a jelszó sor\n49. ábra: Étterem létrehozása adatbázisba való beszúrása - 1\n● RestaurantInfos táblába az étterem ID-val üresen beállítottelérhetőség és cím három\nkülönböző nyelvvel\n50. ábra: Étterem létrehozása adatbázisba való beszúrása - 2\n● OpeningHours táblába üresen beállított nyitás-zárása hét minden napjára\n51. ábra: Étterem létrehozása adatbázisba való beszúrása - 3\n6.1.2. Bejelentkezés\nBejelentkezés felület: mint látható a felületen nincsregisztrációra lehetőség így csak azok a\nszemélyek léphetnek be a rendszerbe akiknek hozzáférésük van. A bejelentkezés követően a\nprogram automatikusan a Rendelés kezelő felületre navigál.\nRendelés kezelő felület: A felület bal sarkában megtalálható a “Vissza a termékekre”\nmenüpont amely a főoldalra navigál. A rendelés kezelő felületet a rendelések leadása\nkövetkeztében mutatom be.\n56\nFőoldal: Az újonnan regisztrált felhasználóknak több értesítő üzenet is megjelenik a termék\nlétrehozásával kapcsolatosan. A főoldalon a fő termékek jelennek meg míg az oldalsó\nmenüpontban több részre van osztva a termék összeállításához szükséges feltételek/adatok.\n1. Bejelentkezés felület\n52. ábra: Étterem weboldalon való bejelentkezése\n2. Rendelés kezelő\n53. ábra: Rendelések kezelése\n57\n3. Főoldal\n54. ábra: Étterem belső rendszerének a weboldala\n6.1.3. Termék létrehozása\nA következőkben bemutatott példában az étteremnek csak Pizzát és Hamburgert árul.\nA lista kinézetek az összes felületen egyformán néz ki, amely tartalmaz egy szerkesztési\nlehetőséget.\nEgy termék létrehozásához több feltételnek is meg kell felelnie. A Főoldali képen láthatjuk,\nhogy 3 értesítés is megjelenik amelyek a következők:\n1. Termék létrehozásához legalább 2 variánsnak kell lennie!\n2. Termék létrehozásához legalább 2 csomagolásnak kell lennie!\n3. Upsell termék létrehozásához legalább 2 allergénnek kell lennie! → az “Upsell\ntermék” a továbbfejlesztési lehetőségekben bemutatott fejlesztés\nAVariáns oldalra navigálva újabb két értesítés jelenik meg:\n1. Variáns létrehozásához legalább 2 kategóriának kell lennie!\n2. Variáns létrehozásához legalább 2 extrának kell lennie!\nAKategória oldalra navigálva újabb értesítés jelenikmeg:\n1. Kategória létrehozásához legalább 2 alkategóriának kell lennie!\nAz értesítéseket elemezve a termék létrehozása előtt következőket kell tennünk prioritás\nszerint rendezve:\n● Létre kell hoznunk kötelezően:\n1. 2 alkategóriát\n2. 2 kategóriát\n58\n3. 2 extra feltételt\n4. 2 allergént\n5. 2 csomagolást\n6. 2 variánst\n6.1.4. Alkategória létrehozása\n55. ábra: Alkategória létrehozása\nAz alkategória létrehozásának a lépéseit pirossal bekereteztem illetve számmal megjelöltem,\namelyek a következőket jelenti:\n1. Az alkategória felületet való navigálást az 1-es pontban nyitott menüben találhatjuk\n2. Az alkategóriák listázása illetve létrehozása/szerkesztésének a menüpontja. A\nlétrehozás gombra kattintva a létrehozás felület betöltődik.\n3. A Pizza kategória létrehozásához szükségünk lesz egy Pizza alkategóriára itt\nmegadhatjuk az alkategória nevét 3 különböző nyelven\n4. A pizza variációinak amegadása. Haazétteremárulkis, nagyés közepespizzátakkor\naz első dobozban megadja a kis pizza nevét három különböző nyelven majd az “Új\nhozzáadás gombra” kattintva megjelenik egy újabb doboz, ahol megadhatja a\nkövetkező variációt.\nA Pizza és a Hamburger alkategóriákat létrehozva az alábbi képen láthatjuk a létrehozott\nalkategóriákat. A szerkesztés gombra kattintva lehetőségünk van új variációt hozzáadni az\nalkategóriához.\n59\n56. ábra: Alkategória lista\nAdatbázisba való mentés:\nA Properties táblába bekerült 1-es ID-ként a Pizza, 2-es ID-ként a Hamburger. A\nPropertyTranslations táblában pedig látható a Pizza és a Hamburger beszúrása 3 különböző\nnyelven.\n57. ábra: Fő kategória adatbázisba való mentése\n60\nA PropertyValueTranslations táblába pedig bekerültek azok az értékek amelyek az\nalkategóriáknak a variációi. Ennek a működéséhez létrehoztam a PropertyValues amely\nösszekapcsolja az alkategória ID-kat.\n58. ábra: Alkategória adatbázisba való mentése\n6.1.5. Kategória létrehozása\n59. ábra: Kategória létrehozás felület\nA kategória létrehozását hasonlóan találjuk meg mint az alkategória létrehozását, csak azzal a\nkülönbséggel, hogy a Kategória menüpontra kell kattintani. A kategória utólagos szerkesztése\nlehetséges.\nA bal oldalon bejelölt dobozban megadjuk a kategória román és magyar nevét. Fontos\nmegjegyezni, hogy a megadott név fog megjelenni az alkalmazásban. A jobb oldalon jelölt\ndobozban hozzá kell rendelnünk azt az alkategóriát amely hozzá tartozik.\n61\nJelen esetben megadjuk a Pizza kategória nevét és hozzárendeljük a Pizza alkategóriát. Ezáltal\na variáns létrehozásakor kiválaszthatjuk, hogy csak a nagy pizzához akciósan jár egy doboz\nCoca Cola.\nAdatbázisba való mentés:\nA Categories táblába beszúródott a létrehozott két kategória:\n60. ábra: Kategória mentése adatbázisba\nA CategoryTranslations táblába beszúródott a kategóriák három nyelven megadott értéke:\n61. ábra: Kategória többnyelvű mentése adatbázisba\nA két tábla mellett használtam egy összekapcsolt táblát amelyben tárolom a kategóriához\nrendelt alkategóriákat:\n62. ábra: Kategória azonosítására szükséges információk\n62\n6.1.6. Extra feltétek\nAz extra feltétek létrehozása/szerkesztése hasonlóan működik mint a kategóriák\nlétrehozása/szerkesztése. A felületen 3 mező található ahol kötelezően meg kell adni az extra\nfeltét árát és a megnevezését.\nAdatbázisba való beszúrás: hasonlóan működik minta kategóriáknál. Az Extras táblában\nmentődik a létrehozott extra feltétek. Az ExtraTranslations táblába pedig beszúródik a\nlétrehozott név 3 különböző nyelven.\n6.1.7. Allergének\nAz allergének mentése/szerkesztése hasonlóan működik mint az extra feltétek, csak itt az\nallergén nevét kell kötelezően megadni.\nAdatbázisba való beszúrás: az Allergens táblában mentődik az allergén létrehozása, az\nAllergenTranslations táblában mentődik a három különböző nyelven létrehozott név.\n6.1.8. Csomagolás\nA csomagolás mentése/szerkesztése hasonlóan működik mint az allergének. A különbség egy\nannyiban tér el, hogy kötelezően meg kell adni a csomagolás árát illetve a nevét. A\ncsomagolás neve csak az étterem belső rendszerében fog megjelenni az applikációban csak az\nértéke jelenik meg.\nAdatbázisba való beszúrás: mivel itt nincs szükség három különböző nyelvre ezért a Boxes\ntáblába mentődik a csomagolás neve és ára.\n63\n6.1.9. Variáns\n63. ábra: Variáns létrehozás felület\nA variáns felületegy kicsit komplexebbatöbbihezképes ezértkülönblokkokraszeleteltem és\nezeket megszámoztam amelyeknek a magyarázata a következő:\n1. A variáns oldal megtalálása a menüben\n2. Mint látható a variánsnak egy nevet kell adni amely csak az étterem belsőrendszerén\nfog szerepelni. Olyan nevet kell választani amelyet könnyenazonosítani lehetavégső\ntermék összeállításon. Pl.: kicsi prosciutto pizza\nA következő lépés kiválasztani azt a kategóriát amely termékhez fog kapcsolódni az\nadott variáns. A blokkban megtalálható még egy lenyílószámlista,ahollehetőségünk\nvan beállítani, hogy az adott termékhez hány extra feltétel megvásárlása kötelező\n3. A másodikblokkbankiválasztott kategóriaalkategóriáinak avariációja jelennekmega\nlenyílólistában.Ennek ajelentőségeazapplikációban jelenikmeg. Azapplikációban a\nPizza kategóriára kattintva 2 variáns fog megjelenni: kicsi, nagy\n4. Megadhatjuk, hogy a termékhez melyik extra feltételek hozzárendelése jelenjen meg\nkötelezőként illetve választhatóként\nAdatbázisba való beszúrás:\n64\nA variáns rész működéséhez 3 adatbázis táblára volt szükségem, mivel több fontos adat\nmentődik egy időben. Ezek a következők:\n● Variáns alap adatainak a mentése -Variants tábla\n● Variánshoz rendelt alkategória és alkategória variánsának azonosítása -\nVariantPropertyValues tábla\n● Variánsokhoz hozzárendelt aktív/inaktív extra feltételeinek az azonosítása -\nProductVariantsExtras tábla\n6.1.10. Termék összeállítása:\n65\n64. ábra: Termék létrehozás felület\nElérkeztünk a végső termék összeállításához. Mivel a termék létrehozása is egy komplex\nfelület ezért külön blokkokra és azokat megszámozva mutatom be a felület működését.\n1. A termék oldal megtalálása a menüben\n2. A termék alap adatainak a megadása\n3. A létrehozott csomagolások közül lehetőség van maximum egy csomagolási árat a\ntermékhez rendelni\n4. Ugyancsak a létrehozott allergének közül legalább 1 allergént hozzá kell rendelni a\ntermékhez. Ez teljes mértékben az étterem felelőssége\n5. A lenyíló listából kiválasztjuk azt a kategóriát amely a létrehozandó termékhez\nkapcsolódik. Ennek kiválasztása következtében csak a kiválasztott kategóriájú\nvariánsok jelennek meg. A kiválasztott variáns bepipálásával majd az ár megadásával\nmenthető a termék.\nAdatbázisba való beszúrás:\nAz program tökéletes működése érdekében négy táblát kellett használjak, amelyek a\nkövetkezők:\n● Termék alap adatainak a mentése - Products tábla\n● Termékhez rendelt aktív/inaktív allergének -ProductHasAllergenstábla\n66\n● Termék többnyelvű adatainak a mentése - ProductTranslations tábla\n● A termékhez rendelt aktív/inaktív variánsok azonosítása - ProductFinals tábla\n6.1.11. Városok és szállítási címek manuális feltöltése\nAz étterem belső rendszere nem rendelkezik szuper felhasználóval ezért a városokat\nilletve a szállítási címeket SQL szkript segítségével kell feltölteni.\nVárosok feltöltése:\nLocationNames: a főtábla amely több táblához is kapcsolódik:\n● LocationNamesTranslations: ebben a táblában a város/falu többnyelvűsége mentődik\n● Locations: ez a tábla határozza meg, hogy az étterem melyik város/faluban található\n● DeliveryPrices: ebben a táblában határozható meg az éttermek kiszállítási igényének\nbeállítása\nSQL szkriptek futtatása az alkalmazás megnyitása előtt:\nLocationNames:\nINSERT INTO LocationNames (id, active, type, url, createdAt, updatedAt)\nVALUES (1, 0, 1, 'szekelyudvarhely', '2022-04-23 15:38:35', '2022-04-23 15:38:35');\nLocationNameTranslations:\nINSERT INTO LocationNameTranslations (id, name, createdAt, updatedAt, locationNameId,\nlanguageId)\nVALUES (1, 'Odorheiu Secuiesc', '2022-04-23 15:38:35', '2022-04-23 15:38:35', 1, 1);\n67\nINSERT INTO LocationNameTranslations (id, name, createdAt, updatedAt, locationNameId,\nlanguageId)\nVALUES (2, 'Székelyudvarhely', '2022-04-23 15:38:35', '2022-04-23 15:38:35', 1, 2);\nINSERT INTO LocationNameTranslations (id, name, createdAt, updatedAt, locationNameId,\nlanguageId)\nVALUES (3, 'Odorheiu Secuiesc', '2022-04-23 15:38:35', '2022-04-23 15:38:35', 1, 3);\nLocations:\nINSERT INTO Locations (id, createdAt, updatedAt, restaurantId, locationNameId)\nVALUES (1, '2022-04-23 15:38:35', '2022-04-23 15:38:35', 4, 1);\nDeliveryPrices:\nINSERT INTO DeliveryPrices (id, deliveryPrice, delivery, minimumOrder, freeDelivery,\ncreatedAt, updatedAt, restaurantId, locationId)\nVALUES (1, 5, 1, '15.9', 30, '2022-04-23 15:38:35', '2022-04-23 15:38:35', 4, 1);\nRendelés elküldésének folyamata telefonos applikációban\nAz alkalmazást megnyitva majd az első oldal betöltésekor (1.0 kép) lehetőségünk van\nkiválasztani a rendelés típusát. A rendelés elküldése vendég típusú felhasználóval mutatom\nbe. A “Regisztráció nélkül folytatom” gombra kattintva betöltődik a város választó oldal (1.1\nkép). Székelyudvarhely város kiválasztása során az étterem lista töltődik be (1.2 kép).\n68\n65. ábra 66. ábra\n67. ábra\nA “The Godfather” éttermet kiválasztva betöltődik az összeállított étlap, amelyet a tesztelés\nfejezetben mutattam be. A kicsi pizzát kiválasztva megjelenik az extra feltét oldal, itt hozzá\ntudunk adni extra feltételeket a pizzához. A hamburger létrehozásakor nem adtam meg extra\nfeltétel lehetőséget, így csak magát a hamburgert lehetséges megvásárolni.\n69\n68. ábra 69. ábra 70. ábra\nA kosár oldalra navigálva majd a rendelés felületen kitöltött adatokkal elküldtem a rendelést.\nAmennyiben a rendelés sikeres betöltődik a Köszönjük oldal.\n70\n71. ábra 72. ábra 73. ábra\nRendelés feldolgozása\nAdatbázisba való beszúrás:\nA rendelés nyomon követésének és a tökéletes működése érdekében hat adatbázis táblát\nkellett használnom. A fentebb elküldött rendelést mutatom be a következő példában.\n1. Orders tábla: ebben a táblában csak a fő adatokat mentődnek el, majd a rendelés\nazonosítójára hivatkozok a többi táblában\n2. OrderItems tábla: ebben a táblában elmentem azokat a variáns ID-kat, amelyek\nmegrendelésre kerültek hívatkozva az 1-es pontban lévő rendelés ID-ra\n3. OrderItemExtras tábla: ebben a táblában elmentem azokat az extra feltételeket,\namelyek kiválasztásra kerültek a variáns mellé\n71\n4. OrderDeliveryAddresses tábla: ebben a táblában elmentem a szállítási cím adatokat\nvendég és regisztrált felhasználó esetében is. Erre azért van szükségem mert ha egy\nfelhasználó módosítja a szállítási címét nem a megadott rendelési cím fog megjelenni\naz étterem belső rendszerén\n5. OrderStatuses tábla: ebben a táblában mentődik, hogy hány rendelési státusszal\ndolgozik a rendszer\n6. OrderStatusTranslations tábla: ebben a táblában több nyelven meghatározódik a\nstátusz neve\nRendelés értesítések\nA rendelést követően a rendszer automatikusan értesíti a felhasználót e-mailen keresztül, míg\naz éttermet e-mailen és SMS-ben is értesítést kap az új rendelésről.\n74. ábra\n75. ábra\n72\nRendeléskezelő felület\n76. ábra: Beérkező rendelés felület\nA rendeléskezelő felületen 6 oszlop látható amely a rendelési állapot státuszát szimbolizálja.\nAz első és második oszlopban található rendelési kártyákon csak egy jobb nyíl található,\namellyel a pincér kattintás segítségével folyamatosan tudja frissíteni a rendelés állapotát. Az\n“Elkészítve” oszlopban már egy vissza gomb is található, amely segítségével a rendelési tétel\nvissza helyezhető a “Felvett rendelések” oszlopba. Amennyiben a pincér az “Új rendelések”\noszlopból a “Felvett rendelések” oszlopba helyezi a rendelést a rendszer automatikusan\nértesíti a felhasználót, hogy a rendelés feldolgozás alatt áll.\nValamely rendelési kártyára kattintva megjelenik egy ablak, ahol a leadott rendelés részletei\nlátható.\n73\n77. ábra: Beérkező rendelés részletek felület\n7. Következtetések, továbbfejlesztési lehetőségek\nA kész rendszert rengeteg új dologgal lehet fejleszteni mind az étterem belső\nrendszerén és az applikációban. A továbbfejlesztési lehetőségek bemutatását külön felosztva\nmutatom be.\nÉtterem belső rendszere:\n1. Szuper felhasználó: olyan szerepkörrel kellene rendelkeznie amely a teljes rendszeren\njogosultsága van. Ezalatt értem azokat a műveleteket is ahol jelenleg SQL szkripteket\nkell futtatni a rendszer működéséhez. a városok/falvak UI felületről való feltöltése,\nhozzáférés az összes rendelés módosításához stb…\n2. Étterem szállítási címek beállítása: jelenleg csak az tudja beállítani az étteremhez\nrendelt szállítási címeket, aki érti az adatbázis kezeléshez. Ennek megoldására egy új\nUI felületre lenne szükség, ahol az étterem saját magának be tudná állítani a címeket\nés a költségeket\n3. Napi menü: már a legtöbb étterem rendelkezik napi menü ajánlattal ezért egy új napi\nmenü termék UI feltöltés felületre lenne szükség, ahol minden információt be tud\nállítani. Pl.: mettől-meddig rendelhető, előrendelés lehetőség stb…\n4. Extra ajánlat: ez a rész is hasonlóan kellene működnie, mint a jelenlegi termék\nfeltöltésnek csak egy annyi különbséggel, hogy ezek a termékek az applikáció kosár\nfelületen vagy a megrendelői felületen jelennének meg\n5. Statisztika nyomonkövetése: az étterem belső rendszerén nincs statisztika információk\nkövetésének lehetősége. Ez egy nagyon hasznos információ lehet az étteremnek.\nApplikáció:\n1. Extra ajánlat: az étterem belső rendszerének a 4. pontja határozza ezt meg. A\nlegfontosabb, hogy ezek a termékek csak a kosár illetve megrendelői felületen\njelenhetnek meg kedvezményes áron\n2. Napi menü: ezt a pontot az étterem belső rendszerének a 2. pontja határozza meg. Az\nétterem étlapját megnyitva kiemelve megjelenik a napi menü rendelése illetve\nelőrendelésének a lehetősége\n3. Kiemelt ajánlatok az étterem lista oldalon: ez a fejlesztés egy havidíjért cserébe az\nétterem lista tetején megjelenne egy extra ajánlat, mely kattintásra az étterem étlapja\njelenik meg illetve automatikusan kosárba tevődik az extra ajánlat.\n74\n8. Köszönetnyilvánítás\nEzúton szeretnék köszönetet mondani mindenek előtt konzulens tanáromnak, dr.\nDomokos Józsefnek, a Sapientia EMTE egyetemi adjunktusának.\n9. Függelékek\nÁbrák jegyzéke\n1. ábra: Adat formátum válasz 13\n2. ábra - Egyedi token küldése 14\n3. ábra - MVC controller felépítése 16\n4. ábra - MVC funkcionális folyamata 17\n5. ábra - Full architect diagram 18\n6. ábra - Node.js hivatalos oldala 19\n7. ábra – Node és npm telepítés ellenőrzése 19\n8. ábra - Belépés a Dokumentum könyvtárba 19\n9. ábra - Államvizsga könyvtár létrehozása a Dokumentum könyvtár alatt 20\n10. ábra - Belépés a létrehozott Államvizsga könyvtárba 20\n11. ábra – Npm init parancs futtatása 20\n12. ábra – Telepítés ellenőrzése 20\n13. ábra - Express.js telepítése 21\n14. ábra – Use case diagram - Telefonos mobilalkalmazás 25\n15. ábra – Use case diagram - Étterem belső rendszere 27\n16. ábra – Activity diagram - Kategória 29\n17. ábra - Activity diagram - Allergén és csomagolás 30\n18. ábra – Activity diagram - Extra és variáns 31\n19. ábra - Activity diagram - Termék létrehozás-szerkesztése 32\n20. ábra – Activity diagram - Rendelések 33\n21. ábra – Sequence diagram - Bejelentkezés 34\n22. ábra – Sequence diagram - Termék létrehozása 34\n23. ábra – Sequence diagram - Rendelések kezelése 35\n24. ábra - Termék tábla felépítése 36\n25. ábra – Adatbázishoz való kapcsolódás 37\n26. ábra – Adatbázis táblák összekapcsolása 38\n27. ábra - Adatbázis kapcsolatok konfigurálása 38\n28. ábra - Lekérdezések megvalósítása 40\n29. ábra - Adatbázisba való beszúrás 42\n30. ábra – Oldal betöltés konfigurációja 43\n31. ábra – Komplex kódrészlet magyarázata 44\n75\n32. ábra - Feldolgozott adatok küldése az API-nak 46\n33. ábra – Sikeres regisztráció válasz küldése 46\n34. ábra – JSON WEB Token enkódolása és dekódolása 47\n35. ábra – Validáció tesztelése API-n keresztül 47\n36. ábra – Sequence diagram - API regisztráció 48\n37. ábra – Városok listázásának kód bemutatása 49\n38. ábra – SQL kód írása Sequelize csomagon belül 49\n39. ábra – SQL lekérdezés visszatérítése 50\n40. ábra – Rendelés ellenőrzésének kód bemutatása 50\n41. ábra – Nem bejelentkezett felhasználó kezelése 51\n42. ábra – Új rendelése mentése az adatbázisba 51\n43. ábra – Rendelés mentéséhez szükséges altáblákba való mentése 52\n44. ábra – SMS küldés megvalósítása - 1 53\n45. ábra – SMS küldés megvalósítása - 2 54\n46. ábra – SMS küldés megvalósítása - 3 54\n47. ábra – Mobilalkalmazás state diagram 55\n48. ábra – Titkosított étterem regisztrálása 55\n49. ábra –Étterem létrehozása adatbázisba való beszúrása - 1 56\n50. ábra – Étterem létrehozása adatbázisba való beszúrása - 2 56\n51. ábra – Étterem létrehozása adatbázisba való beszúrása - 3 56\n52. ábra – Étterem weboldalon való bejelentkezése 57\n53. ábra – Rendelések kezelés 57\n53. ábra – Étterem belső rendszerének a weboldala 58\n54. ábra – Étterem belső rendszerének a weboldala 58\n55. ábra – Alkategória létrehozása 59\n56. ábra – Alkategória lista 60\n57. ábra – Fő kategória adatbázisba való mentése 60\n58. ábra – Alkategória adatbázisba való mentése 61\n59. ábra – Kategória létrehozás felület 61\n60. ábra – Kategória mentése adatbázisba 62\n61. ábra – Kategória többnyelvű mentése adatbázisba 62\n62. ábra – Kategória azonosítására szükséges információk 62\n63. ábra – Variáns létrehozás felület 64\n64. ábra – Termék létrehozás felület 66\n65. ábra – Mobilalkalmazás főoldal 69\n66. ábra – Mobilalkalmazás város választó oldal 69\n67. ábra – Mobilalkalmazás étterem lista oldal 69\n68. ábra – Mobilalkalmazás termék lista oldal 70\n69. ábra – Mobilalkalmazás termék részletek oldal - 1 70\n70. ábra – Mobilalkalmazás termék részletek oldal - 2 70\n71. ábra – Mobilalkalmazás kosár oldal 71\n72. ábra – Mobilalkalmazás megrendelői oldal 71\n73. ábra – Mobilalkalmazás sikeres rendelés oldal 71\n74. ábra – SMS értesítés 72\n76\n75. ábra – E-mail értesítés 72\n76. ábra – Beérkező rendelés felület 73\n77. ábra – Beérkező rendelés részletek felület 73\n10. Irodalomjegyzék\n[1] MVC bemutatása: https://people.inf.elte.hu/csubix/mvc.html\n[2] Node.js hivatalos oldala: https://nodejs.org/en\n[3] Express.js hivatalos oldala: https://expressjs.com\n[4] React Native hivatalos oldala:https://reactnative.dev\n[5] Sequelize hivatalos oldala:https://sequelize.org\n[6] MySQL hivatalos oldala: https://www.mysql.com\n[7] Berg Craig, ”JavaScript Programming Made Easy for Beginners & Intermediates (Step\nBy Step With Hands On Projects)”, 2009\n[8] Jennifer Windom, “Adatbázisrendszerek - Alapvetés - Második, átdolgozott kiadás”,\n2009\n[9] Learning React Native: Building Native Mobile Apps with JavaScript\n[10] Bonnie Eisenman, “Learning React Native: Building Native Mobile Apps with\nJavaScript”, 2015\n[11] Jonathan Wexler, ”Get Programming with Node.js”, 2019\nUNIVERSITATEA SAPIENTIA DIN CLUJ-NAPOCA\nFACULTATEA DE ȘTIINȚE TEHNICE ȘI UMANISTE, TÎRGU-MUREȘ\nSPECIALIZAREA CALCULATOARE\n77\nVizat decan\nConf. dr. ing. Domokos József\n78",
        "keywords": [],
        "hash_code": 9772729098,
        "department": "cs"
    },
    {
        "author": "Gergely Zsolt",
        "supervisor": "Conf. dr. Antal Margit",
        "year": "2023",
        "abstract": "The topic of my thesis is the design and implementation of a system that makes the management\nof events of university open days easier and more transparent for both the organizers and participants.\nUniversity open days are an annual event aimed at promoting the university among high school\nstudents and providing insight into its operation for those interested. This is an extremely important\nprocess because an outsider can really only get a deeper look into university life here before deciding\nto apply. There are several tasks involved in organizing an event, such as managing information\nrelated to the event and participants, which are slow and cumbersome to solve with traditional\nmethods, hence the need for a system that makes the whole process more effortless and faster.\nThe aim of my thesis is to create a system that offers solutions to the aforementioned problems,\nusing the advantages of two modern frameworks. My system makes it more accessible to transfer\ninformation related to events, save participant related data, and create statistics from the existing\ndataset for the organizers.\nThe system consists of three parts. I implemented the mobile application using the Flutter\nframework, which must be installed on users' phones and is platform-independent. Here, depending\non their role, users can register, create new events, modify existing events, sign up for events, and\ngenerate statistics. In the background, a Spring Boot application runs, which provides access to the\ndata stored in the database and processes and saves the data generated by the mobile application.\nThe third part is the cloud-based storage provided by Firebase, where I store the images, and the\nMySQL relational database, where I store all other data.",
        "keywords": [
            "platform-independent",
            "mobile application",
            "Flutter",
            "Spring Boot",
            "event."
        ],
        "hash_code": 8370559909,
        "department": "cs"
    },
    {
        "author": "Györfi Endre",
        "supervisor": "Lector Dr. Sulyok Csaba,, Conferențiar Dr. Iclănzan David Andrei",
        "year": "2022",
        "abstract": "RomaniareceivesalargeamountofmoneyfromtheEuropeanUniontosupportfarmersinvolved\ninagri-environmentalandagriculturalproduction. ThebrainchildoftheprojectistheMilvusassocia-\ntion 3, which is involved in nature conservation research. They have observed that farmers have a big\nprobleminobtaininginformationonsubsidies,asthereiscurrentlynosinglewebsiteorapplicationin\nRomaniathatcollectssubsidiesandrelatedinformation. Tosolvethisproblem,theAPIAAPPproject\nwascreated,whichconsistsofanAndroidapplicationandacontentmanagementsystem.\nThe aim of the application is to help local farmers to browse the subsidies available in Romania\nand to comply with the conditions attached to the subsidies. It also helps to follow the conditions of\nthe subsidies already won. It helps farmers to win a grant by collecting the documents needed to win\neachgrant. ThedevelopmentwasdoneinKotlinMultiplatformMobile,whichsupportsmultiplatform\napplicationdevelopment,theAndroidpartwaswritteninKotlin.\nThethesisdescribestheclientandserverapplication,thetechnologiesusedforitsimplementation,\ncoveringthearchitectureandthefunctionalities.\nTwo persons participated in the development of the application, namely Endre Györfi and István-\nLehel Balázs. The development has been divided according to functionalities, which can be followed\nindetailintheuse-casediagrampresentedinthethesis.",
        "keywords": [
            "Milvus",
            "farmers",
            "subsidies",
            "Kotlin",
            "Multiplatform 3MilvusAssociationhttps://milvus.ro"
        ],
        "hash_code": 6545891107,
        "department": "cs"
    },
    {
        "author": "Gáll János",
        "supervisor": "Ș.l.dr.ing. Bakó László",
        "year": "2021",
        "abstract": "ThedissertationpresentsaprocessordesignedandimplementedforanFPGAcircuit,whichImodeled\nontheXilinxPicoBlazeprocessor. Inthispaper,Ipresentthestepsofdesign,construction,andtesting.\nNowadays, computer technology is developing extremely fast, with redesigning and optimizing\nvariouselements. Theprocessorisoneofthemostimportantcomponentsofacomputerthatexecutes\ninstructionsandcontrolstheentiresystem.\nThere are several types of processor architectures, such as Harvard and Neumann architectures. I\nbuilt the processor presented in my dissertation on the principles of Harvard architecture. However,\nI also used a two-phase piping to make better use of the processor. This allows you to perform\noperationsmuchfaster.\nDuring the design of the processor, I also took into account the RISC design strategy, the essence\nofwhichisthattheprocessorhasasmallnumberandsimpleinstructions. Thismakesplanningeasier\nandfaster.\nThe aim of the dissertation is to compare the two processors, PicoBlaze and the processor I de-\nsigned and developed. In terms of computational performance and process control performance. The\ntestsperformedcanbedividedintotwogroups,arithmetictestsandanalogsignalsamplingtests.\nDuring arithmetic tests, I examined Factorization and Fibonacci number sequence generation for\nboth processors. During analog signal sampling, processors had to reproduce sine and square signals\nofdifferentfrequencies.",
        "keywords": [
            "FPGA",
            "RISC",
            "Processoremulator",
            "compiler",
            "analog-to-digitalconversion 7"
        ],
        "hash_code": 1108760069,
        "department": "cs"
    },
    {
        "author": "Hammas Attila",
        "supervisor": "Conf. dr. ing. Brassai Sándor, Tihamér",
        "year": "2021",
        "abstract": "Artificial neural networks (ANN) are widely used in solving problems like image processing,\ndata mining, or classification. Hardware accelerators are used for increasing the performance\nand efficiency of neural networks. An option for implementing such an accelerator is an FPGA-\nbased system, although developing neural networks for FPGAs is very time-consuming and\nrequires professionals to do it. In this article, we try to tackle this problem by creating a\nframework that should speed up the process. At the same time, we will take a look at some\nefficiency optimization and speed-up options as well. The framework is written in Python and\ngenerates a C++ code whit HLS directives. This code can be compiled by Vivado HLS into a\nhardware descriptive language and packaged as an IP. The Vivado tool can generate a bit file\nthat can be uploaded onto the FPGA device.\nAmong other things, the dissertation presents a comparison of different approximations of\nnonlinear transformations (base functions and activation functions) in terms of accuracy,\nrequired resource, and delay needed for evaluating the transformation. The generated neural\nnetwork module was integrated into a system, that we developed. Using that system, we tested\nthe neural network module and compared it with the models implemented in Python.",
        "keywords": [
            "framework for neural networks",
            "HLS",
            "MLP",
            "RBF",
            "FPGA"
        ],
        "hash_code": 844233960,
        "department": "cs"
    },
    {
        "author": "Horváth Levente",
        "supervisor": "Ș.l. dr.ing. Fehér Áron",
        "year": "2023",
        "abstract": "The aim of this work is to implement a low cost, easily accessible digital sound effect unit.\nThe project involves the study of digital signal processing theory, algorithm design and\ndevelopment, and hardware implementation. In the first phase, the studied effects were tested\nunder Python with pre-sampled raw guitar sound files. In the second phase, the algorithms were\ntested on a self-developed multimedia system with an STM32G491 microcontroller using\nartificially generated and synthesized signals. The quality of the effects was tested using both\nobjective and subjective methods.",
        "keywords": [
            "digital signal processing",
            "sound effects",
            "ARM programming",
            "Python simulation"
        ],
        "hash_code": 1029524067,
        "department": "cs"
    },
    {
        "author": "Iszlai Tamás",
        "supervisor": "Ș.l.dr.ing. Szántó Zoltán",
        "year": "2024",
        "abstract": "Nowadayspeople’slivesaregreatlyinfluencedbydigitalization,andmostindividualspossessatleast\nonesmartdevicethatoffersnumerouspossibilitiestoeaseeverydaylife.\nThese possibilities provide solutions to many problems, such as keeping in touch with distant\nrelatives and friends, buying and selling products, conducting related transactions and last but not\nleast,navigatingaroundthewiderworld.\nThis thesis presents the creation and testing of a web server application, which is accompanied\nby a mobile application and an alertness monitoring algorithm introduced in two other theses. To-\ngether these components form an application that supports social activities and transportation. The\nwebserverisresponsibleforthebackendoperationsandinformationflowoftheapplicationthrougha\ncommunicationchannel.\nThe webserver is developed using Python, a widely-used programming language with a plethora\nof packages. The developed application can be installed and deployed in the given environment,\nafter which it provides functionalities such as authentication, post management, search, notifications,\nmessaging,fileupload/storageandoperationswithQ&Aforms.",
        "keywords": [
            "webserver",
            "navigation",
            "architecture SAPIENTIA ERDÉLYI MAGYAR TUDOMÁNYEGYETEM MAROSVÁSÁRHELYI KAR SZÁMÍTÁSTECHNIKA SZAK StayConnected: Telefonos navigáló alkalmazás backendje DIPLOMADOLGOZAT Témavezető: Végzős hallgató: Dr. Szántó Zoltán Iszlai Tamás egyetemi adjunktus Kivonat Napjainkban a az emberek életét nagyban befolyásolja a digitalizáció",
            "legtöbb embernél található legalábbegyokoskészülék",
            "amelytemérdekleheto˝ségetnyújtamindennapiéletmegkönnyítéséhez. Ezen leheto˝ségek rengeteg problémára nyújtanak megoldást",
            "mint kapcsolattartás távoli rokonok- kal",
            "ismero˝sökkel",
            "termékek vásárlása/eladása",
            "evvel kapcsolatos tranzakciók lebonyolítása és nem utolsósorbantájékozódásanagyvilágban. A dolgozat egy webszerver alkalmazás elkészítését és tesztelését mutatja be",
            "melyhez két másik dolgozatban bemutatott telefonos alkalmazás és egy éberséget figyelo˝ algoritmus is társul",
            "amelyek együttesévellétrejönegyszociálistevékenységeketésaközlekedéstsegíto˝ alkalmazás. Awebszerver az alkalmazás hátterében történo˝ mu˝veletek",
            "információ áramoltatásáért felelo˝s egy kommunikációs csatornánkeresztül. AwebszerverPythonsegítségévelkészült",
            "amelyegyszéleskörbenelterjedt",
            "temérdekcsomaggal rendelkezo˝ programozási nyelv. A fejlesztett alkalmazás leheto˝séget nyújt az adott környezetbe való feltelepítésére",
            "beüzemelésére",
            "ezek után olyan funkcionalitásokat nyújt",
            "mint autentifikáció",
            "bejegy- zések kezelése",
            "keresés",
            "értesítések",
            "üzenetváltás",
            "állomány feltöltés/tárolás",
            "Q&A u˝rlapokkal való mu˝veletek. Kulcsszavak: webszerver",
            "navigáció",
            "architektúra"
        ],
        "hash_code": 2630669360,
        "department": "cs"
    },
    {
        "author": "Kalith Norbert",
        "supervisor": "Ș.l. dr. ing Vajda Tamás",
        "year": "2021",
        "abstract": "The theme of my thesis is the design and implementation of a progressive web application to\nhelp teachers and students manage and track attendance.\nAttendance management is a frequently recurring activity in order to allow instructors to keep\ntrack of students' attendance in class. Most teachers use traditional methods to record attendance.\nThe main drawback of these methods is that they are time-consuming processes. By using digital\ntools, the time spent on this activity can be minimized and attendance recording is more\ntransparent for both teachers and students.\nThe aim of this thesis was to design and build an application that would facilitate and speed up\nthe process of attendance management by taking advantage of the benefits of technology. To\nproduce the software, I tested and used a new software development methodology called\nProgressive Web Application. I created a platform-independent application that uses the Web\nNFC API technology to manage presences quickly and reliably, and I also created an Android-\nbased native application that uses Bluetooth technology in case the user's mobile device is not\ncapable of using NFC technology.\nThe result was a multi-platform progressive web application and a native application. Both\nsoftware, taking into account the epidemiological situation, provide a contactless presence\ntracking and speed up and facilitate the management and tracking of the presence.",
        "keywords": [
            "presence management",
            "progressive web application",
            "platform independence",
            "NFC data transmission"
        ],
        "hash_code": 6186140832,
        "department": "cs"
    },
    {
        "author": "Kántor Zsuzsa-Krisztina",
        "supervisor": "Prof. Dr. Ing. Dávid László",
        "year": "2023",
        "abstract": "Today, diagnostic methods in medicine are constantly evolving, and we can now apply\ntechniques that were unimaginable before. Among the new possibilities and technological\nchallenges, I aim to find solutions that can help us recognize and treat common cardiovascular\ndiseases more effectively, thereby preventing premature or avoidable deaths.\nThe main goal of my research is to develop new and advanced diagnostic systems specifically\nfocused on the characteristics of cardiovascular diseases. These systems would enable more\naccurate and efficient diagnoses during the identification and treatment of these diseases. The\nfoundation of my approach is the utilization of electrocardiography (ECG) signals in medicine.\nThese signals provide precise and detailed information about the heart's electrical activity,\nmaking it possible to detect various heart diseases or other abnormalities.\nThe first step involves preprocessing the signals, applying filtering and other normalization\ntechniques. Then, I create an RGB color-channel image, a spectrogram. The spectrogram is a\nvisual representation that shows the frequency spectrum of the signal over time. Different shades\nof color in the channels indicate the intensity of the frequencies, making it easier to analyze the\nstructure and changes of the signal. This process helps extract essential information from the\nsignals and reduces distortions caused by noise.\nThese images serve as the input dataset for my deep learning-based training software, whose\nmain task is to recognize four specific diseases. Therefore, my system will be able to identify\npatterns or subtle details that are not visible to the human eye, providing more accurate diagnoses\nfor people. This can significantly contribute to improving healthcare outcomes and enhancing the\nquality of life.",
        "keywords": [
            "deep learning",
            "cardiovascular diseases",
            "spectrogram",
            "signal filtering",
            "disease diagnosis."
        ],
        "hash_code": 890412580,
        "department": "cs"
    },
    {
        "author": "Katona Andrea Izabella",
        "supervisor": "Conf. dr. ing. Domokos József",
        "year": "2023",
        "abstract": "People have always been interested in robots. We often meet robots, not only in science,\nbut also in various areas of life. Although we used to think of human-robot interaction as science\nfiction (e.g. R2D2 from the movie Star Wars), nowadays it has become more and more a reality.\nSince people's natural communication is through speech, it is not difficult to imagine\ncontrol through speech. Voice control is an exciting topic that allows robots to be controlled by\nvoice commands. There are different methods for this, however, research is still ongoing in the\nfield. This branch of science can lead to many exciting realizations and applications in all areas of\nlife (science, entertainment, industry, etc.).\nThe purpose of my work is to present the advantages and potential of voice control in\ncontrolling mobile robots. To this end, I will present an implementation that allows controlling a\nrobot in a simulation environment as well as a physical robot with voice commands. Further on,\nyou can read about the detailed implementation, the technologies used, as well as the results of the\nmeasurements, conclusions and further development possibilities.",
        "keywords": [
            "mobile robots",
            "voice control"
        ],
        "hash_code": 7581458885,
        "department": "cs"
    },
    {
        "author": "Kencse Szabolcs",
        "supervisor": "Ș.l.dr.ing. Szántó Zoltán",
        "year": "2022",
        "abstract": "The world is moving fast towards digitalization by taking huge steps in all areas of life and thus\nalmost every person has now a smartphone. Nowadays, there are plenty of applications to facilitate\nour everyday tasks, however, in one of the most important areas, education, we still do not take\nadvantage of the opportunities offered by these tools.\nThe goal of my dissertation is to provide an alternative to the handwritten catalogue used in public\neducation that makes it easy for all teachers, students, and parents to track student marks and\nabsences and helps optimizing administration processes. A teacher can hold the catalogue of all\nthe classes he teaches in his hand at the same time and note their grades at any time, as the physical\nlimit, given by the fact that there is only one unique piece for each class, is eliminated. The students\nwill also have the opportunity to view their marks and absences at any time without interrupting\nthe classes and parents will be able to keep track of real data through their kid’s user as well.\nTo implement this solution, I created a multiplatform application that is compatible with\nsmartphones running iOS and Android, but also any device that has a web browser.\nKey words: digital, catalogue, web application, education\n3\n_____________________________________________________________________________\n1. Bevezető\nA jelenlegi oktatási rendszerben, főleg általános- és középiskolában, a legtöbb adminisztrációs\nfeladat elvégzése régi technológiára alapul, ide tartozik ezek közül a legnagyobb is, amely a diákok\njegyeinek és hiányzásainak tárolása, illetve követése. A mostani megoldás az osztálynapló, ahová\na tanárok beírják az összes adatot a diákról, amely teljesen korszerű és egyértelmű megoldás volt,\nakkor amikor ezt kitalálták, viszont a technológia sokkal jobban előre haladt más intézmények\nadminisztrációs munkájában, mint például a felsőoktatásban.\nManapság a legtöbb ember el sem tudja képzelni a napját okostelefon nélkül, így van ez a\ndiákokkal és a tanárokkal is. Az okostelefonok lehetővé teszik, hogy gyorsan hozzáférjünk szinte\nbármilyen adathoz amire éppen szükségünk lehet, pont ezért rengeteg mindenben megkönnyítik\naz emberek mindennapjait, viszont az oktatási rendszerben főleg általános- és középiskolában\nszinte egyáltalán nem használjuk ki ezt a lehetőséget, amit ezek az eszközök nyújthatnának\nszámunkra, mivel ugyanazok a módszerek vannak jelen mint, amikor még nem álltak ezen\neszközök a rendelkezésünkre. Tanulmányok bizonyítják, hogy a felhasználók elfogadóak, ha az új\nbevezetésre kerülő módszer hasznos és könnyen használható [1].\nA felsőoktatási intézményekben már megjelent és a leginkább használttá vált formája a digitális\nadminisztrációs felületeken (pl. Neptun) történő dokumentálás, amelyek nagyban\nmegkönnyítették az átláthatóságot és az adatok kezelését. Ezekben az intézményekben sokkal\nkönnyebben alkalmazkodnak az új technológiákhoz, mivel kevésbé kötött az oktatási módszertan\nés sokkal hamarabb elérhetővé váltak a korszerű technológiák az intézményben résztvevő\nszereplők körében. Ez a különbség közel sem akkora, mint régebb, mivel az elérhető áru\nokostelefonoknak hála mindenki kezében ott van az aktuális technológia, de döntő többségben\nmég mindig csak az egyetemeken használják ezeket [2].\nA kézzel írott napló módszerének több hátránya is van, mint például, hogy ebből csak egy van és\nfizikailag egyszerre egy helyen lehet, amivel az a probléma, hogy a diák nem látja át folyton az\nösszes jegyét, illetve a szülő szintén nem tudja követni a gyereke jegyeit és hiányzásait. További\nprobléma a jegyek közlésével van több szempontból is: a jegyek közlése időt vesz fel a\nrendelkezésre álló így is szűkös órákból, valamint, hogy a jegyek publikussá vannak téve a szóbeli\nközlés által és a diákoknak nincs meg a lehetőségük, hogy közzé szeretnék-e tenni azt másokkal\nvagy sem. Nem utolsó sorban azt is megemlíthetjük, hogy egy mai napló nehezen átlátható (lásd\n4\n_____________________________________________________________________________\n1. ábra1). Erre kínálna megoldást egy digitalizált napló, ahol mindenki hozzáférne a saját adataihoz\nbárhol és bármikor akadálymentesen tudná követni egy okostelefon segítségével.\nábra 1 - Kézzel írott napló\n1 https://media.hotnews.ro/media_server1/image-2014-07-15-17680232-0-notele-din-catalog-ale-lui-duicu.jpg\n5\n_____________________________________________________________________________\n2. Célkitűzések\nA dolgozat legfőbb célja egy olyan alkalmazás, amely többek között tartalmaz egy digitális naplót,\namely kiválthatja a jelenlegi írott naplókat, valamint megkönnyíthet minden más adminisztratív\nfunkciót is, ami egy iskolában még felmerül, mint például az iskola könyvtárának menedzsmentjét.\nAz alkalmazásnak következő szempontoknak kell megfelelnie:\n• Az applikáció fejlesztése Angular-ben történjen.\n• Multiplatform (cross platform) kell legyen, amit a Capacitor keretrendszer segítségével\nkell elérnünk.\n• Több típusú felhasználó típust kell lekezelnünk, hogy mindenki csak a neki megfelelő\nadatokhoz férjen hozzá, illetve csakis azokat tudja módosítani (diák, tanár, osztályfőnök,\nadminisztrátor, könyvtáros).\n• Követhető, letisztult és szép kezelői felület megvalósítása az egyszerű használat érdekében.\n• Helyi megkötések nélkül használható legyen.\n6\n_____________________________________________________________________________\n3. Bibliográfiai tanulmány\nAz igények felderítése érdekében végzett kutatások, mind azt bizonyították, hogy a jelenlegi\ninternet felhasználók többsége okostelefont használ, valamint egy konkrét kutatás arra is rámutat,\nhogy ez a diákok körében is nagyon elterjedt, ahogy azt az ábrán is szemlélhetjük.\nábra 2 - Az internet használatának módjai (Forrás: [15])\nA digitális napló igényére nagy mértékben rámutatott a 2019-2020-as tanév, mivel a Covid-19\nvilágjárvány beköszöntével megkezdődött az online oktatás, amit különböző csoportbeszélgetésre\nalkalmas platformokon majdnem problémamentesen, illetve az egyetemeken már használt jegyek\ntárolására alkalmas webalkalmazásokon, de a közoktatásban ezeket nagyon nehézkesen tudták\nmegoldani a kézzel írott napló miatt. Szükségmegoldásként táblázatokban tárolták a tanárok a\ndiákok jegyeit és hiányzásait, de ez nagyon nehezen rendszerezhető és nem utolsó sorban\nátláthatatlanná tette mindenki számára ezeket az adatokat. Ráadásul még egy plusz feladat is\nlétrejött ezáltal: a rengeteg dokumentumot valakinek rendszereznie kellett ahhoz, hogy a\ndiákoknak a félévi lezárása létrejöhessen. Erre a problémára nyújt megoldást egy digitalizált\nbármikor és bárhol elérhető napló.\nA fentiek alapján mondhatjuk, hogy szükség van egy alkalmazásra, ami lehetővé teszi a kézzel\nírott napló hibáinak kiküszöbölését, valamint azt is bizton állíthatjuk, hogy ha mindenki számára\nkönnyen elérhetővé szeretnénk tenni, akkor ez egy telefonos applikáció kell legyen. Továbbá\nelérhetővé kell tegyük a böngészőn keresztül való hozzáférést is azok számára, akik esetleg nem\nrendelkeznek okostelefonnal, illetve jobban preferáljak a számítógép használatát.\nAz eddig megemlített szempontok alapján a legmegfelelőbb egy reszponzív webalkalmazás\nkészítése. Ezen alkalmazás elkészítésére a kereséseim alapján a legmegfelelőbbnek egy Angular\nkeretrendszerben megírt webalkalmazást találtam, amiből Capacitor keretrendszer segítségével\n7\n_____________________________________________________________________________\ntudok natív alkalmazásokat létrehozni különböző platformokra (iOS, Android stb.). A használandó\ntechnológiákról a következő részben írok részletesebben.\nNéhány megvalósított példa már létezik digitális napló megvalósítására, amelyből kiemelném a\nNoteInCatalog-ot (lásd 3. ábra2), ami szintén rendelkezik iOS, Android, illetve böngészőn\nkeresztül is hozzáférhető applikációval. Még egy hasonló példát találtam, már megvalósítva és\nhasználatban, ami kizárólag iOS és Android applikáción keresztül elérhető: 24edu (lásd 4. ábra3).\nábra 3 - NoteInCatalog szülői alkalmazás\n2 https://noteincatalog.ro\n3 https://www.24edu.ro\n8\n_____________________________________________________________________________\nábra 4 - 24edu digitális napló (szülő/diák alkalmazás)\n9\n_____________________________________________________________________________\n4. Technológiai áttekintés\n4.1 HTML\nA HTML, vagyis HyperText Markup Language, magyar megfelelője hiperszöveges jelölőnyelv.\n„A HTML nem egy programozási nyelv, hanem egy kódnyelv, amelynek segítségével akár a\nJegyzettömb használatával is alkothatóak weboldalak. A hipertext jelenti valójában az interneten\ntalálható oldalakat (dokumentumokat), amelyek szöveg, kép, videó, hang, animáció, vagy ezek\nvalamilyen kombinációjából áll. A HTML ezeknek a dokumentumoknak az elrendezését,\nformázását tartalmazza saját jelölőnyelvén” [3].\n4.2 CSS\nA CSS rövidítés az angol „Cascading Style Sheets” megfelelője, ami magyarul annyit tesz, hogy\n„egymásba ágyazott stíluslapok” [2]. A lényeg a „stíluson van amíg a HTML a weblap szerkezetét\nhatározza meg” [4] (paragrafusok, fejlécek stb.), és ugyan akkor különböző elemeket (képek,\nvideók stb.) tudunk beágyazni a webes dokumentumokba, addig a CSS a weboldal vizuális elemek\nmegjelenítési stílusának (szín, méret, betűcsalád) a meghatározásáért felel, illetve az oldalon való\nmegfelelő elhelyezéséért.\n4.3 SCSS\nAz SCSS egy előfeldolgozó szkriptnyelv, ami CSS-re fordítódik, amelynek szintaxisa majdnem\nteljesen azonos a CSS-ével és konkrétan csak abban tér el attól, hogy több lehetőséget nyújt, mint\na CSS (pl. változók használata – lásd 2. ábra, könnyebb strukturálhatóság).\n10\n_____________________________________________________________________________\nábra 5 – Változók használata SCSS -ben\nA kép bal oldalán a hagyományos CSS megoldással való megoldás található három HTML elemre\nmíg jobb oldalon az SCSS lehetőségét kihasználva kiváltjuk a színkódot egy változóval, ami azért\nelőnyös mivel, ha akarjuk a későbbiekben módosítani a betűk színét (például egy témaváltást\nakarunk megvalósítani), akkor ezt csak egy helyen kell megtegyük.\n4.4 JavaScript\n„A JavaScript egy nagyon hatékony kliensoldali szkriptnyelv. A JavaScript elsősorban a\nfelhasználó és a weboldal interakciójának fokozására szolgál. Más szavakkal, a JavaScript\nsegítségével élénkebbé és interaktívabbá teheti weboldalát. A JavaScript-et széles körben\nhasználják játékfejlesztésben és mobilalkalmazások fejlesztésében is” [5].\nNagyon fontos előnye, hogy a weboldal tartalmát dinamikusan tudjuk aktualizálni és nem utolsó\nsorban formázni is az éppen végbemenő interakciók függvényében.\nA JavaScript kódot egy JavaScript motor (JavaScript Engine) fordítja le gépi vagy alacsonyabb\nszintű kódra. Különböző JavaScript motrokat is ismerünk, mint például a Rhino (Mozilla) vagy a\nJavaScriptCore (Safari - WebKit), ezek mindegyike megfelel az ECMAScript szabványnak amire\nmaga a JavaScript is épül.\n11\n_____________________________________________________________________________\n4.5 Typescript\nA Typescript egy nyílt forráskódú nyelv, ami a JavaScript -re épül, amelyek szokatlan\nkapcsolatban állnak egymással, ami azt jelenti, hogy a Typescript minden lehetőséget felkínál,\namit a JavaScript tud csak még egy igazán fontos dolgot ad hozzá és ez a szigorú típusok.\nábra 6 - Typescript és JavaScript összehasonlítás (Forrás: [6])\nA fenti példában az van szemléltetve, hogy ha egy egyszerű összeadó függvényt szeretnénk\nhasználni és azt várjuk el tőle hogy egy számot kapjunk visszatérített értéknek, akkor a\nTypescript(lásd a fenti ábra bal oldalán) kompilátora nem fogja nekünk engedni, hogy a bemeneti\nérték típusát ne a meghatározott típusnak megfelelően adjuk meg, így nem történhet meg egy olyan\neset, mint például a JavaScript -ben(lásd a fenti ábra jobb oldalán), hogy mindenképp vissza térít\negy értéket ami jelen esetben nem az elvárt típus és ez később gondot okozhat, illetve sokkal\nnehezebbé teszi egy ilyen relatív egyszerű hiba kijavítását, illetve megtalálását. Tehát végső soron\nkicsit több munkával, mivel minden változónak a típusát mi kell meghatározzuk, de könnyebbé\nteszi a munkát, mivel sokkal kissebbé teszi a hibalehetőséget.\n4.6 SPA\nAz SPA vagyis Single Page Application, magyarul annyit tesz, hogy egyoldalas applikáció, ami\nvalójában egy HTML oldal, amibe dinamikusan töltünk be egyes részeket(komponenseket) és ezek\nösszessége fogja kitenni a megjelenített felületet. Ebben az esetben nem átnavigálunk oldalak\nközött, mint egy hagyományos weboldal esetében, hanem a különböző részeket cserélünk ki egy\ninterakcióra reagálva, mivel egyben az alkalmazás betöltődésekor mindent letöltünk a szerverről.\nA szerver és a kliens között csak információk cserélődnek amire szintén reagálhat az előre betöltött\ndinamikus rész.\n12\n_____________________________________________________________________________\n4.7 Angular\nAz Angular egy keretrendszer, ami arra lett kitalálva, hogy egyoldalas kliens alkalmazásokat\nfejlesszünk HTML és Typescript segítségével [7].\n„Angular 2010-ben jelent meg, eredetileg a Google fejlesztette. Alapvetően TypeScript -re épül,\naz Angular 2 verziója csupán 2016-ban jelent meg, addig csupán az AngularJS létezett, melyet ma\nmár nem igen használnak sehol. Ha azt halljuk valakitől, hogy „Angular”, akkor\nalapértelmezettként az Angular 2+ verziókra érdemes gondolnunk (jelenleg már Angular 9 is\nlétezik).\nAz Angular egy keretrendszer, és a választások „legszélesebb” spektrumát nyújtja ebből adódóan,\nugyanis a két vetélytársa csupán könyvtár, azaz library (React és a Vue.js)” [8].\nPélda Angular -ben megírt alkalmazásokra: Gmail, Microsoft Office Word Online (lásd az alábbi\nábrát), OneDrive.\nábra 7 - Képernyőkép onedrive.live.com weboldalról\nMVVM\nAz MVVM (Model View ViewModel) egy tervezéi minta, amely egy a Microsoft Patterns and\nPractises által megalkotott minták közül, célja, hogy egy úgynevezett lazán csatolt (loosely-\ncoupled) architektúrát hozzon létre és az Angular is ezen alapul. A ViewModel valósítja meg a\n„laza csatolás” -t a nézet és az adatmodell között ezáltal teljesen elválasztva az előbb említett két\nrészt.\n13\n_____________________________________________________________________________\nábra 8 - MVVM tervezési minta\n„A modell (Model) tartalmazza az alkalmazás logikáját (algoritmusok, adatelérés), önálló́,\nújrafelhasználható.\nA nézet (View) tartalmazza a felület vezérlőit (ablakok, vezérlők, ...) és az erőforrásokat\n(animációk, stílusok, ...).\nA nézetmodell (ViewModel) lehetőséget ad a modell változásainak követésére és tevekénységek\nvégrehajtására” [9].\nEgy komponens életciklusának fontosabb részei:\n• A konstruktor (constructor) egy beépített metódus, amely akkor kerül meghívásra, amikor\naz osztály példányosítása történik.\n• Az ngOnInit akkor fut le amikor beállítódnak a kezdőértékek, rögtön a konstruktor futása\nután.\n• Az ngAfterViewInit meghívásra kerül mikor a komponens és az összes gyerek\nkomponense (child component) megjelenítendő része létre lett hozva.\n• Az ngOnDestroy rögtön azelőtt hívódik még mielőtt az Angular leépítené a komponenst\nés leiratkozik minden információ figyeléséről (Observable), amely a komponenshez\ntartozott, az esetleges konfliktusok és memóriaszemetek elkerülése végett.\nAz Angular -nek több életciklusa is van, amelyet az 5.-ik ábrán szemlélhetünk.\nEgy fontos dolog, amelyet még érdemes tárgyalnunk az Angular kapcsán az a változás figyelő\n(Change Detection), amely figyeli a változásokat (pl. valamely más komponenstől kapott érték) és\nerre reagálva megváltoztatja a nézetet a változás függvényében.\n14\n_____________________________________________________________________________\nábra 9 - Egy Angular komponens életciklusa\n4.8 Capacitor\nA Capacitor egy olyan nyílt forráskódú keretrendszer, amely lehetővé teszi, hogy a HTML, CSS\nés JavaScript használatával megírt webalkalmazásokból natívan futtatható alkalmazást készítsünk\niOS-re, Androidra, amit feltölthetünk akár az adott operációs rendszer által támogatott alkalmazás\nboltba (pl. App Store vagy Play Áruház), továbbá lehetőséget nyújt arra is, hogy ugyanezt asztali\noperációs rendszereknél is megtegyük egy Electron vagy egy progresszív webalkalmazás\nsegítségével.\nA Capacitor segítségével nem csak natívan tudjuk futtatni az alkalmazást a telefonon, de az\nelérhető nyílt forráskódú bővítményei segítségével hozzáférhetünk olyan natív hardver és\nszoftveres elemekhez, mint például a kamera, a biometrikus azonosítás (pl. ujjlenyomatolvasó\nszenzor) és az értesítések.\n15\n_____________________________________________________________________________\nKövetkeztetésképpen a Capacitor segítségével olyan natív alkalmazásokat készíthetünk natív\nplatformokra, amelyek mind egy forráskóddal rendelkeznek így költséghatékonyabb és gyorsabb\nfejlesztést tesznek lehetővé.\n4.9 Adatbázis\n„Az adatbázis az adatok szervezett gyűjteménye, amely lehetővé́ teszi az adatok\ntetszőleges szempontok szerinti rendszerezését és visszakeresését [...].\nAz adatbázisok legfontosabb jellemzője, hogy nem csak az adatokat, hanem az adatok közötti\nkapcsolatokat, összefüggéseket is képes tárolni.\nAz adatbázisokat adatbázis-kezelő szoftver (program) segítségével hozzuk létre és annak\nsegítségével használjuk” [10].\n4.9.1 SQL és NoSQL\nAz SQL (Structured Query Language), magyarul strukturált lekérdezőnyelv relációs adatbázis\nkezelő szoftverekhez. A relációs adatbázis valójában összefüggő kétdimenziós táblák összesége,\nahol a sorokban összefüggő adatokat tárolunk, míg az oszlopokban ezen adatok tulajdonságait\ntároljuk el minden egyes tábla esetében.\nábra 10 - Példa SQL adatbázisban található táblára (Forrás: [11])\nA NoSQL adatbázis, vagyis a nem SQL adatbázis lényege, hogy nem strukturális, vagyis az adatok\nséma nélkül, szabadon tárolhatóak. A legnépszerűbb formája az adatokat tárolásának a\ndokumentum típusú tárolás és ezen dokumentumokat gyűjteményekbe rendezzük. Ezen\ndokumentumok tartalmát nem kell előre meghatározzuk, tehát nem kell inicializáljuk egy esetleges\n16\n_____________________________________________________________________________\neltárolandó érték típusát. Egy dokumentum (JSON fájl) tartalma kulcs és értékpárokat tartalmaz,\nvagyis objektumokat, például ahogyan az alábbi (ábra 11) ábrán is látható.\nábra 11 - Objektum szerkezete JSON fájlban\nEgy dokumentum tartalmazhat egy újabb gyűjteményt is akár, ahogyan az alábbi ábrán is látható\n(ábra 12) is látható.\nábra 12 - SQL és NoSQL szerkezet összehasonlítása\nA NoSQL adatbázisok általában gyorsabbak, de a fő előnyük mégsem ez hanem a rugalmasság\nmikor bármikor könnyen bővíthetőek, viszont nem beszélhetünk olyan magas\nadatkonzisztenciáról, mint az SQL kapcsán.\n4.9.2 Firebase\nA Firebase egy Google infrastruktúrára épült Baas (Backend-as-a-Service), vagyis egy backend\nszolgáltatás, amely rengeteg eszközt és szolgáltatást biztosít a fejlesztők számára. Főbb funkciók,\namiket kínál:\n17\n_____________________________________________________________________________\n• Firebase Authentication (Bejelentkezés) kezelő szolgáltatás\n• Firestore Database – valós idejű adatbázis\n• Hosting – nagyon gyors tárhely webapplikációk részére\n• Notifications – értesítéseket lehet kiküldeni a felhasználóknak minimális implementálással\nEzek közül három fontosabbról beszélnék az alábbiakban: Firebase Authentication, Firestore\nDatabase, Firebase Storage.\nFirebase Storage\nEgy olyan felhő tárhely alapú szolgáltatás, amely egy Firebase applikációhoz biztosít a\nfelhasználók fájljai számára egy biztonságos tárolási megoldást. Továbbá lehetővé teszi a\nfelhasználók számára a szüneteltetett letöltés folytatását, ami megbízhatóvá és kevésbé\nadatforgalom-igényessé teszi ezt a szolgáltatást.\nFirebase Authentication\nBármilyen platformon könnyen implementálható biztonságos bejelenetkezési lehetőséget nyújt,\nmindezt rengeteg lehetőség formájában: email és jelszó páros, Google-fiókkal, Facebook-fiókkal\nvagy akár SMS-ben kapott ellenőrző kód visszaigazolásával is be tudunk lépni, de a lista még nem\nmerül ki ebben a pár lehetőségben.\nFirestore\nA Firestore, más néven Cloud Firestore egy felhő alapú NoSQL adatbázis szolgáltatás. Lehetővé\nteszi, hogy egyszerre több kliens alkalmazáson szinkronban tudjunk hozzájutni valós idejű\ninformációhoz. A Cloud Firestore egy teljes SDK -t (Software Development Kit) kínál iOS,\nAndroid és más platformokra.\nA Firestore főbb funkciói:\n• adatszinkronizálás több kliens applikáció közt,\n• valós idejű kommunikáció,\n• automatikus skálázás,\n• serverless technológia.\n18\n_____________________________________________________________________________\n4.10 Hálózat\n4.10.1 HTTP\nA HTTP egy kliens és szerver oldal közötti kérés-válasz alapra épülő protokoll, amely lehetővé\nteszi a lékérését olyan erőforrásoknak, mint például a HTML dokumentumok. Ez a protokoll a\nTCP/OSI modell hetedik (alkalmazás) rétegében helyezkedik el. A kliens (általában egy\nwebböngésző) által kezdeményezett lekéréseket egy webszerver dolgozza fel, majd visszaküld egy\nválaszt.\nábra 13 - Kliens és szerverek közti lekérések szemléltetése (Forrás: [12])\nA kliens és a szerver egyéni üzenetváltásokon keresztül kommunikálnak, a kliens által küldött\nüzeneteket lekéréseknek (request), míg a szerver által küldötteket válasznak (response) nevezzük.\nA HTTP protokollban összesen nyolc különböző metódust találunk. A leggyakrabban használt\nmetódusok:\n• GET – egy adott erőforrás (pl. képfájl) letöltését indítja el\n• POST – adatot küld a szervernek (pl. HTML űrlap tartalma)\nábra 14 - Képernyőkép egy HTTP GET kérésről\n19\n_____________________________________________________________________________\n4.10.2 Webszerver\nA webszerver egy weblapok kiszolgálását megvalósító szoftver. Feladatai körébe tartozik a\nwebböngészők kiszolgálása, felhasználók tevékenységeinek naplózása, valamint az elérések\nkorlátozása. A legelterjedtebb webszerver az Apache. Egy webszerver az esetek többségében az\nindex.html állományra érkező lekérést szolgálja ki elsőnek. Egy kliens és webszerver közti történő\nkommunikációt a fenti ábrán (ábra 14) figyelhetünk meg.\n4.10.3 Websocket\nA websocket valós idejű kétirányú kommunikáció megvalósítását teszi lehetővé kliens és szerver\nközt egyetlen TCP protokollon. Egy websocket -en üzeneteket küldhetünk és fogadhatunk a\nszervertől anélkül, hogy újabb lekérést kellene küldjünk a szervernek. A leggyakrabban valós idejű\nalkalmazások esetében használják, mint például egy chat (csevegő) alkalmazás.\nábra 15 - Websocket és HTTP lekérés közti különbség (Forrás: [13])\nA fenti ábrán látható, hogy a websocket esetében az első lekérés után egy nyitott kapcsolat jön\nlétre, míg a HTTP esetében egy kérés-válasz után a kapcsolat bezárul.\n20\n_____________________________________________________________________________\n5. A rendszer specifikációi\n5.1 Felhasználói követelmények\nábra 16 - Use case diagram\n21\n_____________________________________________________________________________\nFelhasználók csoportosítása szerepkörök szerint\nAz alkalmazáson belül a felhasználókat több szerepet (tanár, diák, osztályfőnök, adminisztrátor és\nkönyvtáros) különböztetünk meg, amelyek mind különböző műveleteket végezhetnek, ahogyan az\na használati eset diagrammon is látható (lásd 16. ábra). Egy felhasználónak egy szerepkör jut, de\nez alól kivétel lehet az a tanár, aki osztályfőnök is egyben.\nElőször is megneveznék két olyan műveletet, amelyet mindenki végezhet (lásd 16. ábra):\n• A bejelentkezés: a felhasználó e-mail cím és jelszó segítségével jelentkezhet be, illetve,\nha elfelejtené jelszavát abban az esetben kérhet jelszóemlékeztetőt.\n• A főoldalra való belépés: itt minden felhasználó találkozhat a neki elérhető funkcióval és\nezeket megkattintva átirányítódik a megfelelő oldalra\nA diákok a következő választási lehetőségekkel találkoznak a főoldalon (lásd 16. ábra):\n• Napló: itt látható minden egyes tantárgya, amit tanul, illetve rákattintáskor megnyílik egy\nrészletes nézet a tantárgyhoz kapcsolódó jegyekről és hiányzásokról\n• Órarend\n• Könyvtár: ide navigálva mindenki megtekintheti az éppen aktuálisan szereplő összes\nkönyvet a könyvtárban, illetve, hogy melyik elérhetőek azok közül és ha nem elérhetőek\nakkor mikorra várható a kölcsönzés vége\n• Hírek: az aktuális hírek egy egyszerű nézete\n• Profil: ez a menürész mindenkinek a saját adatát mutatja, illetve lehetőséget nyújt\nprofilkép cserére és az alkalmazás színének megváltoztatására\n• Elérhetőségek: az iskola elérhetőségei\nA tanároknak hasonlóképp történik az órarend, a könyvtár, a hírek és az elérhetőségek\nmenüpontokon való interakció, mint a diákoknál, de kivételt képez a napló, ahol a tanárok láthatják\naz összes osztályt felsorolva, amit tanítanak és azon belül minden tantárgyat. Ezen tantárgyakra\nkattintva megnyílik az osztálynévsor, ahol egy további kattintással a diák nevére megjelennek a\njegyei és a hiányzásai. Ezen a ponton a tanár jegyeket írhat, szerkeszthet, illetve törölhet is,\nvalamint hiányzásokat írhat be és igazolhatja is azokat.\nA harmadik csoportba az osztályfőnök tartozik, aki általában egy tanár is, ami annyit tesz, hogy\namit egy tanár megtehet azt egy osztályfőnök is megtehet, bármely osztályban, ahol tanár viszont\nmindezek mellett rendelkezik egy olyan joggal, hogy a saját osztályának szerkesztheti a névsorát,\n22\n_____________________________________________________________________________\na tantárgylistáját, lezárhatja az egész osztályt az adott félévre vagy évre, megtekintheti minden\ntantárgyból minden jegyét és hiányzását is, illetve minden tantárgy esetében igazolhatja is azokat.\nAz adminisztrátorból egy egyedi fiók van az alkalmazásban és a következők tartoznak ezen\nszerepkőr feladatai közé:\n• Osztályok menedzsmentje: hozzáadhat új osztályokat, illetve az új osztályokhoz\nhozzárendelhet osztályfőnököket\n• Profilok menedzsmentje: hozzáadhat és eltávolíthat osztályprofilokat (pl. A –\nMatematika-Informatika)\n• Felhasználók kezelése: létrehozhat új felhasználókat (diák vagy tanár), illetve\nszerkesztheti azok adatait (tanárok esetében meghatározza ki milyen tantárgyat taníthat)\n• Az iskola elehetőségeinek szerkesztése\nUtolsó szerepkörként a könyvtárost említeném meg, aki szintén láthatja a könyvtárat külső\nszemlélőként, illetve menedzselheti az egész könyvtárat: hozzáadhat és eltávolíthat könyveket,\nkiadhat valakinek könyvet kölcsönzésre, megtekintheti kinél van egy kiadott könyv, illetve\nlezárhatja a kölcsönzést, ha a könyv visszaadásra kerül.\n5.2 Rendszer követelmények\n5.2.1 Funkcionális követelmények\n• Bejelentkezés:\no A felhasználók létrehozásakor az e-mail cím a következő formátumban\ngenerálódik ki: keresztnév.vezetéknév@usochool.com és jelszó pedig\nalapértelmezetten „123456”, így a felhasználók ezekkel az alapértelmezett\nadatokkal jelentkezhetnek be. A jelszavát bárki megváltoztathatja a saját profilján\nbelül.\no Bejelentkezés nélkül egy felhasználó sem tud hozzáférni semmilyen funkcióhoz az\nalkalmazáson belül csak az „elfelejtett jelszó” -hoz.\no Bejelentkezéskor a Firestore Authentication-höz küldd egy kérést az alkalmazás,\nhogy az ellenőrizze le, hogy a megadott e-mail cím és jelszó páros helyes-e, illetve,\nha a válasznak az alkalmazás azt kapja vissza, hogy helyes volt akkor tovább fog\nnavigálni mindenkit a jogainak megfelelő főoldalra.\n23\n_____________________________________________________________________________\n• Kijelentkezés: ebben az esetben a felhasználók be kell legyenek jelentkezve és be kell\nnavigáljanak a profil oldalra, ahol egy kijelentkezésre utaló ikonra kell kattintani egyszer\namire rákattintva megjelenik a „Logout” felírat és ha erre ismét rákattint akkor azzal\nmegerősíti, hogy valóban ki akar jelentkezni.\n• A diákok a profilon kívül mindenhol csak megtekintési joggal rendelkeznek.\n• A tanárok csak a saját tanítványaik jegyeit szerkeszthetik. Szerkesztéskor a meglévő adatok\nhozzáadódnak, illetve frissülnek a Firestore-ban (az alkalmazás által használt NoSQL\nadatbázis)\n• Az adminisztrátor és a könyvtáros által történő bármilyen adatmódosítás is szintén azonnali\nváltoztatást idéz elő az adatbázisban.\n5.2.2 Nem-funkcionális követelmények\n• A következő eszközök által lehetséges a webapplikáció használata, amennyiben azok\nképesek internetkapcsolatot létesíteni:\no iPhone: minimum iPhone 5S készülék, amelyen minimum iOS 11 operációs\nrendszer fut\no bármely Android készülék, amely rendelkezik legalább Android 5.0 operációs\nrendszerrel\no bármilyen tablet, amelyre telepítve van a Chrome vagy a Safari böngésző\no MacOS, Windows vagy Linux rendszerrel rendelkező személyi számítógépek vagy\nlaptopok, amelyek elégséges erőforrással rendelkeznek egy Electron alkalmazás\nfuttatásával: minimum 512 MB RAM memória és Intel Pentium 4- es processzor\n• Fejlesztési követelmények:\no Egy fejlesztői környezet, ami esetünkben a Microsoft ingyenes Visual Studio Code\nszoftvere\no Github verziókövetőrendszer\no Firebase felhőszolgáltatások: az adatbázis, a felhasználók és az adatok kezelésére\no Adobe XD arculattervező szoftver, a felhasználói felület megtervezésére\n• Külső követelmények:\no Az adatok biztonságos tárolása Firebase Storage és Firestore segítségével, amely\nbiztosítja, hogy mindenki csak az általa megtekinthető adathoz férjen hozzá\n24\n_____________________________________________________________________________\no A jelszavak biztonsága érdekében Firebase Authentication-t használunk, amely\nhash-elve fogja eltárolni azokat\no A GDPR (Adatvédelmi és Adatkezelési Szabályzata és Tájékoztatója): az\nalkalmazás a „privacy policy” részben tartalmazza az összes adathasználattal\nkapcsolatos nyilatkozatot.\no A felhasználók privát (telefonszám, lakcím stb.) és a publikus (név, e-mail cím stb.)\nkülön helyen vannak tárolva és szerepkőrhöz kötött hozzáféréssel rendelkeznek az\nadatok megfelelő védelme érdekében.\n25\n_____________________________________________________________________________\n6. A rendszer leírása\n6.1 Rendszer architektúra\nábra 17 – A rendszer architektúrája\nA jelenlegi rendszer egészének az eredménye egy iOS és Android natív alkalmazás, amely\nigazából egy a Capacitor keretrendszer segítségével becsomagolt webapplikáció, ami Angular-ben\níródott. Az Angular webalkalmazás pedig az AngularFire, vagyis a hivatalos, nyílt-forráskódú\n26\n_____________________________________________________________________________\nAngular könyvtár Firebase szolgáltatásainak a használatához. A rendszerben a Firebase felel a\nfelhasználók bejelentkeztetéséért, az adatok tárolásáért, valamint a valós idejű adatbázisért.\n6.2 Webalkalmazás architektúrája modulokra bontva\nEgy Angular webalkalmazást modulokra tagolunk (lásd 18. ábra), hogy egy rendszerezett\nalkalmazásfelépítést kapjunk, ami nem csak azért jó, hogy egy átlátható forráskódunk legyen,\nhanem mert optimalizálni tudjuk az alkalmazásunk sebességét azáltal, hogy csak az aktív\nmodulban lévő komponenseket (lásd 19. ábra), illetve más szükséges modulokat használjuk csak.\nA következőkben modulokra felosztva szeretném bemutatni az alkalmazás főbb részeit.\nábra 18 - Példa modulra a mappaszerkezetben\n(menedzser modul)\nábra 19 - Komponens mappaszerkezete\n6.2.1 Bejelentkezés\nA bejelentkezés vagyis a login modul magába foglalja a login (bejelentkezés) és a forgot-password\n(„elfelejtett jelszó”) komponenst. A login komponens tartalmaz két bemenetet: egy e-mail cím,\n27\n_____________________________________________________________________________\nilletve egy jelszó típusút és egy gombot, amelynek a megnyomásakor a két bemeneti adatot elküldi\naz authentication” szervíznek (lásd az 6.4.1-es fejezetben), ami segítségével megvalósul vagy\nelutasításra kerül a bejelentkezési kérelem. Sikeres bejelentkezést követően átnavigálja a\nfelhasználót a home (főoldal) komponensre.\nAmennyiben a felhasználó elfelejtené a jelszavát így „Forgot password” feliratra kattintva\nmegnyílik az elfelejtett jelszó komponens, ami egy e-mail cím megadásával szintén az\nauthentication szervíz segítségével egy jelszóemlékeztetőt küldd ki az adott címre.\n6.2.2 Főoldal\nA főoldal modul kizárólag a home (főoldal) komponenst tartalmazza, amely a user (felhasználó)\nszervíz által megkapja a bejelentkezett felhasználó szerepkörét az adatbázisból és ez alapján\nmegjeleníti a megfelelő opciókat.\n6.2.3 Napló\nábra 20 - Napló modul főbb komponensei és kapcsolata a napló szervízzel\n28\n_____________________________________________________________________________\nA 20. ábrán láthatóak a napló modul főbb komponensei és azok főbb kapcsolatai a catalogue\n(napló) szervízzel.\nA diák esetében először is a user (felhasználó – lásd 6.4.1 fejezet) szervíztől lekérjük a felhasználó\nadatai közül, hogy melyik osztályba tartozik, majd ezen a ponton lekérjük a napló szervíztől az\nadott osztályban lévő tantárgyakat (a „getClassDoc()” függvény segítségével).\nA tanár esetében is hasonlóan történik a folyamat, csak előszőr azt a listát kérjük le, amely a tanár\náltal tanított osztályokat tartalmazza és az osztályokon belüli tantárgyakat. Majd ezekre a\ntantárgyakra kattintva mindegyik esetében lekérjük az osztálynévsort (a „getClassDoc()”\nfüggvény segítségével).\n6.2.4 Menedzsment\nAz ebben a modulban megjelenő komponensek lehetővé teszik az összes fontosabb\nadminisztrációs tevékenység elvégzését. Az alábbiakban bemutatom a főbb komponenseket.\nFelhasználók menedzsmentje\nA felhasználók menedzsmentje igazából egy újabb komponens, ami magába foglal egy fő\nkomponenst és négy alkomponenst:\n• A felhasználók hozzáadása komponenst (add-user), ami egy űrlap kitöltése után a bevitt\nadatokat továbbítja az authentication szervíznek, amely segítségével létrehozzuk a\nfelhasználót. Az űrlap minden mezőjének kitöltése kötelező, illetve a felhasználó típusának\n(tanár/diák) megfelelő megjelenítését egy két állású kapcsoló kattintásával érhetjük el.\n• A felhasználók listája komponenst (users-list), aminél szintén megjelenik az előbb\nmegemlített két állású kapcsoló, amivel kiválaszthatjuk, hogy a tanárok vagy a diákok\nteljes listáját szeretnénk látni. Ezen felül még egy kereső bemenet is található, amivel\nleszűrhetjük a találatokat a könnyebb átláthatóság érdekében (lásd 21. ábra).\nábra 21 - Felhasználók listájának szűrése\n29\n_____________________________________________________________________________\n• A felhasználók szerkesztéséért felelős komponens (edit-user) a 21. ábrán látható „View”\ngomb megnyomására aktiválódik és mielőtt bármi megjelenne a képernyőn azelőtt betölti\naz adott felhasználó összes jelenlegi adatát. Ezen adatok mind egy szerkeszthető\nszövegmezőben jelennek meg, amelyek módosítása után a „Save” gomb megnyomásával\nmenthetőek.\n• A legutolsó kis komponens tanár által tanítható tantárgyak szerkesztésére alkalmas\nkomponens (edit-teacher-subjects). Itt egy legördülő listában láthatjuk az összes tantárgyat\namelyekre rákkatintva hozzáadhatjuk azt a tanár profiljához.\nOsztályok menedzsmentje\nEbben a modulban két fő komponens található: az osztályok szerkesztése és hozzáadása.\nEgy osztály hozzáadása egy űrlap kitöltésével történik, ahol meg kell adnunk a létrehozni kívánt\nosztály végzés évét (promotion year). Ezután ki kell választanunk egy legördülő listából az osztály\nprofilját (pl. B - Biológia), ami már előre szűrve van azért, hogy egy azonos évben ne tudjon\nlétrejönni két osztály azonos profillal. Ezután egy újabb legördülő menüben kiválaszthatjuk az\nosztályfőnököt, ami szintén egy előre megszűrt lista, ami nem tartalmazza azokat a tanárokat, akik\nmár osztályfőnökök egy másik osztályban.\nEgy osztály szerkesztésénél hozzáadhatunk és eltávolíthatunk diákokat és tantárgyakat az adott\nosztályhoz, illetve lezárhatjuk az osztályt az adott félévre.\nKönyvtár menedzsmentje\nA könyvtár menedzselésére csak a könyvtáros jogosult és a következő funkciókat érheti el a\nkönyvtárkezelés modulban (manage-library) megtalálható komponensek segítségével:\n• Hozzáadhat/eltávolíthat könyveket az adatbázisból. Hozzáadáskor szintén egy űrlap\nkitöltésével történik (cím, szerző, maximális időtartam amire a könyv kiadható és az ISBN\nszám).\n• Módosíthatja egy már meglévő könyv adatait.\n• Megtekintheti a jelenlegi összes könyv listáját. Ellenőrizheti, hogy a könyvek ki vannak\nadva vagy sem. Ha egy könyv ki van kölcsönözve akkor láthatja az ahhoz tartozó diák\nnevét, a kikölcsönzés dátumát, a kölcsönzés végének várható dátumát. Ugyanakkor\n30\n_____________________________________________________________________________\nkezelheti a kölcsönzéseket is vagyis hozzáadhat egy új kölcsönzést, illetve egy könyvet\nújra elérhetővé tehet, ha azt a diák visszavitte.\n6.2.5 Könyvtár\nEz a modul felhasználói szempontból lehetővé teszi azt, hogy megtekinthessük a könyvtárban lévő\nösszes könyvet és azok elérhetőségét. Ha egy könyv nem elérhető akkor látható a kölcsönzés\nvégének várható dátuma. Egy külön listában szintén megtekinthető a felhasználó által\nkikölcsönzött könyvek listája és a kölcsönzés lejáratának ideje.\n6.2.6 Profil\nA profil modul csak a profil komponenst tartalmazza, amelyben a következő lehetősége van egy\nfelhasználónak:\n• Megtekintheti az adatait: profilkép, e-mail cím, születési év, lakhely, telefonszám és\nszemélyi szám\n• Kicserélheti a profilképét: minden felhasználó az adminisztrátoron kívül jogosult\nprofilképcserére, ami a következőképpen valósul meg: a profil oldalon belül a megjelenített\nprofilkép (ha még nem volt beállítva akkor egy alapértelmezett szürke avatár) jobb alsó\nsarkában a „kicsi fényképezőgép” ikonra kattintva a felhasználónak lehetősége nyílik az\neszköze kamarájával készíteni egy képet vagy a galériájából kiválaszthat egy már meglévő\nképet. Kép feltöltésekor a kép a Firebase Storage-be töltődik fel, ahonnan sikeres művelet\nesetén visszakapunk a képre mutató linket, amit elmentünk a felhasználó profiljához\ntartozó adatokhoz az adatbázisban. Ezen műveletekhez szükséges lehet a belső tárhelyhez,\nilletve az eszköz kamerájának használatához szükséges engedélyek elfogadása, amelyet az\nalkalmazás szükség esetén felkínál, mivel ezek már natív rendszer elemek.\n• A témaválasztás: erre a funkcióra mindenki jogosult. A profil komponensen belül a téma\nikonra kétszer rákattintva (a második a megerősítésre szolgál), az alkalmazás elmenti az\neszköz tárhelyére az éppen kiválasztott témát és ezt minden alkalmazás indításkor\nfigyelembe veszi és az adott eszközön preferált színt tölti vissza.\n• Kijelentkezés\n31\n_____________________________________________________________________________\n6.2.7 Kisebb modulok\nEnnél a résznél megemlítenék pár kisebb modult, mint például az elérhetőségek, a hírek és az\nosztott modul.\nAz elérhetőségek modulban megtaláltható az adminisztrátor által szerkeszthető, elérhetőségek\nlistája.\nA hírek modulban egy egyszerű lista található, amelyen a hírek borítóképét, címét és első\nbekezdésének első pár szavát láthatjuk, amire rákattintva megjeleníthetjük a teljes cikket.\nAz utolsó modul a megosztott (shared) modul, amely tartalmaz minden olyan komponenst és\nszervízt, amelyet az alkalmazás több területén is felhasználunk.\nábra 22 - Prompt komponens\nEgy jó példa erre a jóváhagyó szövegdobozok megjelenítésére szolgáló prompt szervíz és\nkomponens páros, ami arra szolgál, hogy ha valahol szükségünk van egy művelet megerősítésére\nakkor a prompt szervíz „promptForConfirmation” függvénye segítségével és azon opcionális\nparamétereinek kitöltésével bárhol megjeleníthetünk a megadott paramétereknek megfelelő\nprompt komponenst (lásd 22. ábra).\n32\n_____________________________________________________________________________\nábra 23 - Példa prompt létrehozására, illetve a válasz várására\nA prompt komponensben választott adatot (általában igen vagy nem) megkapjuk választértéknek\nabban a komponensben, ahonnan indítványoztuk ennek a megjelenését (lásd 23. ábra).\n6.3 A fejlesztéshez használt technológiák\n6.3.1 Arculat megtervezése Adobe XD-ben\nábra 24 – A projekt arculattervezése Adobe XD szoftverben\n33\n_____________________________________________________________________________\n6.3.2 Szoftver implementálása Angular-ben\nEbben a részben a szoftver implementálásának főbb lépéseiről lesz szó.\nSzükséges eszközök telepítése\nEsetünkben az Angular fejlesztéshez szükséges az npm (Node Package Manager) és az Angular\nCLI (Command Line Interface) telepítése a számítógépünkre. Ha ezek sikeresen megtörténtek\nakkor léphetünk csak tovább a következő lépésre.\nAz alkalmazás létrehozása és futtatása\nA létrahozást és az alkalmazás első futtatását az Angular CLI, az npm és a Terminal (Windows\nesetén Powershell) következő parancsaival tehetjük:\n• ng new usochool: létrehozunk egy üres projektet „usochool” néven\n• cd usochool: belemegyünk a CLI által létrehozott usochool mappába\n• npm install: feltelepítjük az alap működéshez szükséges csomagokat (package)\n• ng serve: elindítjuk az alkalmazást a localhost (saját számítógépünk) 4200-as portján\nModulok létrehozása\nA modulok létrehozásához az ng generate module a_modul_neve parancsot kell használnunk,\namely létrehoz egy mappát és egy üres modult.\nInterfészek létrehozása\nAz interfészek az Angular-ben egy adott változó, illetve objektum típusát hivatottak meghatározni.\nEzeket azért használjuk, hogy ne tudjuk tévedni egy változó értékadásakor, például egy\ndarabszámot tároló változónak (ami egy számot vár) ne tudjunk szöveg típusú értéket adni.\nábra 25 - Példa Typescript interfészre\n34\n_____________________________________________________________________________\nSzervizek létrehozása\nEgy szervíz létrehozásához az ng generate service útvonal/szervíz-neve parancsot kell\nhasználnunk.\nKomponensek létrehozása\nA komponensek létrehozása is parancssorból történik, viszont oda kell figyelnünk arra, hogy a\nmegfelelő parancs lefuttatása után ellenőrizzük le, hogy megfelelő mappába jött létre, illetve, hogy\nbekerült a megfelelő modul „declarations” tömbjébe, különben a modulba importált egyéb\nalapvető működést biztosító modulok (pl. Az Angular Common modulja) nélkül a komponens\nműködésképtelen lesz.\n6.3.3 Natív alkalmazás megvalósítása Capacitor segítségével\nA natív alkalmazás kigenerálása három egyszerű lépésben történik:\n• Telepítés az ng add @capacitor/angular hozzáadjuk a Capacitor csomagot az\nalkalmazásunkhoz.\n• Második lépésként az Angular alkalmazásunkat lefordítjuk Javascript-re az ng build\nparancs segítségével.\n• Ezután telepítjük a szükséges Capacitor csomagokat: npm i @capacitor/ios\n@capacitor/android, majd a Capacitor parancsait használva hozzáadjuk a különböző\nplatformokat:\no iOS: npx cap add ios\no Android: npx cap add android\n• Végül pedig szinkronizáljuk az alkalmazásunk forráskódját a hozzáadott platformok\nkódjával és megnyitjuk őket a platformspecifikus fejlesztői környezetben: npx cap sync\nios → npx cap open ios; a parancsokat követően megnyílik az Xcode fejlesztői környezet,\nahol natív készülékeken natív alkalmazásként tudjuk kezelni.\n6.4 Szervizek és adatbáziskezelés\nEgy Angular alkalmazásban „a szervíz egy tág kategória, amely magában foglal minden olyan\nértéket, funkciót vagy szolgáltatást, amelyre egy alkalmazásnak szüksége van. A szolgáltatás\njellemzően egy szűk, jól meghatározott célú osztály. Valami konkrétat kell csinálnia, és azt jól kell\ncsinálnia” [14].\n35\n_____________________________________________________________________________\n6.4.1 Bejelentkezés és felhasználókezelés\nAz alkalmazásban a minden felhasználókezeléssel kapcsolatos műveletért a user szervíz és az\nauthentication szervíz felelős.\nElső sorban az authentication szervízt emelném ki, amely a FireAuth SDK (Software Developers\nKit vagyis szoftverfejlesztő készlet) segítségével létesít a Firebase szolgáltatásaival kapcsolatot és\nteszi lehetővé a bejelentkezést (lásd 26. ábra), a felhasználók regisztrálását, az elfelejtett jelszó\nmódosítását, valamint a kijelentkezést.\nábra 26 - A bejelentkezésért felelős függvény az authentication szervízben\nTovábbá szintén ez a szervíz figyeli egy állandó feliratkozás (lásd 27. ábra) által azt, hogy ha egy\nfelhasználó éppen be van jelentkezve vagy ki van jelentkezve, illetve, ha ez állapot változik akkor\nértesíti a felhasználó (user) szervízt.\nábra 27 - A felhasználó állapotát figyelő feliratkozás\nA user (felhasználó) szervíz megkapja parméterként a bejelentkezett felhasználó egyedi\nazonosítóját és létrehoz egy olyan feliratkozást, amely az alkalmazáson belül bárhonnan\nfeliratkozhatunk és megkapjuk a felhasználó összes adatát. Ezáltal lehetővé teszi, hogy csak egy\nhelyen kell figyelnünk a felhasználó adatait, de akárhány helyen tudjuk használni valós időben.\n36\n_____________________________________________________________________________\nTovábbá a user szervíz tartalmaz minden olyan függvényt is, amely egy felhasználó adatainak\nmódosításához szükséges.\n6.4.2 Napló kezelés\nA catalogue (napló) szervízben található minden olyan függvény, amely a naplóval kapcsolatos.\nAz alábbiakban egy rövid példán keresztül szeretném bemutatni, hogy hogyan működik egy ilyen\nművelet.\nábra 28 - Egy diák hozzáadása egy osztályhoz\nA 28. ábrán látható példán szeretnék lépésenként végig haladni, amelyben egy diák hozzáadása\ntörténik egy osztályhoz.\nElső lépésben a függvénynek megadjuk, hogy melyik diákot szeretnénk melyik osztályhoz\nhozzáadni. Ezután az AngularFire segítségével létrehozunk egy referenciát az adott osztály\n(„classDocRef”) és az adott diák („userDocRef”) dokumentumához az adatbázisból.\nábra 29 - IClass: egy osztály objektum típusa\n37\n_____________________________________________________________________________\nKövetkező lépésként az „updateDoc” (ami szintén egy AngularFire által biztosított) függvénynek\naz osztályról már létrehozott referenciát, illetve az IClass típusú (lásd 29. ábra) objektum\n„students” listájához hozzáadjuk a „student” elemet, vagyis egyszerűen szólva az\nosztálynévsorhoz hozzáadjuk a diákot.\nLegutolsó lépésként pedig a diák dokumentumáról készült referencia segítségével frissítjük a diák\nadatai közt lévő osztályazonosító mezőt az osztály egyedi azonosítójával.\n6.4.3 Könyvtár kezelés\nA library (könyvtár) szervíz a diák és a tanár számára lehetővé teszi, hogy láthassa az összes\nkönyvet, ami megtalálható a könyvtárban a „getBooks$()” függvény segítségével. Ezen kívül\nlehetővé teszi a könyvtáros számára a könyvek eltávolítását/hozzáadását a könyvtár adatbázisához,\nilletve a kölcsönzések menedzsmentjét.\n6.4.4 Kisebb feladatok ellátására szolgaló szervizek\nNéhány, az alkalmazásban megtalálható kisebb funkcionalitásért felelős szervízt is megemlítenék,\nmint például a téma változtatására és elmentésére szolgáló theme (téma) szervíz. Alkalmazás\nindításakor meghívásra kerül a téma szervíz, ami megvizsgálja, hogy ennek az eszköznek a\ntárhelyére volt-e beállítva téma preferencia. Amennyiben volt preferencia beállítva így visszaadja\naz elmentett téma azonosítóját, ha pedig nem akkor az alapértelmezett témát teríti vissza. Abban\naz esetben amikor a felhasználó a profil oldalán megváltoztatja a témabeállítást, akkor a téma\nszervíz elmenti azt a felhasználó eszközének memóriájába (a local storage-be), illetve, ha már\nlétezik akkor felülírja azt.\nEgy másik szervíz, ami egy célzott feladatot lát el az a file-upload (fájlfeltöltés) szervíz, ami\nszintén az AngularFire segítségével tölti fel a fájlokat a Firebase Storage-be. Ezt a szervízt jelenleg\naz alkalmazásban a profilkép feltöltésére használjuk.\nA legutolsó kis szervíz, amiről szót ejtenék ebben a részben az a navigation (navigáció) szervíz.\nEz a szervíz az Angular Router (beépített szervíz, amely a megfelelő komponensek\nmegjelenítésére szolgál) segítségével navigál minket a komponensek között.\n6.5 Verziókövetés\nAz alkalmazás fejlesztése során GitHub-ot használtam (lásd 30. ábra), ami egy\nverziókövetőrendszer. Egy ilyen rendszer használata az egyszemélyes szoftverfejlesztésben is\n38\n_____________________________________________________________________________\nnagyon hasznos tud lenni mivel, ha időnként feltöltjük az alkalmazásunk állapotát - pl. egy\nlefejlesztett rész után – a GitHub-ra akkor bármikor könnyen visszaállíthatunk egy működő\nállapotot. Nem utolsó sorban pedig egy biztonságos mentési forma.\nábra 30 - A projekt GitHub felülete\n39\n_____________________________________________________________________________\n7. A szoftver bemutatása\nEbben a fejezetben a felhasználói felütet szeretném bemutatni az alkalmazásról készült\nképernyőképek segítségével. Az alkalmazásban a különböző folyamatokat a főbb szerepkörök és\nfolyamatok szerint fogom bemutatni az alábbiakban.\n7.1 Bejelentkezés és főoldal\nábra 31 - Képernyőkép a bejelentkezésről és a főoldalról\nA fenti képernyőképen (31. ábra) az első részben látható az, ami minden felhasználót fogad, aki\nnincs bejelentkezve. Itt két lehetőség nyílik mindenki számára az első az e-mail cím és jelszó\nmegadása, majd a „Sign In” gomb megnyomása, ami benavigálja a főoldalra (31. ábrán utolsó\nrésze). Ha esetleg a felhasználó elfelejtette a jelszavát akkor a „Forgot password?” feliratra\nkattintva lehetősége nyílik jelszócserét kérvényezni az e-mail címe megadásával.\n40\n_____________________________________________________________________________\nábra 32 - Képernyőkép a profilról\nA 32. ábrán látható képernyőképek a profil oldalt mutatják be. Az alsó sorban található három\ngomb, amelyből az első kétszeri megnyomásával kijelentkezhetünk az alkalmazásból, a\nmásodikkal visszaléphetünk a főoldalra és az utolsóval pedig két téma közül választhatunk. A téma\nszínének változását a 31-es ábra első két részén figyelhetjük meg. Az ábra harmadik része a\nprofilképcserére létező lehetőségeket mutatja be.\n7.2 A napló funkcionalitás\n7.2.1 Diák\nA 33. ábrán látható képernyőkép csoportból az elsőn egy diák főoldalát láthatjuk. A „catalogue”\ngombra kattintva tovább navigálhatunk a diák naplójára, ahol láthatjuk a tantárgyak listáját,\namelyeket a diák tanul és ha azok bármelyikére rákattintunk akkor megjelennek egy felugró\nablakban a tantárgyon belül lévő részletesebb adatok: jegyek és hiányzások.\n41\n_____________________________________________________________________________\nábra 34 - Képernyőkép egy diák naplójáról\n7.2.2 Tanár\nábra 33 - Képernyőkép egy tanár naplójáról\n42\n_____________________________________________________________________________\nEbben a részben a 34. ábráról lesz szó, amely a tanár lapjóját mutatja be. Az első részében láthatjuk\naz osztályok listáját, amiben tanít és az első tantárgyra rákattintva lenyílik egy lista, hogy milyen\ntantárgyakat tanít abban az osztályban. A második részben láthatjuk egy tantárgyra rákattintva az\nosztálynévsort, melyből egy nevet kiválasztva megnyílik a harmadik rész, ahol a tanárnak\nlehetősége nyílik megtekinteni és szerkeszteni a diák jegyeit és hiányzásait. A jegy szerkesztését\nés hozzáadását a 35. ábrán szemlélhetjük.\nA 35. ábra első részében egy már meglévő jegyre rákattintva felugrik az „Edit Grade” ablak, ahol\nszerkeszthetjük a jegyet a „+” és a „-” gombok megnyomásával, illetve a jegyre kattintva ki is\nválaszthatjuk azt. A dátumra nyomva szerkeszthetjük a dátumot is, majd a „Save” feliratú gombbal\nelmenthetjük a változtatásokat. Az ábra utolsó részében egy új jegy hozzáadásra láthatunk példát,\nahol szintén ugyanazok a lehetőségek megvannak, mint szerkesztésnél, de van egy plusz választási\nlehetőség, amelyben eldönthetjük, hogy a jegy milyen típusú: általános vagy félév végi\ndolgozatjegy.\nábra 35 - Képernyőkép jegyek kezeléséről\n43\n_____________________________________________________________________________\n7.3 Adminisztrátor\nA 36. ábra első részén látható képernyőkép az adminisztrátor által látható főképernyő\nbejelentkezés után. A főoldalon lehetősége nyílik a következő menedzsment oldalak megnyitására:\nosztályok, felhasználók, tantárgyak és elérhetőségek kezelése.\n7.3.1 Osztályok kezelése\nAz osztályok kezelésénél (37. ábra) egy listát láthatunk, amelyben 9.-12.-ig vannak csoportosítva\naz osztályok. Ezen felül a lista alatt található „navigáció vissza” gomb mellett található egy „+”\ngomb amire rákattintva megjelenik egy „Add class” felirat, amire újból rákattintva vagyis\nmegerősítve a műveletet megjelenik az új osztály létrehozására alkalmas felugró ablak (37. ábra).\nábra 36 - Képernyőkép adminisztrátor szemszögből és az osztályok menedzsmentjéről\nAz új osztály hozzáadásánál az első kitöltendő mező a „promotion year” vagyis, hogy a\nlétrehozandó osztály mikor fog végezni, amely megadása nélkül a többi mezőre nem is tudunk\nkattintani. Ha ezt megtettük a második mező automatikusan kitöltődik és a harmadik mezőben\nmegjelenik minden olyan osztályprofil, amely elérhető még az adott évben ( a 37. ábrán látható\npéldában azért jelent meg csak az E, mivel az A, B, C, D osztályok már léteznek ebben az évben).\n44\n_____________________________________________________________________________\nA legutolsó mezőnél pedig az osztályfőnök kiválasztása történik, ahol a listában megjelennek\nolyan tanárok, akik még egy osztályban sem osztályfőnökök.\nábra 37 - Képernyőkép az osztályok menedzsmentjéről\nEgy már létrehozott osztály példáját láthatjuk a 38. ábrán, ahol már hozzá van rendelve egy\nosztályhoz a tantárgy lista és a diákok listája is. A diákok listájánál és a tantárgyak listájánál is\ntalálható egy „+” és egy „-” gomb, amelyre, ha rákattintunk megjelenik egy felugró ablak, amely\nlehetővé teszi a tantárgyak, illetve a diákok hozzáadását és eltávolítását. Ezen az ábrán az utolsó\nrészben láthatunk példát a diákok eltávolítására egy osztályból.\nA következő ábra (39.) egy tantárgy hozzáadására ad példát, ahol első lépésben kiválasztjuk a\ntantárgyat, majd a következő lépésben az újabb legördülő listába megjelenik a kiválasztott\ntantárgyat tanító tanárok listája. Az eltávolítás menete pontosan úgy működik, mint a diákok\neltávolításánál.\n45\n_____________________________________________________________________________\nábra 39 - Képernyőkép az osztályok szerkesztéséről\nábra 38 - Képernyőkép tantárgyak hozzáadásról egy osztályhoz\n46\n_____________________________________________________________________________\n7.3.2 Felhasználók kezelése\nEbben a részben a felhasználók menedzsmentjéről lesz szó. A 40. ábra első részében látható két\nválasztási lehetőség az új felhasználók hozzáadása és a már meglévő felhasználók kezelése.\nTovábbi részben látható egy felhasználó létrehozásához szükséges űrlap (az első a diák és a\nmásodik a tanár). A kétállású választóval kiválasztva a megfelelő típusú felhasználót, majd az\nadatok kitöltése után a „Create user” gombra kattintva hozhat létre az adminisztrátor új\nfelhasználót.\nábra 40 - Képernyőkép felhasználók kezeléséről és létrehozásáról\nA létrehozott felhasználók listáját és azok szerkesztését a következő (41.) ábrán figyelhetjük meg,\nahol szintén találkozunk a felhasználó típusának választójával. A kívánt felhasználó típus\nkiválasztása után megjelennek a listában a diákok vagy a tanárok, amelyet tovább szűrhetünk a\nkeresőbe beírt szöveg segítségével.\nEgy diák esetében a „View” gombra rákattintva a 41. ábrán látható első szerkesztői űrlap jelenik\nmeg, amíg a tanárra rákattintva az ábrán látható második űrlap jelenik meg. Mindkét esetben az\nűrlap módosítása után az űrlap alján megjelenik egy „Save” feliratú gomb, amelyre kattintva\nmenthetjük a módosításokat. A tanár esetében található egy plusz gomb: „Edit subjects”. Erre a\n47\n_____________________________________________________________________________\ngombra kattintva egy felugró ablak jelenik meg ahol, szerkeszthetjük a tanár által tanítható\ntantárgyak listáját.\nábra 41 - Képernyőkép felhasználók listájáról és szerkesztéséről\n7.4 A könyvtár menedzsmentje\nA könyvtár menedzsmentjét egy könyvtáros szemszögéből demonstrálom, amely a 42. ábrán\nlátható. Az első részében a könyvtáros által látható főoldalt szemlélhetjük, ahol lehetősége van a\nkönyvtárosnak külső szemlélőként is megtekinteni a könyvtárat, valamint kezelheti is azt. A\nmásodik részben a könyvtár menedzsmentjének főoldala található, ahonnan további két opció\nnyílik a könyvtárosnak: az első a könyvek kezelése és a második a kölcsönzések kezelése.\nA könyvek kezelése opció kiválasztása után megjelenik a jelenleg elérhető könyvek listája,\namelyeket szerkeszthet, eltávolíthat, illetve hozzáadhat új könyveket a listához (43. ábra).\n48\n_____________________________________________________________________________\nábra 43 - Képernyőkép a könyvtárról a könyvtáros szemszögéből\nábra 42 - Képernyőkép egy könyv hozzáadásáról és szerkesztéséről\n49\n_____________________________________________________________________________\nA 44.-ik ábrán egy éppen elérhető könyv kiadásának folyamatát láthatjuk, míg a 45.-ik ábrán\nlátható egy kikölcsönzött könyv részletes adatai és annak visszaadási folyamat, hogy a könyv újra\nelérhető legyen.\nábra 44 - Képernyőkép a kölcsönzés folyamatáról\nábra 45 - Képernyőkép kölcsönzés befejezésének folyamatáról\n50\n_____________________________________________________________________________\n8. Összefoglalás\nA projekt keretében sikerült megvalósítani egy működő naplót, amely képes helyettesíteni egy\nkézzel írott naplót. A megvalósítás főbb részletei a következők:\n• Az alkalmazás tervezésénél fő szempont volt a letisztult, intuitív felhasználói felület\nkészítésé, valamint a felület személyre szabhatósága, ami a témaválasztásnál valósult meg.\n• A legfontosabb pont az egyszerű kezelhetőség és az átláthatóság volt, ami abban nyilvánult\nmeg, hogy egyszerre egy képernyőn ne legyen túl sok információ, tehát minden oldal és\nfelugró ablak lényegre törően jelenítse meg az elvárt információkat.\n• Továbbá az alkalmazás céljaihoz tartozott az is, hogy multiplatform legyen, ami meg is\nvalósult, mivel jelenleg iOS és Androidos eszközökön is megfelelően működik, de a\nplatformtámogatottság könnyedén bővíthető.\n• Egy hozzáadott plusz elem is belekerült az alkalmazásba: a könyvtár. A könyvtár\nmenedzsmentje is sikeresen meg lett valósítva.\nMindezt összevetve nem csak egy kézzel írott naplót helyettesítő alkalmazást sikerült létrehozni,\nhanem egy többfunkciós alkalmazást egy iskola számára.\nAz alkalmazás publikusan elérhető a következő GitHub linken:\nhttps://github.com/szab0lcs/uSochool\nTovábbfejlesztési lehetőségek\nAz alkalmazás továbbfejlesztésére rengeteg lehetőség van és ezek közül néhány már be is került a\nfelhasználói felületbe a tervezés során. Ilyen már előre létrehozott részek: az órarend és a hírek.\nTovábbá a felhasználói élmény javítása érdekében megemlítenék még három lehetőséget is:\n• Az első egy úgynevezett betöltést jelző komponens, ami akkor jelenne meg, ha az adat\néppen töltődik és a lassú internetkapcsolat miatt várnunk kell a teljes információ\nmegjelenésére.\n• Egy új a felhasználó számára releváns adat frissülésekor a felhasználó értesítést kaphatna\naz eszközére, mint például, ha a diáknak beírtak egy jegyet valamilyen tantárgyból vagy\nha egy kikölcsönzött könyv visszaviteli határideje közeledik, vagy már lejárt.\n51\n_____________________________________________________________________________\n• A harmadik lehetőség egy diákok és tanárok közötti üzenetváltásra alkalmas felület, amely\nakár referálhatna egy adott adatra, például az üzenetben meg lehetne adni egy referenciát\negy adott jegyre vagy hiányzásra a könnyebb és maradandó kommunikáció érdekében.\n52\n_____________________________________________________________________________\n9. Irodalomjegyzék\n[1] L. A. Bove és S. Conklin, Learning strategies for faculty during a learning management\nsystem migration, \" Online Journal of Distance Learning Administration 23.1 , 2020.\n[2] J. T. Nagy, Using learning management systems in business and economics studies in\nHungarian higher education, Educ Inf Technol, 2016.\n[3] „Marketing Professzorok,” [Online]. Available: https://matebalazs.hu/html.html.\n[Hozzáférés dátuma: 23 June 2021].\n[4] „Marketing Professzorok,” [Online]. Available: https://matebalazs.hu/css.html. [Hozzáférés\ndátuma: 23 June 2021].\n[5] „Csstricks,” [Online]. Available: https://hu.csstricks.net/8224637-what-is-javascript-\ncomplete-introduction-with-hello-world-example. [Hozzáférés dátuma: 22 June 2021].\n[6] B. L. Michels, „Medium,” 8 August 2017. [Online]. Available: https://medium.com/front-\nend-weekly/typescript-vs-javascript-a3c0beb8b6d9. [Hozzáférés dátuma: 21 June 2021].\n[7] G. LIM, Beginning Angular with Typescript (updated to Angular 9), Independently\nPublished, 2020.\n[8] „Gremmédia,” [Online]. Available: https://gremmedia.hu/angular-react-vagy-vue-melyiket-\nlehet-erdemes-hasznalnunk. [Hozzáférés dátuma: 22 June 2021].\n[9] K. T. Jánosi-Rancz, „Moodle - Sapientia Marosvásárhely,” [Online]. Available:\nhttps://moodle.ms.sapientia.ro/pluginfile.php/14309/mod_resource/content/1/MVVM.pdf.\n[Hozzáférés dátuma: 24 June 2021].\n[10] „informatika.gtportal.eu,” [Online]. Available:\nhttps://informatika.gtportal.eu/letoltes/jegyzetek/Adatbazis_szakiskola_szoveg.pdf.\n[Hozzáférés dátuma: 25 June 2021].\n[11] „PHP Műhely,” [Online]. Available: https://phpmuhely.hu/muhely/segedletek/olvas/sql-\nalapok-2-resz-select-statement. [Hozzáférés dátuma: 25 June 2021].\n53\n_____________________________________________________________________________\n[12] „MDN Web Docs,” [Online]. Available: https://developer.mozilla.org/en-\nUS/docs/Web/HTTP/Overview. [Hozzáférés dátuma: 24 June 2021].\n[13] „ambassadorpatryk.com,” [Online]. Available:\nhttps://ambassadorpatryk.com/2020/03/publish-web-socket-in-the-experience-layer/.\n[Hozzáférés dátuma: 24 June 2021].\n[14] Google, „angular.io,” 28 Február 2022. [Online]. Available:\nhttps://angular.io/guide/architecture-services. [Hozzáférés dátuma: 15 Június 2022].\n[15] S. Rafiq, A. K. Shakeel és T. Yasmin, „Educational Use of Smartphone among University\nStudents: A survey of world-ranked universities in Pakistan,” 2020.\n54\n_____________________________________________________________________________\nUNIVERSITATEA SAPIENTIA DIN CLUJ-NAPOCA\nFACULTATEA DE ȘTIINȚE TEHNICE ȘI UMANISTE, TÎRGU-MUREȘ\nSPECIALIZAREA CALCULATOARE\nVizat decan Vizat director departament\nConf. dr. ing. Domokos József dr. ing. Szabó László Zsolt\n55",
        "keywords": [],
        "hash_code": 560621487,
        "department": "cs"
    },
    {
        "author": "Koncz András",
        "supervisor": "dr. Antal Margit,, Conferențiar universitar",
        "year": "2024",
        "abstract": "The topic of my thesis is a web interface that helps students tofind theirwayaround the\nuniversity andto askfor help.My webapplicationfacilitatesthe preparationof studentsstudying\nat Sapientia University, Faculty ofTechnical andHumanSciences, enhances theiruniversity life\nbybuilding mentor-mentee relationships.\nNowadays, especially for first year students, socialization and access to information is a\nbig challenge.Thesolution isa websitethroughwhich studentscanask for andoffer helptoeach\nother. Thisnot onlyhelpsthem socializeina newenvironment,but alsocontributesto improving\ntheir academicperformance.\nMy aim was to provide a user-friendlyinterfacethat makesit easyfor students tocontact\neach other for help. I also aimed to provide alibrary ofresources whereusers canbrowse useful\nlinks, exam papers and theses to provide them with inspiration and support. In my experience,\nstudents face many difficulties during their university years, and I believe that my website can\nprovide a solution to these learning and orientation problems. I particularly value the features\nthat support mentor-mentee relationships, which facilitate communication between users and\nhelpstudents tointegrateinto theuniversity environment.\nMy project is based on the Spring Boot framework. The client side I implemented\ncommunicates with the server side via REST API requests. Themainfeatureof theclient sideis\nthe use of HTML, CSS and JS technologies, complemented by the Thymeleaf template engine.\nUsing these,I havetriedto create themost transparentand user-friendlyinterfacepossible.\nThe result of my work is a responsive and easy to use web interface, which provides\nfunctionality to help students of our university in their studies. The SapiMentor application is\naccessible attheaddress www.sapimentor.eu.",
        "keywords": [
            "mentoring",
            "Thymeleaf",
            "OpenAI",
            "webapplication",
            "Spring Boot"
        ],
        "hash_code": 6531063972,
        "department": "cs"
    },
    {
        "author": "Körmöci Csaba",
        "supervisor": "Dr. Kátai Zoltán,, conferențiar universitar",
        "year": "2023",
        "abstract": "As cryptocurrencies have become more and more widespread these days, cryptocurrency\nsites and applications have become more popular. It is vital to have tools and platforms that\nallow trading cryptocurrencies. In the crypto world, these are the decentralised exchanges. These\nare platforms or applications that allow cryptocurrencies to be exchanged directly between each\nother without the need for an intermediary. In addition, decentralised exchanges provide a way to\nsupply liquidity to the system. At the same time, they also allow liquidity to be withdrawn.\nBased on this information, the aim of my thesis is to develop a mobile application that\nallows users to exchange cryptocurrencies on both Android and iOS. Note that we do not allow\nusers to buy cryptocurrencies, only to exchange them.\nIn creating my thesis, I needed to learn about the technologies, different principles and\nsolutions that make a decentralised exchange possible. These included different blockchain\ntechnologies, smart contracts and the main functionalities of decentralised exchanges.",
        "keywords": [
            "decentralized exchange",
            "smart contract",
            "crypto",
            "blockchain"
        ],
        "hash_code": 8084975685,
        "department": "cs"
    },
    {
        "author": "Kristóf István-Levente",
        "supervisor": "Dr. Kátai Zoltán",
        "year": "2022",
        "abstract": "Nowadays, IT has become one of the fastest growing industries. We often hear about new\ntechnologies every month or even every week. For recent graduates from academic institutions to\nsucceed in such a dynamic and fast growing environment, it is essential that they have mastered\nthe basics of programming during their studies. One of the basic concepts that can give\nuniversity students a lot of headaches is recursion.\nThe aim of this paper and the accompanying visualisation software is to serve as an educational\ntool for those who wish to gain a deeper understanding of the phenomenon of recursion. The user\nis given the opportunity to visualise different recursive functions using the software. Unlike the\nusual visualization tools, this application uses the method of stairs to visualize the depth of\nrecursion.\nThe presented software can be useful not only for students who want to learn, but also for\nall those who want to explore the phenomenon of recursion by observing interesting patterns in\nvisualizations.\n7",
        "keywords": [],
        "hash_code": 1768879450,
        "department": "cs"
    },
    {
        "author": "Ș.l.dr.ing.SzántóZoltán KállaiBalázs",
        "supervisor": "",
        "year": "2024",
        "abstract": "Nowadays, most people have smartphones that allow them to solve various problems using different\napplications. StayConnected is an innovative application that not only helps maintain users’ social\nconnectionsbutalsooffersnumeroususefulfeaturestofacilitatetravelanddailytasks.\nThe current features of the application include posting pictures, exchanging messages with other\nusers, and creating personal profiles where users can view their posts, items for sale, and events they\nhavecreated.\nOne of the main functions of the application is navigation, which works using Flutter Map. Users\ncan create routes or trips consisting of multiple points and specify several points within a selected\nradius, which draws points of interest (POIs). By selecting these, the route connects these points.\nHoldingdownonapointonthemapallowsuserstocreateevents,suchasacarmeet-up.\nAdditional features of the application include the visibility of users on the map, along with their\nlast login location and time. The market function allows users to post items for sale, and the posting\nlocation is added to the item, which, when clicked on by another user, the app automatically plans\na route from the current location to the item’s location. The application has a search function that\nreturnsresultsfortheenteredtext,includingmarketandregularposts.\nThe app receives and notifies the user of notifications, such as when they receive a message. The\nserverbehindthemapisprivate. WeruntheOSRMAPIonourownserver,andwedirectourrouting\nrequests to this server. If the private server is unavailable, the app sends requests to the standard\nOSRMserver,maximizingreliability. TheapplicationalsoincludesaQ&Apagewhereuserscanask\nquestionsandotherscanrespond.\nThe application settings include a general settings page where users can set the app’s theme (four\nthemes are available) and select the start page (feed page, navigation page, market page, or profile\npage). Ontheprofilesettingspage,userscanchangetheirbio,username,andprofilepicture.\nThefollowingfeaturesareunder development: alibrarysectionwhereuserscan createcategories\nand subcategories and upload documentation they own, a virtual garage that contains users’ cars,\nwhich will later be used for speed recommendations in route planning. Special events can be created\nwhile driving, such as reporting accidents or potholes based on the existing event creation function,\nand we also plan to expand the Q&A page by adding the ability to rate answers and evaluate the\nreliabilityofresponders.",
        "keywords": [
            "Flutterapplication",
            "socialmedia",
            "navigation."
        ],
        "hash_code": 9911177368,
        "department": "cs"
    },
    {
        "author": "Lukács Botond",
        "supervisor": "Dr. Turos László-Zsolt",
        "year": "2022",
        "abstract": "Intoday’sworldmicrocontrollersystemcanbefoundinalotofthingsandtheyhaveabigprocessing\ncapacityandcanbeusedgenerallyinalotofdifferentapplications. Theyhavealotoffunctions,from\nmaking a LED blink to automating complex systems. They also can be easily connected to external\ncomponentssothiswaytheycanbeusedinmoreways.\nFor this cause this dissertation main goal it making a system which will be able to identify simple\nelectoronic components whith their aproximative values and their pinouts. In electoronics there are\na lot of electronic components, like resistors, capacitors, diodes and transistors. But when building\na circuit it is good to know what is the component and their pinout, which is more important on\nsemiconductors. In a lot of times the identifier values are unreadable or there is no datasheet avabile\nso it is hard to idnetify the component. For this purpose the \"electronic component teszter\" was made\nwhich automaticall identif and outputs the component values or outputs if if failed to identify the\ncomponent. The process if fully automatic, only the component need to be connected to the tester\nsocketandtogleswitchoritautomaticallystartswhenitisconnectedtopower.\nThedissertationwillcovermicrocontrollerapplicationsandtheirdesignforcomponentrecogniti-\nonandmeasurement.",
        "keywords": [
            "microcontroller",
            "transistor",
            "identifying 9"
        ],
        "hash_code": 9884667041,
        "department": "cs"
    },
    {
        "author": "Lukács Orsolya",
        "supervisor": "Ș.l.dr.ing. Szántó Zoltán",
        "year": "2022",
        "abstract": "Today, smartphones make most of our lives easier, as they allow us to access\nservices that embrace our day-to-day operations. Theseservicesareavailable through\na downloadable application, a website created by a specialized company. In many\ncases, software can save energy and time. The need to manage time can also be\nobserved in the case of services that put our health and well-being first.\nAs part of my dissertation, I am developing a software that provides health\nservices. Important information is that the software is actually on-demand, serving a\nClient. The Client'sjob isto adviseondiet,to workasa dietitianin whichshecan use\nthe software. The implemented application, which allows the monitoring of clients,\nthe creation of recipes and diets, was created with the help of Flutter. We use the\nreal-time database provided by Firebase to store the data. The application is also\navailable to patients, where they can follow their diet, monitor their changes in body\nsize, and scheduleappointmentswith theirdietitian. Theprimarybasisof thesoftware\nwas to minimize the number of applications required to be used in the work of a\ndietitian. Similar applications have beenobserved, aswell asdifferentparameters that\nneed to be considered when developing a medical application.\nThe Clientalso took partinthecomplete developmentof thesoftware, andher\ncomments and needs were taken into account. The application is a version of the\nexpected software, for which there are still some development ideas, but for now, it\nfully covers the main functionalities.",
        "keywords": [
            "medical application development",
            "dietitian",
            "patient",
            "flutter 9"
        ],
        "hash_code": 2311258494,
        "department": "cs"
    },
    {
        "author": "Lörinczi Mátyás",
        "supervisor": "Dr. Lefkovits László, Oltean-Péter Boróka",
        "year": "2024",
        "abstract": "UsingGraphAlgorithmsonRealNetworks\nThis project develops a web application for the Exodus organization, which is involved in orga-\nnizing camps. The application provides an interface for hosts, bush camps, and teams, as well as an\nadministrative interface to upload their data into the system. Users can easily add and update their\nprofiles,includinglocations,dates,andnecessaryresources.\nThe program automatically organizes the camps using a modified Kruskal algorithm, taking into\naccount various constraints and preferences, such as distance, scheduling, and participant needs. The\nalgorithmoptimizesthedistributionandschedulingofthecampstobeasefficientaspossible.\nOnce the camps are organized, the application visually represents them through interactive maps\nandcharts. Thisallowsadministratorsandparticipantstoeasilyviewcamplocations,dates,andother\nimportantinformation. Theaimoftheapplicationistofacilitateandstreamlinethecamporganization\nprocessandtomaketheprocessesmoretransparentforparticipants.",
        "keywords": [
            "Exodus",
            "webapplication",
            "planning",
            "graphvisualization"
        ],
        "hash_code": 690535069,
        "department": "cs"
    },
    {
        "author": "Madaras Ervin",
        "supervisor": "Dr. Vajda Tamás",
        "year": "2022",
        "abstract": "The project aims to develop software for a wood processing company that canrecognise\nPAL boards by identifying and comparing different properties. This software will help the\noperator of an automated crane to avoid cases where, due to humanerror,the suppliersends the\nwrong type of PAL plate, or where, due to the same error, the woodworking company has\nordered the wrong type of PAL plate. These mistakes can lead to PAL boards, because of a\ndifferent type than the one set for the automated crane, being sent to the wrong place in the\nwarehouse or even the wrong type of board being processed.\nThe wood processing plant provided data with images of the PAL plates, and from this,\ntwo classification algorithmswere implemented.Since onlyoneimagesampleof each PALplate\nexists in the database, traditional classifiers based on artificial intelligence cannot be used. For\nthis reason, thetwoalgorithms thathave beenimplementedextract featuresfrom eachimageand\nuse these features to compare the input sample with the images in the database for comparison.\nOne of these methods, which has been implemented, determines the dominant colors of\nthe images by clustering. By comparing dominantcolors,the algorithmis able todeterminehow\nsimilar two images are to each other. By calculating the Euclidean distance between the\ndominant colors, it can give a value for how different the two images are from each other,\nobviously the smaller the distance, the more similar the images are.\nAnother method that has been implemented is to split the imagesintosegments andthen\ncompute a histogram for each segment. These histograms are then concatenated to create a\nfeature vector for the images. It then compares the feature vectors using chi-square distance.\nThe conclusions are that the algorithms are sensitive to rotation. However, nice results\nwill be obtained ifa segmentof theimagesis created, oronlyone dominantcolorisselected and\ncompared.",
        "keywords": [
            "dominant color",
            "histogram",
            "classification",
            "similarity measure"
        ],
        "hash_code": 1377752079,
        "department": "cs"
    },
    {
        "author": "Zoltán Magyarosi Roland-Mihály",
        "supervisor": "Ș.l. dr. ing. Szántó",
        "year": "2021",
        "abstract": "Nowadays less and less attention is given to development and modernizing of Desktop\napplications over web and mobile. Although Desktop applications have an important role in the\nlives of users and IT workers. With the quick evolution of mobile phones practically everything\nis possible using the smartphone in our pocket, but it couldn’t and probably will not be able to\nsurpass computers for a while.\nThe dissertation focuses on a system designed for personal computers or laptops that\nperfectly meets the role of a virtual assistant in our life. The IPA (intelligent personal assistant)\nsoftwares help the uses perform easy, but frequent tasks like browsing the internet, sending e-\nmails and swiftly opening applications while the input is not codes or signals, but simply a\nhuman voice. Presumably this is the reason for the success of this science that has grown into an\nindustry.\nVirtual assistants are the blessing of the 21st century, but their history dates back to 1920.\nEvery assistant is different, but their purpose is the same: serving the user. In our case a user is\nperson in front of a computer whose job Sapientia Sarah tries to make easier, with performing\nsimple, but frequent commands. This technology is accessible on both smartphones, computers\nand recently in household appliances and cars as well.\nIn my dissertation I studied desktop applications and development of these, voice\nrecognition, executing voice commands and the structure, use and development of virtual\nassistants.",
        "keywords": [
            "virtual assistant",
            "desktop application",
            "user",
            "technology"
        ],
        "hash_code": 6633082011,
        "department": "cs"
    },
    {
        "author": "Magyar Roland István",
        "supervisor": "Ș.l. dr. ing. Fehér Áron",
        "year": "2024",
        "abstract": "Research and development in bionics are crucial for individuals with disabilities, aiding in the\nrestoration or augmentation of physical functions. The functioning of human body parts is\nakin to robots, responding to various signals and performing movements. By capturing and\ncontrolling these electrical impulses, we can transmit them to areas where direct connection is\nseveredorintegratethemintodevices.\nThe aim of my thesis is to demonstrate the control of a 3D-printed hand using real-time\nvideo from a camera, enabling robotic finger movements based on human hand movement.\nAdditionally, it allows extraction of hand movement information from EMG signals, enabling\ncontrol of the robotic hand with a microcontroller. The device processes EMG signals, and a\n3D model and necessary software have been developed to process camera images and control\nthemotorsforappropriatefingermovement.\nThe thesis introduces the concept of bionics and its relevance, drawing parallels between\nthe human body and robots, and emphasizing the role of electrical impulses in movement. It\nreviews relevant literature, focusing on neuromuscular processes, anatomy, and principles of\nelectromyography(EMG),includingtypesofEMGelectrodesandmuscleelectricalactivity.\nIt provides an overview of the electronic components used, such as operational amplifi-\ners, filters, and analog-to-digital conversion, discussing electronic noise management. Image\nprocessing techniques for controlling the robotic hand are explored, detailing digital signal\nprocessing and system integration. Specifications and system architecture are discussed, inc-\nluding functional and non-functional requirements, and choices for models and motors. The\nmicrocontrollersandEMGsensorsusedarealsodescribed.\nSystemdesignincludespreparingthe3Dmodelofthehand,testingthemotors,processing\nsignals, and integrating EMG electrodes. Firmware development focuses on implementing the\nWiFiaccesspoint,ADCreading,andspikedetectionoftheEMGsignal. Softwaredevelopment\nfor image processing and data transmission to the microcontroller is also covered, describing\nthresholdingtechniquesfordetectinghandmovements.\nTheimplementationandexperimentalresultschapteroutlinesinstallationstepsandsystem\nperformancemeasurements.\nThe final chapter provides general conclusions and suggests future work, discussing pos-\nsiblesystemimprovementsandextensions,suchasintegratingadditionalsensorsandadvanced\nsignal processing algorithms. It compares similar devices and analyzes potential development\ndirections.\nThis project demonstrates the feasibility of controlling a 3D-printed robotic hand using\nEMGsignalsandimageprocessing,openingnewopportunitiesforadvancedprostheticdevices.",
        "keywords": [
            "imageprocessing",
            "digitalsignalprocessing",
            "EMG",
            "Python",
            "ESP32"
        ],
        "hash_code": 895695046,
        "department": "cs"
    },
    {
        "author": "Szabolcs Molnár Orsolya-Izabella",
        "supervisor": "Drd. Csaholczi, Dr. Iclănzan David",
        "year": "2024",
        "abstract": "In recent years, the accounting sector has seen significant advancements, now em-\nploying much more modern applications to handle incoming data with greater ease and\nefficiency, facilitating their utilization and recording. There are already applications that\nstreamline the accountant’s tasks with just a press of a button or a few clicks.\nRecently, the use of Optical Character Recognition (OCR) and artificial intelligence\n(AI) technologies has become widespread in accounting. These technologies have revolu-\ntionizedtheprocessingoffinancialdata. OCRtechnologyallowsfortheextractionoftext\nfrom scanned documents, whether they are invoices or receipts, enabling automatic data\nentry and reducing errors associated with manual input. AI algorithms provide substan-\ntial assistance in accelerating processes that would otherwise be more time-consuming\nfor humans. However, these technologies are not infallible and may require human inter-\nvention to ensure acceptable results.\nThe aim of my thesis is to leverage the aforementioned technologies to simplify the\nwork of accountants through a straightforward user-friendly web environment. The appli-\ncation allows for the scanning and processing of key invoice data (such as invoice number,\ndue date, total amount, buyer/seller information). The extracted text from invoices can\nalso be translated into other languages, as the application was designed for universal use,\naccessible even to accountants who speak foreign languages.\nThe system’s backend is Python-based, while the frontend utilizes JavaScript and\nthe React framework. Data is stored in a PostgreSQL database. The optical character\nrecognition technologies used include the well-known Tesseract and DocTR. AI-based\ntechnologies include DeepL for translation and ChatPDF for answering queries related\nto uploaded invoices.",
        "keywords": [
            "OCR",
            "invoice management",
            "translation",
            "Python application",
            "web inter- face 2"
        ],
        "hash_code": 8420305279,
        "department": "cs"
    },
    {
        "author": "Nagy Andrea",
        "supervisor": "Prof. dr. ing. Dávid László",
        "year": "2022",
        "abstract": "The primary aim of the dissertation is to study the electrical activity of the brain, namely\nthe EEG-type signals and to automatically recognize specific emotions. This requires sampled\ndata collection and I used “Muse 2” headband in order to sample and collect this data. It was\nasked a woman and a man for the data collection and both of them made the same experiment.\nI processed the raw data, then I used it to build and teach an artificial neural network, which\nwas created with the help of Tensorflow and Keras frameworks.\nThe secondary aim of the dissertation is to examine the spectrum of the samples and\napply different transformations, then to compare them. Based on previous research I examined\nthe processing of continuous and discrete signals and placed more emphasis on discrete\ntransformations.\nBased on my results (70-80% recognition efficiency), in order for the neural network\nto be as accurate as possible, it is necessary to collect more data, classify them into classes by\nproviding them in a more optimal way. To reach this goal, in the future I would like to develop\na set of rules from the collected data and to classify my data based on these rules, and so I hope\nto achieve greater recognition efficiency.",
        "keywords": [
            "EEG",
            "spectrogram",
            "signal processing",
            "Tensorflow",
            "neural networks."
        ],
        "hash_code": 1899062594,
        "department": "cs"
    },
    {
        "author": "Zoltán Nagy-Serbán Tünde",
        "supervisor": "Ș.l.dr.ing. Szántó",
        "year": "2021",
        "abstract": "Thisdisertationpresentsawebapplication,whichincludesthe3DvirtualtourofSapientiaHungarian\nUniversityofTransilvania,FacultyofTehnicalandHumanSciences,fromTârguMures.\n,\nNowadays, people in big part of the day are in the influence of digitalization. Most of the people\nhasatleastasmatphone,apcoralaptopandwiththesealsohastheconnectiontotheinternet,which\ngivesinfinitepossibilities.\nDigitalization introduces a lot of good features for humanity. Problems can be solved with using\nthe internet and a digital device, for example: paying bills, keeping the relation with relatives and not\nleastwiththehelpofthevirtualtours,peoplecanreachplaces,wheretheynevercouldbe.\nThis dissertation it is about a web application, which uses and displays a 3D model from the\nbuilding of the university, creating a virtual tour of it. To this tour can attend anyone and with this,\nthe posibility is given to have a look inside the building. Beside this has an informational purpose,\nbecause the application shows a lot of information about the university, for example: events (Sapi-\nLine-Tracer),orthenameandthecontactofthespecialistcoordinators.\nTheapplicationhasafeaturewiththename“Takeme!”,whichtakestheusertotheselectedplace\nand also shows the route to reach there, giving a lot of help for visitors. Beside this the user has the\npossibilitytowalkanywhereinsidethemodelandwiththistheusercandiscoverthecompletemodel.\nThe system was made on web interface and thanks to this it can be used almost on all the devices\nlike on pc, laptop and also on smartphone. The application can give a lot of help for the new students\nandalsoforthestudentsandteacherswhoareonlyinvisittofamiliarizeinafasterwaywiththemain\nbuildingoftheuniversity.",
        "keywords": [
            "webapplication",
            "3Dmodel",
            "virtualtour. 5 SAPIENTIA ERDÉLYI MAGYAR TUDOMÁNYEGYETEM MAROSVÁSÁRHELYI KAR SZÁMÍTÁSTECHNIKA SZAK Sapi3D tour – UI DIPLOMADOLGOZAT Témavezető: Végzős hallgató: Dr. Szántó Zoltán",
            "Nagy-Serbán Tünde egyetemi adjunktus 2021 Kivonat A dolgozat egy webalkalmazást mutat be",
            "amely a Sapientia Erdélyi Magyar Tudományegyetem Marosvásárhely-ikaránaka3Dvirtuálistúrájátfoglaljamagába. Amaivilágbanazembereknapjaitnagybanbefolyásoljaadigitalizáció. Alegtöbbembernéltalál- hatólegalábbegyokostelefon",
            "számítógép",
            "laptopamelyekmellétársulazinternetisígyaleheto˝ségek számavégtelen. A digitalizáció az emberek számára nagyon sok jó dolgot vezet be. Rengeteg problémát tudunk megoldaniazinternetésadigitáliseszközöksegítségével",
            "mintpéldául: számlákfizetése",
            "távoliroko- nokkal könnyebb a kapcsolattartás és nem utolsó sorban a virtuális túrák segítségével eltudunk jutni olyanhelyekreahovánembiztos",
            "hogyazéletbenleszleheto˝ségünk. A dolgozatban egy webes applikációról van szó amely felhasznál egy 3D modellt az egyetem- ro˝l létrehozva az egyetem úgy nevezett virtuális túráját. A túrán bárki résztvehet ezáltal betekintést nyerhet az egyetem falai mögé. Ezen kívu˝l informatív jelleggel is rendelkezik",
            "mivel az alkalma- zásszámosinformációtmegjelenítazegyetemmelkapcsolatban",
            "mintpéldául: különbözo˝ események (Sapi-Line-Tracer)",
            "szakkoordinátoroknevei",
            "elérheto˝ségei. Az alkalmazás ugyanakkor rendelkezik a \"Vigyél el!\" funkcionalitással",
            "amely a felhasználó által kiválasztott helyiséghez mutatja meg az odavezeto˝ utat",
            "sok segítséget nyújtva az egyetemre látoga- toknak. Ezen kívül arra is van leheto˝ség",
            "hogy a felhasználók saját maguk lépegessenek az egyetem modelljénígymégjobbankörbetudjákjárniazt. Arendszerwebesfelelületrekészültésennekköszönheto˝enmajdnemmindeneszközönmeglehet tekinteni",
            "úgyaszámítógépenmintalaptoponésnemutolsósorbanatelefononis. Azalkalmazássok segítséget nyújthat az újjonnan érkezo˝ egyetemistáknak",
            "vendég diákoknak és a vendég tanároknak is azegyetemfo˝ épületébenvalóeligazodásnál. Kulcsszavak: webalkalmazás",
            "3Dmodell",
            "virtuálistúra."
        ],
        "hash_code": 2047149331,
        "department": "cs"
    },
    {
        "author": "Nüszl Richárd-István",
        "supervisor": "Dr. Szabó László Zsolt",
        "year": "2023",
        "abstract": "The topic of the project is to develop a web application that connects students, companies, and\nuniversities during their internships. The goal is to develop a user-friendly platform capable of\nmanaging the entire process related to internships.\nOne of the major objectives of the project is for the application to function as a\nprofessional-oriented social platform for students and companies, thereby facilitating the\ndevelopment of professional relationships and nurturing partnerships between companies and\nuniversities.\nAnother important objective of the project is to provide students with recommendations\non the platform based on their profiles and fields of study. This allows them to find relevant\nopportunities in the field of internships. The algorithms of my recommendation system, using\ntechniques like Cosine Similarity, consider the students' skills, interests, and the requirements set\nby the companies. Thus, the platform helps students find the most suitable internship positions,\noptimizing the related processes and ensuring the effectiveness of the internships.\nTo develop the project, I am using modern web technologies such as Angular, Java\nSpring Boot, PostgreSQL, and AWS. These technologies help make the platform robust, scalable,\nsecure, and fast.",
        "keywords": [
            "Internship",
            "Recommendation System",
            "Cosine Similarity",
            "Angular",
            "Spring Boot"
        ],
        "hash_code": 6647580175,
        "department": "cs"
    },
    {
        "author": "Palfi Szabolcs",
        "supervisor": "Dr. Szántó Zoltán",
        "year": "2021",
        "abstract": "These days the majority of shopping is done online. There are tons of online shopping websites, with\nsomekindofbigsalegoingonalmostallthetime,howeverthesesalesaremostofthetimemadeup.\nThese false sales can be spotted only if you follow a products price daily, for a longer period of time\nwhich is a repetitive and time-consuming process. The same can be said when you’re interested in\npurchasing some products but you’re not quite decided yet, so you want to wait for the price to drop.\nThesegavetheinspirationfordevelopingoursystem.\nInthispaperwe’llpresentapricemonitoringsystemwhichautomatestheprocessdescribedearli-\ner. AtpredefinedmomentsthesystemwakesupandscrapespubliclyavailabledatafromtheInternet,\nwhicharethansaved. Theuserhastheopportunitytoaddproductstohislist,forthemtobefollowed,\nand can view the price change on a chart. All this can be done from a Chrome browser extension or\na mobile application built with Flutter. The so-called heart of the system is a python script which is\nresponsiblefortheminingofthedata,periodicallyupdatingthepricesandpushingnewproductsinto\nthedatabase. Allthisisdonewhilerespectingallmoralandlegalboundaries. Allofourdataisstored\ninaRealtimeDatabaseprovidedbyFirebase,whichturnedouttobeperfectforourapplication.\nAfter months of gathering data, while using the system, we analyzed it and made a few conclu-\nsions. We saw multiple patterns emerging from the price changes but there is not one that matches\neveryproduct. Thereweremanyscamsregardingprices,especiallyduringBlackFridaybuttherewe-\nre also real and significant price drops as well. After using the system for a longer period of time we\ncan say that a software like this helps the buyers in making a purchase decision, by providing useful\ndatainaeasytoreadform.",
        "keywords": [
            "webscraping",
            "browserextension",
            "Flutterapp 8"
        ],
        "hash_code": 161681634,
        "department": "cs"
    },
    {
        "author": "Pál Andor",
        "supervisor": "Dr. Szabó László Zsolt",
        "year": "2023",
        "abstract": "The aim of the thesis is to design and develop a web application that digitises the\nchoice of subjects for the diploma. A solution was needed that would help and facilitate\nthe work of the university committee and students in the diploma topic selection process.\nOur objectives included the development of a web application that could handle a\nlarge number of data and users and could be easily used by anyone. The application\nshould meet all university requirements and could be further developed on request. Be\nsecure and ensure that the application is maintainable.\nThe objectives have been achieved in all areas. A web application has been developed\nthat secretaries can log into and create periods and invite teachers and students to the\nsystem. Teachers can upload their degree topics and students can apply for them. And\nguests can view the diploma topics they have created.\nA wide range of technologies have been used in the development. Most prominent are\nthe frontend and backend frameworks. Using Angular and Spring to boot I was able to\ndevelopahighlyscalableandsecurewebapplication. UsingPostgreSQLdatabasetostore\ndata and testing frameworks and applications Cypress and Postman for maintainability.",
        "keywords": [],
        "hash_code": 2546271706,
        "department": "cs"
    },
    {
        "author": "Rigmányi Zsombor",
        "supervisor": "Prof. Dr. Habil. Szilágyi László",
        "year": "2023",
        "abstract": "The aim of this thesis is to classify chest X-rays to detect the presence of pneumonia.\nA convolutional neural network was used to achieve a more accurate classification. Our\ngoal was to develop an efficient classifier, which is a neural network created by our own\nmodel, or a neural network with GoogleNet architecture, trained for our own purposes\nusing “transfer learning” technique.\nOur research methodology was based on studying existing solutions, conducting our\nown experiments and collecting data. We applied the transfer learning technique to the\nGoogleNet architecture, which is a pre-trained large model, thus improving the classi-\nfication accuracy. Data collection was performed using chest X-rays of pneumonia and\nasymptomatic cases.\nBased on the results, we were able to develop a graphical user interface that allows\nautomaticclassificationofchestradiographsanddiagnosisofpneumonia. Theneuralnet-\nwork with GoogleNet architecture achieved outstanding accuracy on the tested dataset,\nand compared to our own classification network, produced significantly better results,\nsimilar to the results of the networks studied in the literature.\nBased on these results, we conclude that a well-written neural network interoperating\nwith the GoogleNet architecture can effectively detect pneumonia based on chest X-ray.\nThis research could contribute to the improvement of medical diagnostics, helping early\ndetection and more effective treatment.",
        "keywords": [
            "chest X-ray",
            "classification",
            "convolutional neural network",
            "transfer learn- ing",
            "GoogleNet architecture"
        ],
        "hash_code": 9553014538,
        "department": "cs"
    },
    {
        "author": "Tamás Rozsnyai Arnold-Robert",
        "supervisor": "Dr. Vajda, UNIVERSITATEA „SAPIENTIA” din CLUJ-NAPOCA Viza facultății:, Facultatea de Științe Tehnice și Umaniste din Târgu Mureș, Specializarea:Calculatoare și tehnologia informației, LUCRARE DE DIPLOMĂ, Coordonator științific: Candidat: Rozsnyai Arnold-Robert, ș.l. dr. ing. Vajda Tamás Anul absolvirii: 2022, a) Tema lucrării de licență:, PRELUCRAREA STATISTICA A RUTELOR VEHICULELOR, b) Problemele principale tratate:, - Studiul unor sisteme și algoritmi similari, - Proiectarea și implementarea unei aplicații, - Sunt necesare revizuirea literaturii, proiectarea software-ului și documentația de, implementare, prezentarea și interpretarea rezultatelor măsurătorilor, c) Desene obligatorii:, - Schema bloc al aplicației, - Diagrame UML privind software-ul realizat., d) Softuri obligatorii:, -Aplicație, e) Bibliografia recomandată:, -Leaflet - a JavaScript library for interactive maps, f) Termene obligatorii de consultații: săptămânal, g) Locul și durata practicii:Universitatea „Sapientia” din Cluj-Napoca, Facultatea de Științe Tehnice și Umaniste din Târgu Mureș, Primit tema la data de: 31.03.2021, Termen de predare: 26.06.2022, Semnătura Director Departament Semnătura coordonatorului, Semnătura responsabilului Semnătura candidatului, programului de studiu, Declarație, Subsemnata/ul ............................................................., absolvent(ă) al/a specializării, …………………………………………………………., promoția………… cunoscând, prevederile Legii Educației Naționale 1/2011 și a Codului de etică și deontologie profesionalăa, Universității Sapientia cu privire la furt intelectual declar pe propria răspundere că prezenta, lucrare de licență/proiect de diplomă/disertație se bazează pe activitatea personală, cercetarea/proiectarea este efectuată de mine, informațiile și datele preluate din literatura de, specialitate sunt citate în mod corespunzător., Localitatea, Data: Absolvent, Semnătura………………………, Declarație, Subsemnata/Subsemnatul .................................................., funcția……………………., titlul științific………………… declar pe propriarăspunderecă …………………………………, absolvent alspecializării……………………..conform HG............................aîntocmit prezenta, lucrare sub îndrumarea mea., În urmaverificării formei finaleconstatcă lucrareadelicență/proiectul dediplomă/disertația, corespunde cerințelor de formă și conținut aprobate de Consiliul Facultății de Științe Tehnice și, Umaniste din Târgu Mureș în baza reglementărilor Universității Sapientia. Luândînconsiderare, și Raportul generat din aplicația antiplagiat „Turnitin” consider că sunt îndeplinite cerințele, referitoare laoriginalitatealucrăriiimpusede Legeaeducației naționalenr. 1/2011șide Codulde, etică și deontologie profesională a Universității Sapientia, și ca atare sunt de acord cu, prezentarea și susținerea lucrării în fața comisiei de examen de licență/diplomă/disertație., Localitatea, Data: Semnătura îndrumătorului, Prelucrarea statistică a rutelor, vehiculelor, Extras, În ultimii ani, sa înregistrat o creștere rapidă a necesității de vehicule echipatecu GPS., Pe măsură ce devine o prioritate din ceînce mai marepentruoamenisăajungă dela unpunctla, altul cât mai ușor posibil, poate fi beneficsă poțifiltra secțiunilede drummai aglomerate.Poate, fi util pentru proprietarul vehiculului să cunoască cât mai multe informații recuperabile despre, vehicul, pe baza traseului parcurs., Scopul tezei este de a procesa traseele vehiculelor, deducând din acestea informații, cu, ajutorul cărora să poată fi filtrate datele relevante (viteza medie, coordonatele curbei). Setul de, date disponibil este alcătuit din diferite date (coordonate, viteză, consum, direcție). Algoritmul, dezvoltat poate fi utilizat pentru a reducesetulde datefără apierdedate importantedinpunct de, vedere statistic., Datele cele mai importante conțin coordonatele careaurezultatschimbarearutei. Soluția, este capabilă să detectezecurbedincare poategenera statisticisemnificative(viteza medieîntr-o, curbă). Drept urmare, este capabil să compare diferite rute și să sugereze altele noi., Dezvoltarea are loc în ASP.NET Core Web App și este testată în xUnit, în care, elementele hărții sunt afișate folosind Leaflet și OpenStreetMap., Cuvinte cheie: set de date, statistici, traseu, SAPIENTIA ERDÉLYI MAGYAR, TUDOMÁNYEGYETEM, MAROSVÁSÁRHELYI KAR, SZÁMÍTÁSTECHNIKA SZAK, JÁRMŰVEK ÚTVONALAINAK, STATISZTIKAI FELDOLGOZÁSA, DIPLOMADOLGOZAT, Témavezető: Végzős hallgató:, Dr. Vajda Tamás Rozsnyai Arnold-Robert, Kivonat, Az utóbbi években rohamosan növekedett az igény olyan járművekre, amelyek GPS-el, vannak felszerelve. Mivel az emberek számára egyre nagyobb prioritást élvez, hogy minél, zökkenőmentesebben eljussanak egyik pontból a másikba, ezért előnyös lehet, ha képesek, vagyunk kiszűrni a forgalmasabb útszakaszokat. Hasznos lehet, ha a jármű tulajdonosa, minél, több visszakereshető információt tud a járműről a megtett útvonal alapján., A dolgozat célja feldolgozni a járművek útvonalait úgy, hogy ezekből olyan, következtetések jöjjenek létre, aminek a segítségévelreleváns adatokat(átlagsebesség,kanyarok, koordinátája) lehessen kiszűrni. A rendelkezésre álló adathalmaz különböző adatokból, (koordináta, sebesség, fogyasztás, irány) van felépítve. A fejlesztett algoritmus segítségével, csökkenteni lehet az adathalmazt, statisztikailag fontos adat elvesztése nélkül., A legfontosabb adatok tartalmazzák azokat a koordinátákat,amelyekútvonal változtatást, eredményeznek. A megoldás képes felismerni a kanyarokat, amelyekből jelentős statisztikai, adatokat (átlagsebesség a kanyarban) képes előállítani. Ennek eredményeképpen különböző, útvonalakat képes összehasonlítani és újakat is ajánlani., A fejlesztés ASP.NET Core Web App-ban zajlik és xUnit-ban van tesztelve, amelyben, Leaflet és OpenStreetMap segítségével vannak megjelenítve a térkép elemek., Kulcsszavak: adathalmaz, statisztika, útvonal, Abstract, In recent years, there has been a rapid increase in demand for vehicles equipped with, GPS. As it becomes an increasing priority for people to get from one point to another as, smoothly aspossible, it can bebeneficialto beable tofilter outthe busierroad sections.It canbe, helpful for the vehicle owner to know as much retrievable information about the vehicle as, possible based on the route taken., The aim of the dissertation is to process the routes of the vehicles in such a way that, conclusions can be drawn from them, withthe helpof whichrelevant data(averagespeed, curve, coordinates) can be filtered out. The available data set is made up of different data (coordinate, speed, consumption, direction). The developed algorithm can be used to reduce the data set, without losing statistically important data., The most important data contains the coordinates that result in a route change. The, solution is able to detect bendsfrom whichitcan generate significantstatistics(averagespeed in, a curve). As a result, it is able to compare different routes and suggest new ones., The development takes placeinASP.NET CoreWebApp andis testedinxUnit, inwhich, map elements are displayed using Leaflet and OpenStreetMap., Keywords: data set, statistics, path, Tartalomjegyzék, Bevezető 13, Irodalmi áttekintés 15, Szakirodalmi tanulmány 15, Ismert hasonló alkalmazások 17, OSRM 17, OptimoRoute 18, Elméleti megalapozás 19, Elméleti alapok 19, RDP 19, DBSCAN 20, DTW 21, KDTREE 22, Dijkstra 23, Felhasznált technológiák 24, ASP.NET Core MVC 24, SQL Server Express 25, xUnit Test Project 25, Entity Framework 26, Leaflet 27, OpenStreetMap 27, Rendszer specifikációja 28, Felhasználói követelmények 28, Rendszer követelmények 30, Funkcionális követelmények 30, Nem funkcionális követelmények 31, A rendszer architektúrája 32, Adatbázis 33, Alkalmazás 33, Fejlesztett algoritmusok működése 39, Felhasználói felület 41, Mérések és eredmények 43, Statisztikai adatok 50, Következtetések 55, Megvalósítások 55, Továbbfejlesztési lehetőségek 55, Irodalomjegyzék 56, 1. Bevezető, Napjainkban a járművek többsége GPS modullal van felszerelve, melynek célja a gyors, és problémamentes utazás. Ennek következményében nagy hangsúlyt fektettek az útvonalajánló, és útvonalfeldolgozó alkalmazások fejlesztésére, amelyek rövid időn belül képesek precíz és, hasznos információt biztosítani a jármű tulajdonosának. Ezenalkalmazásokpontossága rengeteg, adatgyűjtést és ellenőrzést követel, valamint manuálisan bevitt adatot. Ezért a legtöbb, útvonalajánló alkalmazás egy már létező és ellenőrzött földrajzi adatot tartalmazó adatbázis, használatával müködik. Az ilyen adatbázisok teljeskihasználásanem ingyenes,tehátahasználat, mértékével növekedik a költségek értéke is, valamint nem kivánt függőséget is okozhat., A fejlesztett alkalmazás ezen problémákra próbál megoldást biztosítani, a lehető, legkevesebb adatot felhasználva, illetve olyan eredményeket generálni, amelyek rendszerint, megegyeznek a többi hasonló alkalmazás eredményeivel. A felhasznált adatbázis egy jármű, megtett útvonalait tárolja, amelyek pontonként vannak elmentve, ezen pontok több, információkat tartalmaznak (koordináta, sebesség, idő, irány). Az összes olyan pont, amely egy, útvonal összekötő szakasz részeként irányváltást eredményez, releváns pontként vantekintve.A, dolgozat megvalósításai közé tartozik az adatbázisban lévő pontok mennyiségének a, csökkentése, anélkül hogy releváns pontok törlődtek volna el. Ennek a kivitelezéséhez a, Ramer-Douglas-Peucker (RDP) algoritmus volt felhasználva, amely egy vonalszakaszokból álló, görbét egy hasonló, kevesebb ponttal rendelkező görbévé alakít át. A következőkben szükséges, volt a pontok csoportosítása a kanyarokban található pontok információ gyűjtése céljából. Az, RDP által kapott feldolgozott pontok klaszterezésére a DBSCAN klaszterező algoritmus volt, felhasználva, amely által csoportosultak a kanyarokban található pontok. A pontok feldolgozása, által lehetővé vált két pont közötti legrövidebb útvonal ajánlása, heatmap generálása, amelyen, szemléltetődik az útvonalon haladó járművek átlagsebessége, valamint két kiválasztott útvonal, közötti különbség meghatározása. A legrövidebb útvonal ajánlásához a Dijkstra algoritmus volt, felhasználva, amely egy ponthoz képest az összes többi pontig kigenerálja a legrövidebb, útvonalat. A heatmap létrehozása, a klaszterezett pontok közötti helyes útvonalhoz tartozó, szomszédos pontok megtalálása révén jött létre. Két útvonal közötti különbség meghatározására, a Dynamic Time Warping (DTW) algoritmus jelentette a megoldást, amely két időbeli, szekvencia hasonlóságának mérését valósítja meg., Több nehézség is adódott a kívánt eredmények elérésealatt.Azegyik problémát azRDP, algoritmus okozta, mivel egyes esetekben nehéz volt megfelelő paramétereket választani,annak, érdekében hogy az eredménye tökéletesen ráilleszkedjen a térképen lévő útra. Egy másik, probléma az adatbázisban szereplő hibás pontok kikűszöbölése volt amit a GPS jelvesztése, eredményezett. A DBSCAN algoritmus néha olyan pontokat is csoportosít, amelyek egy másik, kanyarhoz tartoznak, mivel nehéz megtalálni a megfelelő paramétereit., A dolgozat célja egy olyan rendszer fejlesztése, amely csökkenti az adatbázisban lévő, felesleges adatok mennyiségét, kevés adatból képes minél helyesebb útvonalajánlásra, útvonal, összehasonlításra, valamint fontos statisztikai adatokat generálására a legtöbb útvonalról., A fejlesztés ASP.NET Core Web App-ban zajlik és xUnit-ban van tesztelve, amelyben, Leaflet és OpenStreetMap segítségével vannak megjelenítve a térkép elemek. A kódlogikája és, az adatok feldolgozása C#-ban íródott, valamint atérképenlévő elemekmegjelenítésére HTML, CSS és javascript kód volt írva., 2. Irodalmi áttekintés, 2.1. Szakirodalmi tanulmány, A járművek útvonalainak feldolgozása egy bonyolult és összetett folyamat, ami, eredményül olyan feldolgozott adatokat térít vissza, amelyek felhasználhatóak különböző, feladatokra,mint azútvonal ajánlás,információgyűjtés,útvonalakösszehasonlításaés statisztikai, adatok előállitása különböző útvonalakról. Ahhoz hogy ez a folyamat minél gyorsabb és, megbízhatóbb legyen, fontos hogy ne legyen eltárolva az összes olyan kezdeti adat, amely nem, releváns, a feldolgozás általi eredmény kivitelezéséhez. Erre a problémára Liangbin Zhao és, Guoyou Shi módszere jelentette számomra is a megfelelő megoldást, ahol az automatic, identification system (AIS) által kapott hajó pályáit tömörítették, a módosított, Ramer-Douglas-Peucker (RDP) algoritmus segítségével [1]. A probléma számukraazt jelentette, hogy túl sok adatot kellett tárolni, lekérdezni és feldolgozni. Az AIS pályát alkotó pontok, általában egyenes szakaszon haladnak, amelyek nagy részben fogjákalkotnia pályaösszetevőit, viszont a legfontosabb része apályánakazirányváltoztatást eredményezőpontokjelentik, mivel, valójában ez határozza meg a pálya alakját. Két részre bontják fel a pályát: egy egyenes és egy, íves részre. Úgy gondolják, hogy az egyenes és íves részek közötti átmeneti pont rendkívül, fontos a pályaalak jellemzőinekamegőrzésében. Aztállítják hogyezeketazátmeneti pontokat a, fordulókör sugarától függetlenül meg kell tartani. Az általuk végzett kísérletek szerint, 85,942,008 pontból sikerült 84,305,155 pontot eltávolítani az adathalmazból, ami a pontok, 98.095%-át jelentette, megtartva a pálya alapvető forgalmi jellemzőit. Ezek az eredmények, inspiráltak arra hogy alkalmazzam az általuk használt RDP algoritmust, hogy a járművek, útvonalait egyszerűsítsem, mivel hasonló mértékű problémát jelentett a nagy adatmennyiség és, ezeknek a feldolgozása. Ennek a megoldásnak a hátránya az, hogy szükséges egy megfelelő, paramétert találni az RDP algoritmusnak, ami által nem távolítja el az átmeneti pontokat. A, feldolgozás következő részében, olyan megoldásra volt szükségem amely, a feldolgozott, pontokat klaszterezni tudja annak érdekében, hogy felismerje a kanyarokat. Ebben az esetben, nem sikerült találnom egy olyan megoldást se, ami a jármű által megtett útvonalból kanyarokat, keressen klaszterezés által. Ezért elkezdtem kutakodni olyan klaszterezési algoritmusok után, amelyek alkalmasak GPS koordinátákklaszterezésére.Azelső módszert amivelpróbálkoztamaz, a K-Means klaszterezési algoritmus [2]. Azonban hamar kiderült, hogy ez nem lesz megfelelő, megoldás a problémára, mivel nem tudtam előre megállapítani a klaszterek számát, valamint, nem találtam egy olyan változatát se az algoritmusnak amely képes gyorsan kideríteni a, klaszterek számát. Egy nagyon jó megoldásnak találtam a DBSCAN klaszterezési algoritmust, ami képes arra hogy klasztereket alkosson egymáshoz közeli pontok szerint, anélkül hogy, paraméterként kérje a klaszterek számát, képes felismerni és elkülöníteni a klaszterekről a zajos, adatot, paraméterként kéri hogy minimum hány adat legyen a klaszterben és minimum milyen, távolságra legyenek a létrejött klaszterekközt[3]. Ennekköszönhetően nagyflexibilitástbiztosít, számomra, hogy észleljem a kanyarokat és ezek típusát, mivel ha a klaszterben lévő minimum, pontok száma változik, akkor változik a klaszterek száma is. Ez azt jelenti, hogy a gyakrabban, látogatott kanyarok fognak megmaradni az adathalmazban. Ennek hátránya viszont az, hogy, elveszhetnek olyan kanyarok is, amelyek fontosak lehetnek a további feldolgozásban., Hozzávetőlegesen könnyen gyorsítható is az algoritmus, az egyik módszer,egy gráfalapú index, struktúra használata, a szomszédos keresési műveletek felgyorsítására [4]. Azt követően, hogy, sikerült megtalálni a megtett útvonalakból, azokat a kanyarokat ahol áthaladt a jármű, valamely, módon létre kellett hozni egy összeköttetést a klaszterezett pontok közt, ami biztosítani fogja a, klaszterezett pontok átjárhatóságát, aminek a segítségével helyes útvonalat lehessen ajánlani., Erre a problémára nem sikerült megoldást találni, ezért ez egy saját megoldást követelt. A, leghíresebb útvonalajánló alkalmazások, mint a Google Maps, Mapquest, Waze mind képesek, bármely 2 útvonal közt kigenerálni a legrövidebb útvonalat,nagyonrövid időalatt,ráadásul úgy, képesek arra, hogy az útvonal minden pontja szorosan és kivételesen az utakhoz kapcsolódjon, így egy szép átlátható útvonal ajánlást biztosítva. Ezeknek a megvalósítása a GoogleMaps által, nem elérhető, csak az API-n keresztül kérhetőek le ezek az adatok. A Snap To Roads, szolgáltatásból kiindulva valamilyen formában el vannak tárolva az úthoz tartozó GPS, koordináták, és képes a megadott koordináták szerint visszatéríteni egy hasonló adathalmazt, amelyeken a jármű a legnagyobb valószínűséggel haladt [5]. Egy ilyen adathalmaz felépitésére, rengeteg adat szükséges, és minél több felhasználó részvétele szükséges annak érdekében, hogy, az összes út tárolható lehessen. A hátránya a nagy mennyiségű API hívások, amelyekértfizetni, kell annak érdekében, hogy hozzáférhetővé váljanak. Az összes útvonalajánló vagy utakat, szolgáltató alkalmazásért, valamilyen összeget kell fizetni, ahhoz hogy maximálisan kilehessen, használni. Az én megvalósításom, előzőleg feldolgozott adatok nélkül kellett megtalálja a, kanyarokat, felépíteni az útvonal hálózatokat aszerint, ahonnan a jármű vagy járművek, végighaladtak. Elméletileg elég optimalizálássalés elégmennyiségű ellenőrizetlenadattal,képes, lehessen hasonló útvonalat ajánlani mint például aGoogleMaps. Ahhozhogyaz útvonalajánlás, létrejöhessen szükségvanarra, hogyalétrehozottklaszterpontoktudják, hogykia szomszédjuk, tehát a jármű tudja milyen irányba haladhat. Egy hálózat kiépítésére volt szükségem, ahol, minden elem súlyozott kapcsolatban van egymással. Newman, egy olyan hálózat kiépítését, elemzi, ahol nem bináris kapcsolat van a hálózat elemei közt,hanem mindegyikkülönsúlyozott, kapcsolattal rendelkezik, amelyek jellemzik erősségeiketegymáshozképest[6]. Azt állítja,hogy, egy súlyozott hálózat matematikailag ábrázolható egy szomszédsági mátrixszal, olyan, bejegyzésekkel, amelyek nem egyszerűen nulla vagy egy, hanem egyenlők a súlyokkal a, széleken. Ennek köszönhetően hasonlóan kiépithető egy szomszédsági mátrix a klaszterezett, pontok szomszédai szerint. Ezt követően szükségem volt egy olyan algoritmusra amely képes, meghatározni a legrövidebb útat, a szomszédsági mátrix felhasználásával. DongKai Fan és Ping, Shi dolgozatukban megemlítik, hogy a Dijkstra algoritmusa a leginkább klasszikus és kiforrott, algoritmus a legrövidebb út kereséséhez egy grafikonon, azonban ennek az algoritmusnak nagy, az idő komplexitása és nagy tárhelyetfoglalel[7]. Egy olyan módosítottváltozatot mutatnakbe, amik ezeket a problémákat kiköszöbölik. Számomra alkalmas algoritmusnak bizonyosult az, útvonal ajánlásához,ezértén isalkalmaztam. Egymásikfunkcionalitás amitalkalmazniakartam, az az útvonalak összehasonlítása. Tehát egy már létező útvonalat hozzá akartam hasonlítani egy, új útvonalhoz, és meg akartam találni a legjobban egyező útvonalat az adathalmazból., Szükségem volt egy matematikai mértékre amivel meg tudom állapítani, mennyire különbözik, egy útvonal egy másik útvonaltól és ennek mennyi a mértéke. Pavel Senin, szerint a DTW, algoritmus rendkívül hatékonyan képes meghatározni az idősorok közötti hasonlóság mértékét., Emellett képes meghatározni egy távolság függvényt is, ami visszatériti két idősor eltérési, mértékét. Ezt felhasználva megtudtam állapítani két útvonal közti különbséget [8]., 2.2. Ismert hasonló alkalmazások, 2.2.1. OSRM, Az OSRM [9] egy nyílt forráskódú útválasztó gép amely nagy teljesítménnyelbírés egy, útválasztó motorként funkcionál. Bármely két pont között amely az úthálózatba tartozik, képes, kigenerálni a legrövidebb útvonalat. Az OSRM egy ingyenes hálózati szolgáltatás, BSD-licenc, alatt és C++-ban íródott. Felhasználja az OpenStreetMap (OSM) projekt nyílt és ingyenes, úthálózati adatait arra, hogy működésre bírja a kifinomult útválasztási algoritmusait. A, legrövidebb útvonalat akár egy kontinentális méretű hálózaton is képes kiszámítani, ami pár, másodpercet vehet igénybe ha gyórsitó technika nélkül történik. Az OSRM összehúzó, hierarchiák megvalósítását használja, aminek segítségével néhány ezredmásodperc alatt képes, kiszámitani és kiadni a legrövidebb utat bármely kiindulópont és cél között, ezért az egész, útvonal kiszámitása is kevés időt vesz igénybe. A legtöbb időt az útvonal annotálása és a, geometriai hálózaton keresztüli továbbítás jelenti. Nagy hangsúlyt fektet arra, hogy gyors, eredményt tudhasson generálni, ez számomra is fontos tényező, viszont felhasználja az, OpenStreetMap úthálózatait arra, hogy képes legyen pontos útvonal ajánlásra., 2.2.2. OptimoRoute, Az OptimoRoute [10] megtervezi és optimalizálja az útvonalakat és a menetrendeket a, szállítási munkaerő számára. Mindenki számára elérhetővé szeretnék tenni a tervezési, útválasztási és menetrend-optimalizálási általuk fejlesztett technológiát. Kisebb, vállalkozásoknak készült hatékonyság javítás céljából. Bevételnövelést, növekedett szállítási, lehetőségeket és munkamegrendelést igér, mindezt nagy hatékonyság mellett. Csökkenti a, működési költségeket és a túlórákat. Megjelenítéshez Leaflet-et és MapBox Streets-et használ., Hasonlóan használom én is a Leaflet-et az útvonalak kirajzolására., 3. Elméleti megalapozás, 3.1. Elméleti alapok, 3.1.1. RDP, A Ramer-Douglas-Peucker egy általános és jól ismert, vonal egyszerűsítő algoritmus., Egy megadott távolság küszöböt használva képes megőrizni a megközelítési vonal mentén lévő, irányokat, aminek az egyszerűsítése mértéke aszerint változhat,hogymilyenértéket adunkmeg., A célja az algoritmusnak csökkenteni a görbét alkotó pontok számát. Ha létezik egy olyan 𝐶, 1, görbe amely az 𝐴 = {𝑛 , 𝑛 , ... ,𝑛 } pontok halmazából áll, akkor meg akarjuk találni azt a 𝐶, 1 2 𝑘 2, görbét amely 𝐵 ⊂ 𝐴 pontok halmazából áll, mind ezt egy ε feltételezett elfogadotthiba mellett., Az algoritmus az 1. ábrán tekinthető meg, megvalósítása a következő módon történik[11]:, 1. ábra RDP algoritmus folyamata[12], 1. A 𝐶 görbe első és utolsó pontja [𝑛 𝑛 ] szakaszhoz kapcsolódik (1b. ábra). Az 𝑛 és 𝑛, 1 1 𝑝 1 𝑝, pontokat hozzáadjuk a 𝐵halmazhoz., 2. A görbe egyéb pontjai közül {𝑛 . . . 𝑛 } megkeressük azt az 𝑛 -t amelyre igaz, hogy, 2 𝑝−1 𝑘, az 𝑥távolság a legnagyobb az [𝑛 𝑛 ]szakasz.(1c. ábra), 1 𝑝, 3. Ha 𝑥 ≤ ε, teljesül akkor az algoritmus véget ért. Ebben az esetben a 𝐵 = {𝑛 ,𝑛 }, 1 𝑝, halmaz és azúj 𝐶 görbe egy[𝑛 𝑛 ]szakasz. Másikesetbenaz𝑛 pont hozzácsatolódika, 2 1 𝑝 𝑘, 𝐵 halmazhoz, majd az algoritmus rekurzívan lefutakövetkezőgörbékre:𝐶 ∈ [𝑛 𝑛 ] és, 1𝑘 1 𝑘, 𝐶 ∈ [𝑛 𝑛 ] (1d. ábra)., 𝑘𝑝 𝑘 𝑝, Az RDP algoritmus egy batch algoritmus, mert a teljes adatkészlet szükséges már a, 2, program lefutásának az elején. Az eredeti algoritmus időbonyolultsága 𝑂(𝑛 ) ahol 𝑛 az, adatpontok száma., 3.1.2. DBSCAN, Az egyik legismertebb sűrűség alapú klaszterező algoritmus a Density-based spatial, clustering of applications with noise (DBSCAN) [13]. Ha egy pontokkal rendelkező térben sok, pont van egymáshoz közel, azaz magas a legközelebbi szomszédok száma, ott egy csoport jön, létre, és a csoportba nem sorolható pontokat zajként értelmezzük. Ezenkívül a csoportokat és a, zajt is külön értelmezi, ezeket szétválasztva és külön visszatérítve. Kétparaméter (ε és𝑚𝑖𝑛𝑃𝑡𝑠), adható meg az algoritmusnak. Haegyadott dimenzióban tetszőlegesteretfeltételezünk, legyen ε, a legközelebbi szomszédot meghatározó paraméter egy ponthoz képest. A DBSCAN esetében a, pontok három csoportra oszthatók: corepoints, reachablepoints,outliers. Egy pontcorepoint(𝑝), ha legalább 𝑚𝑖𝑛𝑃𝑡𝑠(megadott minimum pontszám) pont ε távolságon belül található 𝑝 -t, beleértve. Egy pont directly reachable(𝑞) 𝑝-től ha 𝑞, ε távolságon belül van 𝑝-től. Egy pont, reachable(𝑞) 𝑝-től ha létezik egy útvonal 𝑝 , ... ,𝑝 , amiben 𝑝 = 𝑝 és 𝑝 = 𝑞, ahol minden, 1 𝑛 1 𝑛, 𝑝 directly reachable 𝑝-től. Minden pont ami egyik ponttól sem reachable azt outliers vagy, 𝑖+1 𝑖, noise point-nak értelmezzük., 2. ábra DBSCAN algoritmus[14], Magyarázat:, ● 𝑚𝑖𝑛𝑃𝑡𝑠 = 4 (𝐴körül ε sugárban hány pont legyen), ● a pirospontokcore pontokmivel azezeket körülvevőkörεsugarában legalábbnégypont, található (𝐴-t beleértve), ezek együtt egy klasztert képeznek., ● A sárga pontok nem core pontok hanem reachablepontok,mivel𝐴-tól elérhetőekatöbbi, core pointon keresztül., ● A kék pont nemelérhető egyikcorepoint általsem ésnem iscorepoint, ezértnoise point, lesz., A DBSCAN többször is átjárhatja az adathalmazösszespontját,azidőbonyolultsága egy, indexelő struktúrával (KDTree) amely a szomszédsági lekérdezést 𝑂(𝑙𝑜𝑔 𝑛)-ben végrehajtja, 𝑂(𝑛 𝑙𝑜𝑔 𝑛) lesz, ahol 𝑛a pontok száma., 3.1.3. DTW, A Dynamic Time Warping (DTW) algoritmus lehetővé teszi két időbeli sorozat, összehasonlítását. Az algoritmus képes egy optimális illeszkedést meghatározni két sorozat, között, valamint ezen idősorok közötti hasonlóság mértékét. Adott két idősor, 𝑋 = (𝑥 ,𝑥 , ..., 𝑥, ..., 𝑥 ), 𝑁∈ ℕ, és 𝑌 = (𝑦 ,𝑦 , ..., 𝑥 ..., 𝑦 ), 𝑀∈ ℕ, az értéksorozatokat, 1 2 𝑖 𝑁 1 2 𝑗 𝑀, jelenti (vagy a csúcssorozatok által ábrázolt görbéket). A 𝑋 és 𝑌 sorozatok egy 𝑛 * 𝑚 rácsot, alkotnak,aholminden pont (𝑖,𝑗) az 𝑥 és 𝑦 közöttiigazítás.A warping path𝑊leképezia 𝑋és 𝑌, 𝑖 𝑗, elemeit, hogy minimalizálja a köztük lévő távolságot. 𝑊 a rácspontok (𝑖,𝑗) sorozata. Az, optimális elérési út (𝑖 ,𝑗 )a következőképpen számítható ki:, 𝑘 𝑘, 𝐷 (𝑖 ,𝑗 ) = 𝑚𝑖𝑛 𝐷 (𝑖 𝑗 ) + 𝑑(𝑖 𝑗 | 𝑖 𝑗 ) (1), 𝑚𝑖𝑛 𝑘 𝑘 𝑖 𝑗 𝑚𝑖𝑛 𝑘−1 𝑘−1 𝑘 𝑘 𝑘−1 𝑘−1, 𝑘−1 𝑘−1, ahol: 𝑑 az euklideszi távolság, Ezután a teljes útköltség a következőképpen számítható ki:, 𝐷 = ∑𝑑(𝑖 𝑗 ) (2), 𝑘 𝑘, 𝑘, A warping path két sorozat összehangolására használható és dinamikus programozás, felhasználásával találjuk meg. Nem célszerű minden lehetséges útvonalat bejárni, mert ez túl, drága folyamat lenne. Hatékonysági okokból fontos korlátozni a lehetséges warping path-ek, számát, ezért a következő szabályok lesznek érvényesek[15]:, ● Peremfeltétel: Ez a feltétel biztosítja, hogy a warping path a két jel kezdőpontjával, kezdődik és a végpontokkal ér véget: 𝑖 = 1,𝑖 = 𝑛 é𝑠 𝑗 = 1, 𝑗 = 𝑚., 1 𝑘 1 𝑘, ● Monotonitási feltétel: Eza megszorításmegőrzi apontokidőrendjét (nemmegyvissza az, időben): 𝑖 ≤ 𝑖 é𝑠 𝑗 ≤ 𝑗 ., 𝑡−1 𝑡 𝑡−1 𝑡, ● Folytonosság (lépésméret) feltétele: Ez a feltétel korlátozza az útvonal-átmeneteket a, szomszédos időpontokra (nem ugrál az időben): 𝑖 − 𝑖 ≤ 1 é𝑠 𝑗 − 𝑗 ≤ 1., 𝑡 𝑡−1 𝑡 𝑡−1, Egy elfogadható warping path a sakk király lépéseinek a kombinációit tartalmazza, amelyek a, következők:, ● Vízszintes mozgások: (𝑖, 𝑗) → (𝑖, 𝑗 + 1), ● Függőleges mozgások: (𝑖, 𝑗) → (𝑖 + 1, 𝑗), ● Átlós mozgások: (𝑖, 𝑗) → (𝑖 + 1, 𝑗 + 1), A DTW algoritmus időbonyolultsága 𝑂(𝑛𝑚), ahol 𝑛 és 𝑚 a két bemeneti sorozat hossza., 3.1.4. KDTREE, A K-dimenziós fa (KDTREE) egy fa adatstruktúra, amely rendezett módon tárol egy, k-dimenzióban lévő pont gyűjteményt. Az egyik alkalmazása egy k-dimenziós térben lévő, legközelebbi pont megkeresése. Ebben az adatstruktúrában hatékony a pontok tárolása és, keresése. A kívánt szerkezet kialakítása az összes csomópont két felére osztásával alakul ki. A, csomópont balgyermekeabal felét,amíg ajobb gyermekeajobb felétképviseli. Atérkét részre, van osztva a méretek számától független módon. Pontosabban minden belső csomópont egy, hipersíkot jelent, amely két részre osztja a teret. Kétdimenziós tér esetében egyenes, háromdimenziós tér esetén sík. A térben lévő összes csomópont egy pontot jelent a fa, struktúrában., 3. ábra kétdimenziós pontok gyűjteménye egy kd fában tárolva[16], A 3. ábrán a pontokat tartalmazó terület (tetszőlegesen) egy 128 × 128méretűnégyzetre, van korlátozva, és minden belső csomópont felosztja a keresési teret. A kd-fa (a) bontása egy, 128 × 128 egységnyi régióra hét adatponttal (3a. ábra)a(b) régiókd-fája. Minden felosztástegy, vonal jelzi, amely függőleges az x megkülönböztetővel rendelkező csomópontok számára, és, függőleges az összes diszkriminátorral rendelkező csomópont esetében. Agyökércsomópont két, részre osztja a teret, gyermekei továbbosztják ateret.A gyerekekosztásvonalai nemkeresztezik, a gyökér osztásvonalát, így a kd-fa minden csomópontja segít a teret téglalapokra osztani, hogy, megmutassa hol helyezkedhetnek el a csomópontok a különböző részfákban., Statikus k-d fa felépítésének időbonyolultsága: 𝑂(𝑛 𝑙𝑜𝑔 𝑛), ahol 𝑛 a pontok száma. Egy, legközelebbi szomszéd megtalálása egy kiegyensúlyozott k-d fában véletlenszerűen elosztott, pontokkal átlagosan 𝑂(𝑙𝑜𝑔 𝑛)időt vesz igénybe., 3.1.5. Dijkstra, A Dijsktra[17] algoritmus megtalálja a legrövidebb útvonalat egy gráfban lévő pontok, között. Pontosabban egy kiválasztott ponttól megkeresi az összes ponthoz képest a legrövidebb, útvonalat. Az algoritmus egy kiválasztottcsomóponttólindul éselemzi agráfot, hogymegtalálja, a legrövidebb utat azadott csomópontösszestöbbi csomópontjaközött. Eltárolja acsomópontok, és a kiindulási csomópont között jelenleg ismert legrövidebb távolságokat, valamint módositja, ezeket az értékeket ha rövidebb útvonalat talál. Amikor az algoritmus sikeresen megtalálta a, legrövidebb útvonalat a kiindulási csomópont és egy másik csomópont között, az adott, csomópont státusza látogatott lesz és hozzáadódik az útvonalhoz. Ez a folyamat addig, folytatódik, amíg a gráf összes csomópontjához megtalálja a legrövidebb útvonalat. Az így, keletkezett adatokból pedig akiválasztottcsomópontból megkapjukazösszestöbbi csomópontig, vezető lehető legrövidebb útvonalat., A megadott 𝐺 = (𝑉, 𝐸) gráf szomszédsági mátrixként van ábrázolva. Itt 𝑤 [𝑢, 𝑣], tárolja az él súlyát. Legyen | 𝐸 | és | 𝑉 | a gráf éleinek és csúcsainak száma. Ezután, 2, meghatározható az időbonyolultság ami 𝑂(|𝑉| )lesz., 3.2. Felhasznált technológiák, 3.2.1. ASP.NET Core MVC, Az ASP.NET Core Model-View-Controller (MVC) keretrendszer egy könnyű, nyílt, forráskódú, könnyen tesztelhető, ASP.NET Core-ra optimalizált prezentációs keretrendszer. Az, ASP.NET Core egy MVC minta alapú módszert biztosít dinamikus webhelyek létrehozásához, amely elősegíti a problémák elkülönítését. Teljes ellenőrzést biztosít a jelölés felett, támogatjaa, TDD-barát fejlesztést, valamint a legújabb webes szabványokat használja[18]., Az ASP.NET Core MVC az ASP.NET Core Routing-ra épül, egy effektív, URL-leképezési komponensre, amely lehetővé teszi olyan alkalmazások létrehozását, amik, érthető, valamint kereshető URL-címekkel is bírnak. Lehetővé teszi az URL-elnevezési minták, meghatározását azokhoz az alkalmazásokhoz, amik alkalmasak keresőoptimalizálásra (SEO), valamint linkgenerálásra, független módon attól, hogy a webszerveren hogyan vannak, elrendezve. Útvonalakat határozhat meg egy kényelmes útvonalsablonszintaxis alkalmazásával, amely támogatja az útvonalértékekre, alapértelmezett értékekre, valamint behatárolt értékekre, irányuló megszorításokat., routes.MapRoute(name: \"Default\", template:, \"{controller=Home}/{action=Index}/{id?}\");, 1. kódrészlet konvenció alapú útválasztás, A konvenció alapú útválasztás (1. kódrészlet) lehetővé teszi az alkalmazás által, elfogadott URL-formátumok teljes körű meghatározását, valamint azt, hogy ezek a formátumok, hogyan kapcsolódnak az adott vezérlők konkrét műveleti módszereihez. Ha bejövő kérés, érkezik, az útválasztó motor megfelelő URL-t keres az egyik korlátozott URL-formátumhoz, majd meghívja a kapcsolódó vezérlő műveleti metódusát., [Route(\"api/[controller]\")], public class ProductsController : Controller, {, [HttpGet(\"{id}\")], public IActionResult GetProduct(int id), {, ..., }, }, 2. kódrészlet attribútum-útválasztás, Az ASP.NET Core MVC-modell-összerendelés a kliens kérés adatait (űrlapértékek, elérési út adatok, lekérdezési karakterlánc-paraméterek,HTTP-fejlécek) objektumokkáalakítja a, vezérlő által. Ez azt eredményezi, hogy a vezérlő logikájának nem kell kitalálnia a bejövő, kérésadatokat, mivel már rendelkezik az adatokkal a műveleti metódusának paramétereként., Az ASP.NET Core már rendelkezik beépített függőségi injekcióval (DI). Az ASP Core, MVC-ben a vezérlők konstruktoraikon keresztül kérik a szükséges szolgáltatásokat, lehetővé, téve az explicit függőségek elvének követését., 3.2.2. SQL Server Express, A Microsoft SQL Server Express[19] LocalDB egy szolgáltatás az SQL Server Express, fejlesztői részére. Az SQL Server Express különleges funkciókkal rendelkezik. A LocalDB, telepítése az SQL Server Database Engine elindításához szükséges minimális fájlkészletet, másolja. A LocalDB telepítése után egy különleges kapcsolati karakterlánc segítségével hozhat, létre kapcsolatot. A kapcsolat létrejötte után automatikusan létrejön a szükséges SQL Server, infrastruktúra, hogy az alkalmazás bonyolult konfigurációs feladatok nélkül tudja alkalmazni az, adatbázist. A Developer Tools egy SQL Server Database Engine-t biztosít a fejlesztők részére, amely lehetővé teszi számukra a Transact SQL kód írását, továbbá tesztelését anélkül, hogy az, SQL Server teljes kiszolgálópéldányát kellene kezelniük., 3.2.3. xUnit Test Project, Az xUnit egy olyan tesztelőeszköz amely a .NET-hez volt fejlesztve és egy ingyenes tesztelési, keretrendszert biztosít a fejlesztőknek. Különböző attribútumokat és módszereket biztosít, amelyek segítségével megirhatóak a tesztkódok az alkalmazáshoz., A fontosabb attribútumok a következők[20]:, ● [Fact] – az attribútum által a tesztfuttató tudni fogja hogy le kell futtassa, ● [Theory] –Az attribútum azt sugallja hogy több paraméter lesz elküldve a tesztelési, kódhoz. Hasonlóan tudatja a tesztfuttatóval hogy le kell futtassa, viszont azt is jelenti, hogy paramétereket fog kapni a teszt metódus., ● [InlineData] – Az attribútum megjelöli azokat a paramétereketamelyeket atesztmetódús, fog megkapni. Ha a [Theory] attribútumot használjuk, akkor az [InlineData]-t is, használnunk kell., 3.2.4. Entity Framework, Az Entity Framework (EF) Core egy könnyű, nyílt forráskódú és platformfüggetlen, változata a híres Entity Framework adatelérési technológiának. Az EF Core objektum-relációs, leképezőként (O/RM) működik. Lehetővé teszi a .NET fejlesztőknek hogy az adatbázissal, dolgozzanak .NET objektumokon keresztül. Megszünteti az adat hozzáférési kódnak, megírásának a szükségességét, mivel ezt automatikusan megoldja[21]., Az EF Core általaz adathozzáférés egymodellenkeresztülfog történni.Eza modeltöbb, entity class-ből és egy kontextus objektumból áll amely kezeli az adatbázishoz szükséges, kommunikációt. A kontextus lehetővé teszi a lekérdezéseket és a módosítások mentését. Az EF, több modell tervezési megközelítést támogat. Megengedi egy már meglévő adatbázishoz, hozzáférve egy modell automatikus generálását. Megirt kódból képes egy modellt generálni, amely megegyezik az adatbázissal. Miután a modell létrejött, képes EF Migrations által, létrehozni egy adatbázist a modellből, továbbá képes változtatni és továbbfejleszteni az, adatbázist, a modellt érő változtatások következtében., Az Entity Framework Core, Language-Integrated Query (LINQ)-t használ az, adatbázisból való lekérdezéshez. A LINQ kompatibilis a C# programozási nyelvvel amelynek, segítségével lekérdezéseket lehet írni. A származtatott kontextus és az entity osztályok, segítségével képes hozzáférni az adatbázisban lévő objektumokhoz. Az EF Core átadja a LINQ, lekérdezés reprezentációját az adatbázis-szolgáltatónak, ami lefordítja adatbázis specifikus, lekérdezési nyelvre. A lekérdezések mindig végrehajtásra kerülnek még abban az esetben is, ha, az eredményben visszaadott entitások már léteznek a kontextusban., Minden kontextus példány rendelkezik egy ChangeTracker-el amely felelős a, változtatások átirásáért az adatbázisban. Ahogy változtatások keletkeznek az entity osztályok, példányaiban, ezek aváltozásokle vannakmentveaChangeTracker-beés megírja aváltozásokat, az adatbázisba a SaveChangesmeghívása után.Azadatbázis-szolgáltató felelősa változtatásokat, lefordítani adatbázis specifikus operációkra(mint például INSERT,UPDATE vagy DELETE, utasításokat a relációs adatbázisra)., 3.2.5. Leaflet, A Leaflet[22] egy vezető nyílt forráskódú Javascript könyvtár, amely interaktív térképpel, kapcsolatos API műveleteket biztosít. Fejlesztése során figyelembe volt véve az egyszerűség, teljesítmény és használhatóság is. Hatékonyan működik,többplatformon is támogatott, valamint, bővíthető további pluginokkal., 3.2.6. OpenStreetMap, Az OpenStreetMap[23] (OSM) egy ingyenes szerkeszthető földrajziadatbázis. Aprojekt, elsődleges eredménye a geoadatokat szolgáló térkép., 4. Rendszer specifikációja, 4.1. Felhasználói követelmények, ● Könnyen kezelhető:, ○ A weboldal megnyitása következtében a funkcionalitások egyből elérhetőek., ○ Az oldalak között egy kattintással lehet navigálni., ○ A paraméterek minden oldalon változtathatóak., ○ Egy gomb nyomásával, az algoritmus újra futtatható a beállított paraméterekkel, ○ A kérésekre megfelelő időn belül választ kap a felhasználó., ● Átlátható:, ○ A weboldal elemei jól látható helyre vannak elhelyezve., ○ A paraméterek minden oldalon szem előtt vannak., ○ A térképet teljes képernyőbe is meg lehet jeleníteni., ○ Futtatáskor a térképen lévő eredmény kerül középpontba., ○ A különböző oldalakra való navigálási elemek egymás mellett helyezkednek el., ● Intuitív:, ○ Minimalista design., ○ Olvasható betűtípus használata., ○ A szem számára kellemes színek használata., ● Lényegre törő:, ○ Kizárólag az algoritmusok kerülnek bemutatásra., ○ Az oldal indításakor már lefut az első algoritmus., ● Szerepkörök a rendszer használatakor:, 4. ábra Use case diagram a felhasználói szerepkörök szemléltetésére, Az alkalmazás fő funkcionalitását és szerepköreit afentlátható usecasediagram mutatja, be (4. ábra). A rendszerben minden felhasználónak megegyezik a jogosultsága, tehát minden, funkcionalitást használhat. Az összes felhasználó megtekintheti az összes oldalt, amelyeken, oldalaktól függően különböző algoritmusok eredményei egy térképen kerülnek bemutatásra., Minden oldalon különböző változtatható paraméterek jelennek meg, amiket a felhasználó, tetszése szerint módosíthat.A módosítások csakakkor jelennekmeg atérképen haezeketelküldi, a rendszernek a “SUBMIT” gomb használatával., 1. Táblázat: Result menete, Use case Result, Use case number user_request_n1, Actor USER, Use case description A felhasználó meg szeretné tekinteni az, eredményt., Preconditions 1. Az alkalmazás fut., 2. A beírt paraméterek helyesek., 3. Az internet elérhető., Basic flow 1. A felhasználó megnyomja a “SUBMIT”, gombot., 2. megvárja ameddig megérkezik az, eredmény., 3. megtekinti a térképen lévő eredményt., Post conditions A beírt paramétereket megjegyzi a rendszer., Alternate flow 1. Nem megfelelő a RDP toleration, 2. Nem megfelelő aDBSCAN euclidean, distance, 3. Nem megfelelő a DBSCAN minimum, core points, 4.2. Rendszer követelmények, 4.2.1. Funkcionális követelmények, 5. ábra rendszer folyamata, A weboldal működése különböző feltételeknek (5. ábra) kell megfelelnie annak, érdekében,hogymegfeleljenafunkcionáliskövetelményeknek.A weboldal indításának kétesete, lehet,amikor jóelérhetőségiútvonal vanmegadvaés problémamentesenbetöltődikakiválasztott, oldal, valamint az amikor hibába ütközik. Abban az esetben amikor hibába ütközik betöltődik, egy másik oldal ahol a hiba van szemléltetve. Amikor a weboldal helyesentöltődik be, akkoraz, egyik felhasználó által kiválasztott oldal fog megjelenni. A betöltést követően az oldal átküldia, program feldolgozó egységének a kérést az automatikusan beállított paraméterekkel. Abban az, esetben amikor a felhasználó változtat a paramétereken, a kérés a megváltoztatott, paraméterekkel fog átmenni. A paraméterek lehetnek helytelenek és helyesek, amennyiben a, paraméterek helytelenek az adott adatmező által egy hiba üzenet jelenik meg. Feltéve, hogy az, adatok helyesek, meghívódnak a kért algoritmusok és elküldi az adatokat a weboldalnak., Előfordulhat hogy az átküldött adatok helytelenek, ebben az esetben a konzolon fog megjelenni, egy hiba üzenet. Abban az esetben, amikor az adatok helyesek ezek megjelennek a térképen., 4.2.2. Nem funkcionális követelmények, ● A algoritmusok C# nyelvben legyenek fejlesztve, ● A rendszer kialakítása kövesse az MVC programtervezési mintát, ● Az algoritmusok 1 perc fussanak le 200000 feldolgozott adat esetén, ● A projekt Microsoft Visual Studio alatt működjön, ● A térkép megjelenítésére OpenStreetMap legyen használva, ● A térképen lévő eredmény kirajzolására Leaflet legyen használva, 5. A rendszer architektúrája, A rendszer működésének a megértéséhez elengedhetetlen a rendszer átfogó, struktúrájának a megértése. A rendszer architektúrája elrejti az összes olyan információt ami, megnehezíti a rendszer értelmezését, vagyis csak a fő komponenseket veszi figyelembe. Ezek, jelentését az 6. ábra szemlélteti:, 6. ábra rendszer architektúra, A járművek útvonalait feldolgozó alkamazás keretein belül találhatóak meg azok az, algoritmusok, melyeknek célja alokálisadatbázisbólkapott feldolgozatlanadatok optimalizálása, és értelmezése, majd pedig továbbküldése a web felületre. A lokális adatbázis kezdetben a, feldolgozatlan adatokat tartalmaza, amelyeket elküldi az alkalmazásnak. Kétoldalú, kommunikáció létezik az adatbázis és az alkalmazás között. Ennek szerepe az, hogy egyes, feldolgozott adatok eltárolhatóak lehessenek, ezzel felgyorsítva a további feldolgozásokat. A, webfelületre olyan adatok lesznekátküldveaz alkalmazásáltalamelyekmárkész megjeleníthető, adatokat tartalmaznak, illetve azalapbeállitások amelyekszükségesek arra,hogyinicializálódjon, a web felület. A felhasználó egy olyan személy, aki tesztelni szeretné az algoritmusokat és meg, szeretné tekinteni ezek eredményeit. A felhasználó a webes felületen keresztül tudja, megtekinteni az eredményeket, és átalakítani az algoritmusok paramétereit, különböző bevitt, adatok által. Amikor változtatás történik a felhasználó által, a webes felület visszaküldi a, változtatott paramétereket és újra feldolgozza ezzel az adatokat, ami követeli a kétoldalú, kommunikációt a webes felület és az alkalmazás között., 5.1. Adatbázis, Az adatbázis Microsoft SQL Server Express (MSSE)általlettmegvalósítva.AzMSSE a, Microsoft SQL Server relációs adatbázis-kezelőrendszerének egyverziója. Egyolyan adatbázist, tartalmaz ami főleg a kisebb méretű alkalmazásokat célozza meg, viszont jelen esetben elegendő., 7. ábra adatbázisban lévő feldolgozatlan adatok tartalma, A 7. ábrán a feldolgozatlan adatok jellemzői láthatóak, ezen adatok felhasználásával, lehetséges az eredmények létrehozása. Az adatok különböző járművek által lettek begyűjtve, amelyek többféle információt küldtek jelenlegi helyzetükről és a helyzetükhöz kapcsolodó, jellemzőkről: sebesség, idő, útvonalhoz tartozás és irány. A feldolgozások során egyes, feldolgozottadatok iselvannaktárolva azadatbázisbaaz újrafelhasználhatóságcéljából. Ezekaz, adatok a klaszterezett pontokat és a klaszterbe tartozó pontokat jelentik, valaminta klaszterezett, pontokhoz tartozó útvonalak ID-ját. Az adatbázis az Entity Framework által lett generálva a, Code-First metódus felhasználásával. Az alkalmazásban létrejön egy kontextus aminek a, segtiségével bárhonnan elérhetőek lesznek az adatbázisban szereplő adatok., 5.2. Alkalmazás, Az alkalmazás a Microsoft VisualStudiofejlesztőkörnyezetben lettmegvalósítva,amely, két projektet tartalmaz. Az UtvonalFeldolgozas nevű projekt egy ASP.NET Core Web, Application ésaModel-View-Controller (MVC)programtervezési mintátköveti. AzMVCminta, miatt az alkalmazás három összetevőcsoportra osztódott: modellek, nézetek és vezérlők. Az, összes felhasználói kérés egy vezérlőhöz kerül. A vezérlő együttműködik a modellel, hogy a, felhasználó által kért műveletek végrehajtódhassanak. A vezérlő kiválasztja a felhasználó által, kért megfelelő nézetet, és megadja a szükséges modell adatokat, hogy ezek megjeleníthetővé, válhassanak a nézet által. Az adatok megjelenítése RazorPage-eksegítségével történik,ami egy, újabb, egyszerűsített webalkalmazás-programozási modell. Az UtvonalFeldolgozas projekt, tesztelésére egy UnitTests nevű xUnit Test Project volt alkalmazva, amely ugyancsakMicrosoft, Visual Studio alatt működik. Az alkalmazás megértése céljából, csak a legfontosabb moduljai, lesznek logikai sorrendben bemutatva., Az UtvonalFeldolgozas projekt tartalmazza az összes olyanprogram résztami szükséges, az alkalmazás működéséhez, valamint a következő NuGet csomagokat használja fel:, EFCore.BulkExtensions-t a nagyméretű adatbázis kérésekre és aNewtonsoft.Json-taz osztályok, JSON-re való átalakításához. Az alkalmazás legfőbbalgoritmusai azoka következőműveleteket, valósítják meg: felesleges pontok törlése vonal egyszerűsítési módszerrel (RDP), pontok, klaszterezése (Cluster), heatmap előállítása átlagsebességből (Heatmap), útvonal ajánlása, Dijkstra algoritmussal (RouteRecommendation) és új útvonal összehasonlítása egy már eltárol, útvonallal (EstimateRoute)., 8. ábra UtvonalFeldolgozas általános folyamata, A 8. ábrán megtekinthető az UtvonalFeldolgozas általános folyamatának a kinézete, amely felülnézetből mutatja a kommunikációt az egységek között. Az adatbázis és a modellek, között létrejön egy kontextus amely ezek közt egy könnyebb átjárhatóságot biztosít. A, modellekben lévő adatok eltárolhatóak az adatbázisba a kontextus által. A logika modulban, történik az adatok feldolgozása és az eredmények előállítása, amelyeket továbbküld a, kontrollernek. A kontroller kommunikál a nézettel és a logika modul által kapott Json fájlokat, átküldi ennek. A nézetben az adatokat értelmeződnek és kirajzolódnak a térképre, ha, módosulnak a paraméterek vagy más oldal töltődik be akkor egy új kérés érkezik a, kontrollernek. Az új kérés értelmeződik a kontroller által és a logika modul által lekéri a, megfelelő eredményt., 9. ábra pont modellek UML osztálydiagramja, A 9. ábrán láthatóak a modellek amelyek a feldolgozás során fel voltak használva, a, LatLngUtc osztály volt alkalmazva a RDP algoritmus demonstrálására. Ebben az osztályban, csak a pontok helyzete és az eltárolási idejük szerepel.A Pointosztályvolt felhasználvaminden, másik algoritmus esetében a feldolgozatlan adatok eltárolására. Ez az osztály több információt, tartalmaz: milyen iránya volt a pontnak, mi a sebessége, milyen útvonalhoz tartozik, milyen, típusú klaszterbe tartozik, mi az előző és az utána következő pont. A ClusteredPoint osztály, szerepe a klaszterezett pontok eltárolása. Ebben az osztályban található: hány pontban volt, megállva a jármű, hány pontban volt sebessége a járműnek, átlagsebessége, átlagideje a, klaszterben, szomszédos klaszter pontjai és milyen pontok tartoznak a klaszterbe. Enneklétezik, egy egyszerűsített verziója is a SimpleClusteredPoint ez a heatmap előállítására lett létrehozva., 10. ábra további modellek UML osztálydiagramja, A 10. ábrán a további felhasznált modellek láthatóak, amelyek nem szerepeltek a 9., ábrán. A LargeMeasurements200k nevű osztályba kerülnek be az adatbázisban lévő, feldolgozatlan adatok. Az ApplicationDbContext egy olyan kontextus aminek a segítségével a, kódból bárhonnan elérhetőek az adatbázisban lévő adatok. A DijsktraRoute osztály a Dijsktra, algoritmus által felhasznált osztály., 11. ábra főprogram egyszerűsített UML osztálydiagramja, A főprogram minden egyes indításkor végrehajtódik és két fontos objektumot tartalmaz, (11. ábra): builder-t és az app-t. Ezen objektumok az ASP.Net Core Web Application beépitett, objektumai. A builder objektum felelős az appfelépítéséért, valamintaszükséges szolgáltatások, beállításáért. A beállított szolgáltatások a következők: adatbázis kontextus hozzáadása, az SQL, szerver elérésének a beállítása, kontrollerek és nézetek hozzáadása. Az adatbázis kontextus, segítségével könnyen elérhetővé válik az összes adatbázis operáció.Azapp egywebalkalmazás, szerepe aHTTP-csővezetékek ésaz útvonalakkonfigurálása.Azappbeállít többköztesszoftvert, a csővezetékhez, ami képes a kivételek észelésére és logolására, illetve a HTTP kérések, átirányítására HTTPS-re. Legvégül az app beállítja a kezdetleges kontrollert és a hozzá tartozó, nézetet ami jelen esetben a RDP oldal lesz, ezt követve pedig elindul., 12. ábra létrehozott kontroller egyszerűsített UML osztálydiagramja, A kontrollereksegítségéveloldható meg akommunikációa modellekésa nézetekközött., Könnyebb átláthatóság céljából a MyController osztály (12. ábra) egy sablonos illusztrációja a, létező kontrollereknek ami megmutatja, hogy mit tartalmaz az alkalmazásban. Az összes, MyController egy már beépített Controller osztályból van származtatva. Található benne egy, konstruktor ahol inicializálódik az adatbázis kontextus és egy destruktorahol ezfelszabadul.Az, Index metódusok felelősek a kiválasztott nézetek visszatérítéséhez. A Get típusú metódusok, kezelik le az adatok szállítását a nézetet kezelő metódusokba. Az Error metódus küldi vissza a, hibát szemléltető nézeteket. A feldolgozatlan adatok beolvasásért és a feldolgozott adatok, átadásáért a MainDistributor (12. ábra) osztály felelős. Megoldja a különböző tipusú adatok, beolvasását, loggerek inicializálását, valamint a fejlesztett algoritmusok (Cluster, RouteRecommendation, RDP, Heatmap, EstimateRoute) megoldásának továbbítását Json, formában., 13. ábra A fő feldolgozó algoritmusok UML osztálydiagramja, A fő feldolgozó algoritmusok a 13. ábrán látható módon kommunikálnak a, MainDistributor (12. ábra) osztállyal. Ezek a metódusok dolgozzák fel az adatokat, ezek közül, egyszerre csak egy hajtódik végre, egy oldal betöltése vagy pedig egy felhasználó általi kérés, következtében., 14. ábra A nézet egyszerűsített UML osztálydiagramja, A 14. ábrán egy sablonos osztálydiagram látható ami szemlélteti a nézetben lévő elemek, kommunikációját. Az Index oldal az amit a felhasználó lát és a LeafletHandler CSS fájlban, találhatóak meg az Index kinézeti beállításai. Az AlgorithmHandler inicializálja a térképet, a, setupMap módszer segitségével ami a Utils osztályban található. Ezt követően a post metódusba, történik meg a kommunikáció a kontrollerekkel és küldődik át az adat. A Show metódus arra, szolgál, hogy a feldolgozott adatot kirajzolja a térképre., 6. Fejlesztett algoritmusok működése, A ProcessDPR (13. ábra) metódus két fontos feldolgozást hajt végre. UTCDateTime (9., ábra) szerint rendezést hajt végre a Point tipusú listán. Ezt követően az RDP algoritmus képes, lesz helyesen átjárni és törölni a felesleges pontokat, majd pedig visszatéríteni ezeket és, továbbküldeni a MainDistributor (12. ábra) osztálynak., A ProcessClusters (13. ábra) metódus felhasználja az előbb magyarázott ProcessDPR, metódust és ennek az eredményét dolgozza tovább fel. az optimalizált pontokat klaszterezi a, DBSCAN algoritmus segítségével. A klaszterezési folyamat két részből áll. Először létrejönnek, azok a listák amelyek tartalmazzák az egymáshoz közel lévő pontokat és egy külön listában a, zajos pontokat. Abban az esetben amikor a zajos pontok is fel vannak használva ezek egytagú, klaszterekként lesznek értelmezve. Ezt követően egy algoritmusminden csoportbólkiválasztjaa, klaszter közepéhez legközelebbi pontot ésahhoz rendeliaklaszterösszes többipontját,valamint, kiszámitja minden klaszternek az átlagsebességét, átlagidejét. Az így feldolgozott klaszter, pontok pedig tovább lesznek küldve a MainDistributor osztálynak., A ProcessHeatmap (13. ábra) először felhasználja a ProcessDPR-t, hogy megkapja az, optimalizált pontokat, majd pedig beállítja minden pontnak, hogy milyen pont van előtte és, milyen pont következik utána. Ezt követően végrehajta a klaszterezési metódust amely, kigenerálja a klaszter pontokat. Megkeresi az összes klaszter pont közötti kapcsolatot így, szomszédos klasztereketfog eltárolni minden egyes klaszterpontesetén.Kiépít egyolyan tuple-t, tartalmazó listát amelyben minden klaszter pont közötti kapcsolat megtalálható és ezt, továbbküldi a MainDistributor osztálynak., A ProcessEstimatingTrack (13. ábra) először lekéri az adatbázisból az összes útvonal, ID-ját ami egy pontrendszer kiépítéséhez lesz szükséges. Ezt követően végrehajtja a, ProcessClusters metódust így megkapva a klaszterett pontokat. Bekéri az új útvonalat amelyre, meg kell találja a leghasonlóbb útvonalat az adatbázisból. Kiépít egy KdTree adatstruktúrát a, klaszterezett pontokból, amely a legközelebbi szomszédok megkeresését fogja felgyorsítani. Az, útvonal pontjait megpróbálja hozzárendelni a hozzá legközelebb álló klaszterhez, ha sikeresen, megtalálta a klasztert akkor hozzárendeli és eltárolja az összes olyan útvonal ID-t amelyekhez, tartoznak a klaszter pontjai, így kialakítva egy pontrendszert. A pontrendszer felhasználásával, kiválasztódnak a hasonló útvonalak. Az összes hasonló útvonal összehasonlításra kerül az új, útvonallal, amelyiknél a DTW távolság a legkisebb lesz, kiválasztódik. Az összegyűjtött adatok, és a nyertes útvonal tovább lesz küldve a MainDistributor osztálynak., A ProcessRouteRecommendation (13. ábra) felhasználja a ProcessDPR metódust, hogy, átvegye az optimalizált pontokat, majd pedig az összes pont esetében az előtte és utána lévő, pontok eltárolódnak. Következőleg végrehajtódik a klaszterezési metódus így megkapva a, klaszterezett pontokat. Az összes klaszter ponthoz hozzárendelődnek a szomszédos klaszter, pontok. Felépül a szomszédsági mátrix a klaszter pontokból. Ezt követően pedig a létrejött, szomszédsági mátrixot felhasználva a Dijsktra algoritmus kigenerálja a legrövidebb útvonalakat, egy klaszter pontból kiindulva az összes többi klaszter pontig. Két kiválasztott klaszter pont, közötti legrövidebb útvonal pedig továbbítva lesz a MainDistributor osztálynak., 7. Felhasználói felület, 15. ábra RDP oldal, A felhasználói felületen több oldal között lehet navigálni. Az egyik ilyen oldal az a RDP, oldal (15. ábra), ezen az oldalon egy paraméter bevitele lehetséges és ez pedig a RDP toleration., A paraméter bevitele egy adatmezőben történik, ez alatt található egy Submit gomb, amely a, paraméter változtatásokat szinkronizálja az eredménnyel. A RDP oldalon még megtekinthető a, térkép és a kirajzolandó eredmény. A Travel Speed csúszkával állítható a kirajzolás sebessége, valamint a Follow jelölőnégyzettel beállítható ennek követése. A térkép nagyítható és teljes, képernyős módban is megtekinthető. A navigáció a legfelső panelben elhelyezkedő elemek, kattintásával történik., 16. ábra Cluster oldal, A 16. ábrán látható felhasználói felületen négy paraméter bevitele lehetséges, adatmezőkön keresztül és egy jelölőnézgyzettel. A Submit gomb szinkronizálja a paraméter, változtatásokat az eredménnyel. A térképen pedig egy interraktálható statikus eredmény, található., A további oldalak (EstimateTrack, Heatmap, Route Recommendation) kinézete és, funkcionalitásai megegyeznek a Cluster oldalon láthatóakkal., 8. Mérések és eredmények, Az algoritmusok bemutatási sorrendjét az fogja meghatározni, hogy milyen fontos, alkotóelem a további algoritmusok számára és az, hogy ezek milyen sorrendbe lettek, implementálva a rendszerbe. Egyes eredmények bemutatása összehasonlításialapon fogtörténni, más hasonló alkalmazások eredményeivel, hogy bizonyítható lehessen ezek helyessége., Az RDP algoritmus kulcsfontosságúaz összestöbbi algoritmusszámára,mivelkiszűriaz, összes felesleges pontot az útvonalak halmazából. Ennek helyessége abban bizonyosul meg, hogy a feldolgozatlanútvonalak formájátmegtartvaképes legyen előállítaniegyhasonló formájú, útvonalat, amely nem távolít el egy átmeneti pontot sem. Az átmeneti pontok az útvonalakat, alkotó kanyarokat jelentik., Az algoritmusok által feldolgozott adatok az ECOMOTIVEáltal voltakbiztosítva, amely, egy jármű összes útvonalát tartalmazza. Az adathalmazban lévő pontok az éleskanyarokszerint, lettek gyakrabban tárolva. Az útvonal pontokként, időrendi sorrendbe való megjelenítése pedig, az alábbi ábrán látható:, 17. ábra az RDP algoritmus előtti feldolgozatlan útvonalak, A 17. ábrán észrevehető, hogy az adatok tartalmaznak helytelen pontokat is, ezeket a, GPS jelvesztése eredményezte, ebben az esetben a pont helyzete (0,0)-rá állítódik. Továbbá, megfigyelhető, hogy az adatok nagy része helyes, és fontos információkat tartalmazhat. Ezek, feldolgozása az RDP algoritmus által az alábbi ábrán tekinthető meg:, 18. ábra az RDP algoritmus által feldolgozott útvonalak, A 18. ábrán látható, hogy afeldolgozott útvonalakformájateljes mértékben megegyezik, az eredeti útvonalak formájával. Az algoritmus 0.0001-es tolerációs mértékkel 199,905 pontból, sikeresen eltávolított 143,802-at, ami a pontok 71.93%-át jelenti. A pontok mennyiségbeli, különbsége így nem teljesen látható, ezért egy konkrét útvonal kerül bemutatásra:, 19. ábra RDP algoritmus előtti feldolgozatlan útvonal, A 19. ábrán a kék vonal mentén lévő zöld pontok által határozódik meg az útvonal, formája. Az összeköttetés a pontok között időbeli sorrendben lett megvalósítva. Látható, hogy, minden kanyarban több pont található és nem mind szükséges ahhoz, hogy az útvonal formája, megmaradjon. Ennek az RDP algoritmus által feldolgozott formája a 20. ábrán látható:, 20. ábra az RDP algoritmus által feldolgozott útvonal, A 20. ábrán már tisztán látható, hogy az összes olyan pont amely nem járult kritikusan, hozzá az útvonal formáját alkotó pontokhoz, el lett törölve. A zöld pontok rendszerint a, kanyarokba csoportosultak. A következőkben ezen feldolgozott pontok, DBSCAN általi, klaszterezés eredménye lesz bemutatva:, 21. ábra feldolgozott útvonalak pontjainak a klaszterezése a DBSCAN algoritmus által, A 21. ábrán a létrejött klaszter pontok egy része tekinthető meg,ezek a20.ábránlátható, hasonló zöld pontok összességéből jöttek létre. 56103 pontból létrejött 1767 klaszter, a, következő paraméterekkel: 0.01-E07 DBSCANeuklideszi távolsággalés 3DBSCANminimum, ponttal, valamint zaj pontok nélkül., 22. ábra DBSCAN által létrejött klaszter pontok és ezek típusa, A 22. ábrán 3 féle pont különböztethető meg: nagyméretű kék és piros klaszter pontok, valamint a kis méretű piros pontok. A nagyméretű kék színű klaszter pontok azt jelölik, hogy, abban a klaszterben a járművek leggyakrabban mozgásban voltak, a nagyméretű piros színű, klaszter pontok pedig ennek az ellenkezőjét. A kis piros pontok pedig a nagyméretű piros vagy, kék klaszter pontok halmazába tartoznak és egy rózsaszín vonallal vannak ezekhez kötve., 23. ábra DBSCAN által létrejött klaszter pontok információi, Az összes klaszter pont statisztikai információt tartalmaz (23. ábra) a hozzá tartozó, pontok összeségéről. Ezek az adatok a következők : klaszter pont koordinátája, hányszor volt a, jármű mozgásban és hányszor volt a sebessége nulla, a jármű átlag sebességét, átlagosan mikor, haladt át a ponton, hány különböző útvonal tartozik a klaszterbe, hanyadik kirajzolt klaszter a, térképen és hogy hány pontot tartalmaz a klaszter., 24. ábra az eltárolt útvonalak közüli leghasonlóbb útvonal keresése, A klaszterezett pontok és a DTW távolság által lehetővé vált egy teljesen új útvonal, összehasonlítása egy már adatbázisból meglévő leghasonlóbb útvonal összehasonlításával., Ennek eredménye a 24. ábrán lett szemléltetve. Az eredmény megértése céljából az ábra több, kisebb szegmensként lesz tárgyalva. A kisebb kékkel kitöltött kör (24a. ábra) mutatja az új, útvonal klaszterbe besorolható kezdőpontját, valamint a kisebb lilával kitöltött kör (24d. ábra), ennek a végpontját. Látható egy nagyobb kék kör (24b. ábra) is, amely a már meglévő, leghasonlóbb útvonalnak a kezdőpontját jelenti, továbbá egy nagyobb lila kör (24d. ábra) ami, ennek a végpontját jelenti. Az útvonal menetét és formáját a körök közötti vonalak ábrázolják, ezek három színben jelennek meg: zöld, szürke és piros. A zöld vonalak az új útvonal és a, meglévő útvonal közti hasonlóságot illusztrálják,valamint apirosvonalak ennekellenkezőjét.A, szürke vonalak a már meglévő útvonal pontjait kötik össze.A zölddelkitöltöttkörök (24c.ábra), azt jelentik, hogy az új útvonal pontjait sikerült besorolni egy már létező klaszterbe, a kisebb, piros körök (24e. ábra) ennek ellenkezőjét szemléltetik.A szürkekörök mutatjáka mármeglévő, útvonal pontjait. Az új útvonal pontjait ha nem sikerül klaszterbe sorolni akkor egy piros, körként(24f. ábra) jelenik meg. A két útvonal közötti DTW távolság az 3.698E-05és 2egymás, melletti útvonalat talált az EstimateTrack algoritmus a leghasonlóbbnak., 25. ábra heatmap a klaszterek közötti átlagsebességről, Az eddigi feldolgozásoknak köszönhetően egy heatmap előállítása is létrejöhetett (25., ábra). Ezen a heatmap-en 4 féle szín különböztethető meg: piros,narancssárga,sárgaés zöld.A, piros színnel jelölt útszakaszokon haladnak a legkisebb átlagsebességgel a járművek, majd a, narancssárga, sárga és zöld színű útvonalak egyre nagyobb értéket ábrázolnak., 26. ábra létrehozott heatmap összehasonlítása a Google Maps forgalmi térképével, Az adatok hiányában nehéz pontos eredményt szolgáltatni, viszont összehasonlítás, céljából mindkét térképen (26. ábra) kiszűrhető, hogy a városból kifelé haladva felszabadul a, forgalom és nagyobb sebességgel lehet haladni., 27. ábra két pont közötti legrövidebb útvonal, A szomszédsági mátrix létrehozásával a klaszter pontok között és a Dijkstra algoritmus, felhasználásával egy sikeres útvonajánlás megvalósítása látható. A 27. ábra két pont közötti, legrövidebb útvonal van szemléltetve, ahol a klaszter pontok között haladva rajzolja ezt ki a, program., 28. ábra két pont közötti legrövidebb útvonal a Google Maps-et használva, Ellenőrzésképpen a 28. ábrán lévő START és END pont közötti legrövidebb útvonalat a, Google Maps által szolgáltatott eredménnyel (17. ábra) is összehasonlítottam. A 2 ábrán (27., ábra és 28.ábra) lévő legrövidebb útvonal nagy mértékben megegyezik ami azt jelenti, hogy, helyesen működik a fejlesztett algoritmus., 29. ábra xUnit RDP teszt, A 29. ábrán a RDP algoritmus tesztelési eredményei láthatóak. A RDP algoritmus által, használt távolságok és különböző paramatérre való kimeneteinek a helyessége került tesztelésre., 8.1. Statisztikai adatok, A fontosabb algoritmusok futási eredménye és statisztikailag fontosabb eredményei az, alábbi táblázatokban kerülnek bemutatásra, ahol az “s” a másodpercet jelöli:, 2. Táblázat: feldolgozatlan adatok adatbázisból való kiolvasása, Pontok száma Első teszt Második teszt Harmadik teszt Átlagidő(s), ideje(s) ideje(s) ideje(s), 50000 1.067 1.041 1.040 1.049, 100000 1.092 1.062 1.064 1.072, 150000 1.183 1.099 1.171 1.151, 199905 1.153 1.176 1.135 1.154, A 2. táblázat szemlélteti a feldolgozatlan adatok beolvasásának az idejét az adatbázisból, különböző számú pontok esetében. A pontok számának a növekedése nem befolyásolja, nagymértékben a lefutási időt., 3. Táblázat: feldolgozatlan adatok idő szerinti rendezése, Pontok száma Első teszt ideje Második teszt Harmadik teszt Átlagidő(s), (s) ideje (s) ideje(s), 50000 0.013 0.012 0.012 0.012, 100000 0.028 0.029 0.026 0.027, 150000 0.039 0.041 0.037 0.039, 199905 0.052 0.056 0.058 0.055, A 3. táblázat a feldolgozatlan adatok idő szerinti rendezésének az idejét mutatja, különböző számú pontok esetében,amelyszükséges azRDPalgoritmusműködéséhez. A pontok, időrendbeli rendezése egy elhanyagolhatatlan előfeldolgozás az RDP algoritmus számára, amelynek lefutási ideje kevesebb kell legyen mint az RDP algoritmusnak., 4. Táblázat: feldolgozatlan adatok optimalizálása RDP algoritmus által, Pontok Első teszt Második Harmadik Átlagidő Törölt Végső, száma ideje teszt ideje teszt ideje (s) pontok pontok, (s) (s) (s) száma száma, (%), 50000 0.070 0.068 0.071 0.069 59.93% 20037, 100000 0.108 0.134 0.128 0.123 69.85% 30152, 150000 0.151 0.172 0.132 0.151 73.86% 39213, 199905 0.246 0.271 0.263 0.260 71.94% 56103, A 4. táblázaton látható az RDP algoritmus futási ideje, a feldolgozás alatt eltávolított, pontok mennyisége százalékos formában, valamint az algoritmus által visszatérített ponthalmaz, nagysága különböző számú pontok esetében. A legjobb eredményt 150000 pont esetén sikerült, elérni, mivel abban a ponthalmazban volt a legtöbb elhanyagolható pont. 199905 pont esetén, több irányváltozás volt jelen a pontok növekedése mellett ezért a törölt pontok számának a, százaléka is csökkent az előzőhöz képest. Az algoritmus a következő paraméterrel volt, használva, amivel a kanyarokat helyesen felismerte és megtartotta:, ● RDP toleráció = 0.0001, 5. Táblázat: optimalizált adatok klaszterezése DBSCAN által, Pontok Első teszt Második Harmadik Átlagidő Klaszterek, száma ideje teszt ideje teszt ideje (s) száma, (s) (s) (s), 50000 0.800 0.833 0.790 0.807 1492, 100000 3.933 4.007 3.824 3.921 1919, 150000 7.176 7.262 7.176 7.204 2289, 199905 8.111 7.928 8.163 8.067 3878, A 5. táblázaton megtalálható a DBSCAN algoritmus futási ideje, valamintaz algoritmus, által visszatérített klaszterek száma különböző számú pontok esetében. 50000 és 100000 pont, klaszterezésének az átlagideje sokkal alacsonyabb, mint a többi ponthalmaznak. Ennek oka az, hogy sok a közös kanyar, ezért gyorsabban tud futni az algoritmus. A pontok növekedésével az, algoritmus ideje növekvő tendenciát mutat Az algoritmus a következő paraméterekkel volt, használva:, ● DBSCAN minimum pontok =3,ez aminimumpontszám amellyela klaszterezési, algoritmus még helyesen működhet., ● DBSCAN euklideszi távolság = 0.000000001, klaszterek elemei közötti, legoptimálisabb távolság, hogy ne értelmezzen az algoritmus két közeli kanyart, egy kanyarnak., ● DBSCAN zaj = hamis, ebben az esetben nem kerülnek be azoka klaszterpontok, amelyek nem voltak kanyarnak észlelve., 6. Táblázat:információ összegyűjtése a klaszterezett adatokból, Klaszter pontok Első teszt Második teszt Harmadik teszt Átlagidő(s), száma ideje(s) ideje(s) ideje(s), 1492 0.101 0.045 0.101 0.082, 1919 0.447 0.229 0.452 0.376, 2289 1.124 0.856 1.254 1.078, 3878 3.062 2.921 3.139 3.040, A 6. táblázat a klaszter pontokról való információgyűjtést szemlélteti különböző számú, klaszter esetében. 3878 pont esetén láthatóan megnövekedik a lefutási idő, ez azt jelenti hogy, több pont tartozik egyes klaszterekbe., 7. Táblázat: szomszédsági mátrix felépítése, Klaszter pontok Első teszt Második teszt Harmadik teszt Átlagidő(s), száma ideje(s) ideje(s) ideje(s), 1492 0.002 0.004 0.003 0.003, 1919 0.007 0.005 0.006 0.006, 2289 0.007 0.007 0.006 0.006, 3878 0.010 0.009 0.008 0.009, A 7. táblázat a szomszédsági mátrix felépítésének az idejétmutatja be,különbözőszámú, klaszter esetében. A Dijkstra algoritmusnak szüksége van egy szomszédsági mátrixra amely, láthatóan gyorsan létre tud jönni., 8. Táblázat: Dijkstra algoritmus, Klaszter pontok Első teszt Második teszt Harmadik teszt Átlagidő(s), száma ideje(s) ideje(s) ideje(s), 1492 0.006 0.005 0.005 0.005, 1919 0.012 0.012 0.011 0.012, 2289 0.022 0.018 0.019 0.019, 3878 0.032 0.033 0.034 0.033, A 8. táblázat bemutatjaa Dijkstraalgoritmusfutási idejétkülönbözőpontok esetében.Az, algoritmus egy kiválasztott klaszter pontból kiindulva gyorsan megtudja találni az összes többi, klaszter ponthoz vezető legrövidebb útvonalat., 9. Táblázat: Heatmap kigenerálása, Pontok száma Első teszt Második teszt Harmadik teszt Átlagidő(s), ideje(s) ideje(s) ideje(s), 50000 1.087 1.117 1.104 1.102, 100000 1.870 1.936 1.890 1.898, 150000 2.803 2.929 2.861 2.864, 199905 6.17 6.232 6.101 6.116, A 9. táblázaton látható a Heatmap kigenerálásának az ideje különböző pontok esetében., A Heatmap generálásához szükséges a szomszédsági mátrix létrejövetele, mivel ezen klaszter, pontok közötti reláció lesz szemléltetve, ami jelen esetben az átlagsebesség. A lefutási ideje, növekszik a pontok számával. A legnagyobb ponthalmaz esetén lassúvá válik az algoritmus, ez, azt jelenti hogy több helyes klaszterpont jött létre., 10. Táblázat: EstimateTrack algoritmus, Pontok száma Első teszt Második teszt Harmadik teszt Átlagidő(s), ideje(s) ideje(s) ideje(s), 50000 1.561 1.589 1.601 1.583, 100000 2.832 2.756 2.688 2.758, 150000 3.831 3.857 3.793 3.827, 199905 4.959 4.869 4.979 4.935, A 10. táblázaton megtekinthető az EstimateTrack algoritmus futási ideje különböző, pontok esetében. Két útvonal közötti hasonlóság megállapításához szükséges a leghasonlóbb, útvonalak rangsorolása, jelenleg ez az ötven leghasonlóbb útvonalat jelenti. Továbbá a, leghasonlóbb útvonalak közül ki kell választani csatolásokkal együtt, hogy melyik útvonalnak, lesz a legkisebb a DTW távolsága ami a leghasonlóbb útvonalat fogjajelenteni,ennek alefutási, ideje látható a 10. táblázaton, ahol a pontok számának a növekedésével egyre lassabb lesz a, lefutási idő., 9. Következtetések, 9.1. Megvalósítások, ● Feldolgozatlan pontok beolvasása alokálisadatbázisból,ami maximálisan200000pontot, jelent., ● Feldolgozatlan adatok RDP algoritmussal való optimalizálása. 0.0001 RDP tolerációval, 150000 pontnak a redukálása 73.86%-al., ● Az RDP által optimalizált pontok klaszterezése DBSCAN szerint és statisztikai adatok, gyűjtése minden klaszterpontba. 199905 pontból 3878 helyes kanyar megkeresése., ● A klaszterezett pontok felhasználásával útvonalhasonlitást végezniegyadatbázisbanlévő, útvonal és egy új útvonal közt a DTW távolság kiszámitásával, ahol az 50 leghasonlóbb, útszakaszból lett rangsorolva a leghasonlóbb útvonal., ● A klaszterezett pontok közötti szomszédok megkeresése, ami átjárhatóságot biztosít az, egész ponthamazon., ● A klaszterezett pontok és a köztük lévő kapcsolatok felhasználásával heatmeap-et, előállítani átlagsebesség szerint., ● A klaszterezett pontok közti szomszédsági mátrix felépitésével legrövidebb útvonalat, generálni a Dijkstra algoritmus felhasználásával., ● Az eredmények megjelenítése Leaflet és OpenStreetMap segitségével., ● Az algoritmusok számára megfelelő és gyorsan tesztelhető felhasználói felület, létrehozása., ● A dolgozat egy kezdetleges formája [24] bemutatásra került a XXI. Kari Tudományos, Diákköri Konferencia keretein belül., 9.2. Továbbfejlesztési lehetőségek, A létrehozott alkalmazásban még sok hiányosság található, az adatbázis csakegy lokális, adatbázis ami miatt nem futtatható az alkalmazás bárhonnan és ez egy nagy korlátot jelent. A, felhasznált algoritmusok még tovább optimalizálhatóak, cserélhetőek annak érdekében, hogy, még pontosabb eredmények jöhessen létre. A frontend hibakezelése tovább fejleszthető, mivel, nem erre volt fektetve a legnagyobb hangsúly. Sokkal több tesztelésre van szükség annak, érdekében, hogyminélkevesebb hibajöhessenlétre. Azalgoritmusokgyorsasága nagyonfontos, ezért a párhuzamosság bevezetése is elengedhetetlen a legnagyobb gyorsaság elérése céljából., Az eredmények megjelenítése nem mindenhol teljesen egyértelmű, ezért ezen részét is tovább, kell fejleszteni. Nagyobb mennyiségű adat feldolgozásához további optimalizálási módszerekre, van szükség., 10. Irodalomjegyzék, [1] Liangbin, Z., Shi, G., 2018. A method for simplifying ship trajectory based on improved, Douglas–Peucker algorithm. In: Ocean Engineering, 166, pp. 37-46, ISSN, 0029-8018,(https://www.sciencedirect.com/science/article/pii/S0029801818314872), [2] Hartigan, J.A., Manchek, A. W., 1979, Algorithm AS136:A k-means clusteringalgorithm., Journal of the royal statistical society. series c (applied statistics), pp. 100-108., [3] Ester, M., Kriegel, H.P., Sander, J. and Xu, X., 1996, August. A density-basedalgorithm for, discovering clusters in large spatial databases with noise. In: kdd, 96(34), pp. 226-231., [4] K. Mahesh Kumar, A. Rama Mohan Reddy, 2016, A fast DBSCAN clustering algorithm by, accelerating neighbour searching using Groups method. In: Pattern Recognition, 58, pp 39-48, ISSN 0031-3203, https://doi.org/10.1016/j.patcog.2016.03.008., [5] Google Maps Platform Roads API Documentation, https://developers.google.com/maps/documentation/roads/overview Hozzáférve: 2021.08.14., [6] Newman, M. E. J., 2004, Analysis of weighted networks. In: Physical review E. American, Physical Society, 70(5), pp. 056131., [7] Fan, D., Shi, P., 2010, Improvement of Dijkstra's algorithm and its application in route, planning. In: 2010 Seventh International Conference on Fuzzy Systems and Knowledge, Discovery, 4, pp. 1901–1904., [8] Senin, P., 2008. Dynamic time warping algorithm review. In: Information and Computer, Science Department University of Hawaii at Manoa Honolulu, USA, 855(1-23), pp. 40., [9] OSRM OpenSourceRoutingMachine.ModernC++ routing engine for shortest paths inroad, networks. http://project-osrm.org Hozzáférve: 2021.08.17., [10] OptimoRoute plans and optimizes routes and schedules for delivery and field service, businesses.https://www.linkedin.com/company/optimo-route.Hozzáférve: 2022.04.08., [11] http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker algorithm. Hozzáférve: 2022.03.16., [12] Input curve, specified stages of the Ramer–Douglas–Peucker algorithm, output curve with, reduced number of points., https://www.researchgate.net/figure/Input-curve-specified-stages-of-the-Ramer-Douglas-Peucker, -algorithm-output-curve-with_fig1_236024099. Hozzáférve: 2022.03.16, [13]Ester, M., Kriegel, H.P., Sander, J. and Xu, X., 1996. A density-based algorithm for, discovering clusters in large spatial databases with noise. In kdd, 96(34), pp. 226-231., [14] Density-based spatial clustering of applications with noise (DBSCAN)., https://en.wikipedia.org/wiki/DBSCAN. Hozzáférve:2022.02.18, [15] Alizadeh, E., 2020, An Illustrative Introduction to Dynamic Time Warping. In: Towards, Data Science. Hozzáférve: 2022.03.20, [16] CS3 Data Structures & Algorithms CHAPTER 15 ADVANCED DATA STRUCTURES., https://opendsa-server.cs.vt.edu/ODSA/Books/CS3/html/KDtree.html#kdexamp.Hozzáférve:",
        "year": "2022",
        "abstract": "In recent years, there has been a rapid increase in demand for vehicles equipped with\nGPS. As it becomes an increasing priority for people to get from one point to another as\nsmoothly aspossible, it can bebeneficialto beable tofilter outthe busierroad sections.It canbe\nhelpful for the vehicle owner to know as much retrievable information about the vehicle as\npossible based on the route taken.\nThe aim of the dissertation is to process the routes of the vehicles in such a way that\nconclusions can be drawn from them, withthe helpof whichrelevant data(averagespeed, curve\ncoordinates) can be filtered out. The available data set is made up of different data (coordinate,\nspeed, consumption, direction). The developed algorithm can be used to reduce the data set\nwithout losing statistically important data.\nThe most important data contains the coordinates that result in a route change. The\nsolution is able to detect bendsfrom whichitcan generate significantstatistics(averagespeed in\na curve). As a result, it is able to compare different routes and suggest new ones.\nThe development takes placeinASP.NET CoreWebApp andis testedinxUnit, inwhich\nmap elements are displayed using Leaflet and OpenStreetMap.",
        "keywords": [
            "data set",
            "statistics",
            "path"
        ],
        "hash_code": 7265195548,
        "department": "cs"
    },
    {
        "author": "Salló Csaba",
        "supervisor": "Ș.l.dr.ing Turos László-Zsolt",
        "year": "2024",
        "abstract": "The thesis presentsthe completedesign andimplementation ofanIoT sensorsystem.The\nsystem consists of custom ESP32-based hardware, an Arduino framework loaded onto the\nhardware,a Node.jsserverapplication, andaReact-based webapplication.\nThe server application, installed on a Linux server, is accessible from external networks\nand achieves real-time communication using MQTT and Socket.IO protocols. The server also\nprovides thedatabaseand GoogleHomeintegration.\nThe hardware, along with the Arduino application, allows thehardware toconnecttothe\ninternet, communicate with the server via the MQTT protocol, and execute commands received\nfrom the server. Through its exposed pins, various sensors can be connected to the device.\nAdditionally, with a third-party device containing a USB-UART converter, we can upload new\nfirmwares or even logging on serial communication. In configuration mode, the device allows\nsetting connectiondetailswithout flashing.\nThe React-based web application provides a responsive and user-friendly interface for\nusers. Within the web application, hardware can be dynamically added to the user, and sensors\ncan be attached or removed from the hardware. Through the web application, the hardware\nfirmware canbeupdated usingthe OTAmechanism, andthe hardwarelogs canbemonitored.\nOne of the most important features of the system is that the data is only transmitted\nthrough the private server, as long as the devices are not added to Google Home, which is not\nmandatory.",
        "keywords": [
            "IoT",
            "ESP32",
            "ArduinoApp",
            "ServerApp",
            "WebApp"
        ],
        "hash_code": 5305230960,
        "department": "cs"
    },
    {
        "author": "Simó Zsuzsa",
        "supervisor": "dr. Losonczi Lajos, 1",
        "year": "2021",
        "abstract": "",
        "keywords": [
            "ventilator",
            "remote controlled",
            "embedded microcontroller",
            "breath control",
            "user interface Due to the lung damage caused by the epidemics",
            "the need for high-efficiency",
            "mobile ventilators that isolate operating personnel from the patient is growing worldwide.Theaim is to develop a complementary system for remote patient monitoring and controlling which can act fully as a noninvasiveartificial respiration assistantthatrepresents anewapproachin thefieldof mechanical ventilators. We have combined a completely new concept ventilation mechanism with a modern ESP32 microcontroller-based control systemandaprogram installed onamobile graphical user interface that allows these machines to be easily carried",
            "operated andcontrolled",
            "while also providing closed-loop breath control. Two-way",
            "remote monitoring andcontrolbased on Internet of Things (IoT) technology allows an authorized physician connected to a wireless network to monitor respiratoryparameters andadjustsettings inrealtime",
            "trackmultiple patients simultaneously",
            "or even make clinical decisions",
            "without having to come into direct contactwith the device or the patient. The parameters controlled and regulated by our machine",
            "as well as their minimum and maximum limits",
            "comply with the RMVS00"
        ],
        "hash_code": 7095831972,
        "department": "cs"
    },
    {
        "author": "Tamás Solyom Botond-Őrs",
        "supervisor": "Ș.l. dr. ing. Vajda",
        "year": "2021",
        "abstract": "My license thesis aim is to realize an application, which is able to save my appointments,\nback to a specific time limit. In our days the concept of security it becomes more and more\nimportant in every area of our life, therefore the preservation of this, takes precedence keeping our\nhuman life.\nThe acceleration of the world, involves the increase of meetings and contacts between\npeople and the regular formation of this. An exponential increase of these contacts resulting from\nthese meetings becomes a defining motive of our accelerated world. Unfortunately, in some cases\nit creates a negative effect in our lives, it can prevent the opportunity of preserving the security.\nThe frequently encounters, the multitude of contacts between people, in some cases can be a threat\nto our heath and the safety of our material assets.\nDuring the creation of my license thesis, my goal was the implementation of an application\nwhich, with the help of Bluetooth technology, can follow where and with whom we meet and\npursues a certain time limit, which we are spending with a certain person. If it is necessary warns\nthe users about a potential contact that could pose a danger of their safety.\nThe application was successfully implemented in the Android development environment,\nwith the help of Bluetooth technology integrated in the smartphones.\nAs a result, we get a phone application running on an Android operating system which can\nbe used in case of pandemic, or in any case when is required the contact research, but it can also\nbe used even for personal reason for the tracking of our own movements and meetings.",
        "keywords": [
            "contact researcher",
            "Bluetooth",
            "Android",
            "safety"
        ],
        "hash_code": 7066234017,
        "department": "cs"
    },
    {
        "author": "Soós Izabella",
        "supervisor": "Conf. dr. ing. Bakó László",
        "year": "2023",
        "abstract": "In human life, one of the most important and valuable things is time. In today's fast-paced\nworld, events have become so accelerated that it is truly challenging to keep them under control\nand manage our time effectively. To save time, numerous smart devices and systems have\nemerged, making people's lives easier. We can even say that we are living in the era of smart\nsystems.\nMy thesis’ topic encompasses such a system. It helps us not only to save time, but also\nrelieves us from a responsibility. This modern and innovative solution allows us to take care of\nour plants in the best possible way while minimizing the tasks of plant care and maximizing the\nhealth and beauty of our flowers. It assists in maintaining the plants in optimal condition, especially\nwhen we are not at home or don't have enough time for their care. The system's sensors and\ncontrollers monitor the environmental parameters of the plants, such as temperature, humidity,\nlight intensity, and their watering needs.\nThe smart flowerpot system automatically regulates watering, ensuring that the plants\nalways receive the right amount of water at the right time. We no longer need to worry about\noverwatering or underwatering, as the system takes precise care of watering our flowers.\nThrough an interactive and user interface, we can easily set the watering schedule, monitor\nthe plants' condition, and track the environmental parameters. Whether we are at home or away,\nthe system allows remote access, enabling us to stay connected with our flowers and intervene\nwhen necessary.\nFor the control of the system, I have used an ESP32 microcontroller. The ESP32 is an\nextremely versatile and powerful platform that enables full control and monitoring of my smart\nflowerpot system.",
        "keywords": [
            "user interface",
            "smart system",
            "microprocessor"
        ],
        "hash_code": 7474381893,
        "department": "cs"
    },
    {
        "author": "universitar Szakáli-Vándor Árpád",
        "supervisor": "Dr. Márton Gyöngyvér lector",
        "year": "2024",
        "abstract": "The thesis deals with the dynamic data uploading of web applications. The goal of the project\nwas to create a portfolio page that uses modern technologies and is therefore easy to use,\nresponsive and dynamic at the same time. The development was made in the Vue.js framework\nand Typescript language, the backend tasks are provided by Firebase, mainly through the\nFirestore database. This allows administrators to modify the various contents of the website\nwithout basic programming knowledge.\nThe website can be divided into several parts: the main page contains the presentation of the\nworks, the introduction, the description of the services, and the contact information.\nAdministrators can dynamically change data using various pre-made templates. The website is\nresponsive, so it is easy to use and transparent on desktop computers, tablets and smartphones.\nIn the documentation, I tried to present the technological background in sufficient detail, such\nas Firebase Hosting and the security measures that guarantee data protection.\nThe main goal of the project is to demonstrate how to easily and efficiently create and manage\na dynamic website using modern software development tools. The finished website was named\n\"DynaCraftHub\", which refers to the possibility of dynamic data upload, and is of course\naccessible through Firebase services.",
        "keywords": [
            "dynamic data upload",
            "responsive design",
            "Firebase",
            "user experience"
        ],
        "hash_code": 5334988697,
        "department": "cs"
    },
    {
        "author": "Zoltán Szalma Tamás-Zsolt",
        "supervisor": "Ș.l.dr.ing. Szántó",
        "year": "2022",
        "abstract": "In today’s world, websites have to meet more and more expectations, serving an increasing\nnumber of users is one of the most important aspects of modern websites. A page may be\nbrowsed by 100 people in one minute and increase to 100,000 in the next minute. A modern\nwebsite needs to sense this and increase or decrease the resources allocated, depending on the\nload.\nThe dissertation presents a scalable web application based onKubernetes,during the creationof\nwhich I created a webshop, and then I containerized it and deployed it to a local Kubernetes\ncluster.\nThe webshop allows you to browse and search for products belonging to different categories,\ndisplay a specific product in detail, add products to the cart, register, login and pay by credit\ncard.\nI used Spring Boot framework for the server sideof theapplication. On theclient sideI usedthe\nAngular framework. For the database I used a relational MySQL database.\nTo implement the containerization, I used Docker to create the containers that are the basis for\ndeploying the application to the Kubernetes cluster. I solved the deployment to the Kubernetes\ncluster with Minikube, which allowed me to use Kubernetes locally for free.\nIn the dissertation I write in detail about the technologies used, mainly about Kubernetes and\nDocker, the implementation of functions, the architecture and the results achieved.",
        "keywords": [
            "cloud",
            "scalable",
            "Kubernetes",
            "webshop"
        ],
        "hash_code": 2892678779,
        "department": "cs"
    },
    {
        "author": "Szász Attila",
        "supervisor": "Dr. ing. Szántó Zoltán, Dr. ing. Márton Lőrinc",
        "year": "2023",
        "abstract": "Industrial robots are more and more wide-spread in various manufacturing and logistics processes,\nwhere accuracy, speed, and safety are important factors. Robots are capable of automating tasks\nthat are boring, dangerous, or too complex for humans. However, the collaboration between robots\nand humans represents challenges, especially when robots need to adapt flexibly to changing\nenvironments and tasks.\nThe recognition and manipulation of small objects are tasks widely used in industrial and\neducational contexts. However, determining the type and positioning of these objects is not always\nstraightforward, particularly when they have similar colors or sizes. In this paper, I present a\nmethod that enables the Baxter robot to easily differentiate cubes using ArUco markers. I describe\nhow I programmed the Baxter robot to determine the type and position of cubes on a workspace\nand arrange them accordingly. Throughout my study, I provide a detailed presentation of the\nsystem's design, implementation, and testing.\nIn my paper, I have developed a system that can control the Baxter robot to recognize and\nmanipulate cuboid-shaped objects. The system consists of three main components: an image\nprocessing module that detects and identifies objects using the OpenCV and cv2.aruco libraries, a\ncommunication module that uses the ZMQ protocol to send and receive data, and a robot control\nmodule that utilizes the ROS (Robot Operating System) libraries to control the robot's arms and\ngrippers. During the operation of the system, the robot captures an image of the workspace,\ndetermines the position and type of objects, and performs sorting based on this information.",
        "keywords": [
            "Baxter",
            "ROS",
            "ArUco",
            "Opencv",
            "Python",
            "image processing",
            "industrial and educational robotics"
        ],
        "hash_code": 7505858309,
        "department": "cs"
    },
    {
        "author": "Szász Nimród János",
        "supervisor": "Ș.l.dr.ing. Szántó Zoltán",
        "year": "2023",
        "abstract": "Nowadays, everyone has a smartphone that can solve many problems with various\napplications. Such useful applications are, for example, applications for paying our bills, but we\ncan also find many applications for managing our day-to-day tasks.\nMobile applications not only make our everyday lives easier but can also be helpful in\neducational institutions. The most commonly used mobile applications in schools and universities\nare various calculators, translators, and note-taking applications.\nHowever, applications for presenting PowerPoint presentations are not widespread among\npeople, so their number is very small and they are not the best maintained or do not have many\nfeatures that would make the use of these applications meaningful other than that the user does not\nhave to keep a separate device with them.\nMy thesis aims to design a system that allows laser pointers to be used on PowerPoint\npresentation slides with the help of our smartphone regardless of whether we have an Android or\nIOS phone. In addition, it should allow switching between slides and drawing on them. The system\nconsists of two components: one part is the server, which receives and processes data sent by our\nphone; the other part is the phone, which detects the user’s hand movements with the help of the\naccelerometer in the phone and also sends the pressing of displayed buttons to the server via WiFi.\nThe data required to connect to the server is made possible by scanning the QR code generated by\nthe server.",
        "keywords": [
            "Mobile application",
            "PowerPoint",
            "laser pointer."
        ],
        "hash_code": 8489835894,
        "department": "cs"
    },
    {
        "author": "Szeibert Xavér",
        "supervisor": "Conf.dr.ing. Kutasi Dénes Nimród, Ș.l.dr.ing. Szabó László Zsolt",
        "year": "2023",
        "abstract": "In the modern and rapidly evolving world, there is electric technology behind all our\nneeds, hobbies, and work, which we use comfortably and without problems. In current times,\nwith the increase in inflation, the prices of all necessities have risen, especially electricity.\nTherefore, if we do not pay attention to our daily energy consumption and do not make changes\nin our energy usage habits, we can easily encounter financial difficulties.\nThe aim of my thesis is to develop an IoT (Internet of Things) system that enables easy\nmeasurement and monitoring of energy consumption of electronic devices within a household.\nAdditionally, the system is capable of monitoring the production of solar panels installed in the\nhousehold. The data is stored in a database, allowing for future statistical analysis and insights.\nThis provides a more accurate understanding of energy costs and helps optimize consumption\nwhile leveraging renewable energy sources.\nThe different units communicate with each other through the MQTT protocol, where\npublishers (household appliances, solar panels) send sampled data to the broker (Raspberry Pi),\nwhere the data is processed, stored in a MongoDB database, and the processed data is sent to a\nmobile application via a REST API service.",
        "keywords": [
            "IoT",
            "Smart Energy meter",
            "MQTT",
            "Energy Management"
        ],
        "hash_code": 8961822645,
        "department": "cs"
    },
    {
        "author": "Zoltán Szász Arnold-Levente",
        "supervisor": "Ş.l. dr. ing Szántó",
        "year": "2021",
        "abstract": "Today, thanks to technological breakthroughs, mobile phones have a computing capacity\nunimaginable in the past. In addition to phone calls and messaging, these devices have many new\nfeatures. To achieve user experience at the highest level, they need a lot of sensors and\ncommunication modules. In addition, phones can be equipped with various accessories associated\nwith new sensors, making it possible to continuously monitor vital signs.\nThe purpose of this diploma work is to develop a system that would benefit from the\npossibilities offered by sensors. The Stroke Monitor application includes two different software,\nwhich consists of a telephone application and a smartwatch application, their interaction allowing\nthe user to monitor their heart rate even outside the hospital. The purpose of monitoring is to inform\nthe user and the contact person in case of a possible risk of stroke which is implemented based on\nthe data provided by the smartwatch and processed by the telephone application. It plays an\nimportant role for vulnerable users, because early medical emergency measures reduce the\naftermath of stroke. The telephone application is also able to display various graphs, determine the\nrisk score, provide daily advice to prevent the risk of stroke. During the development of the system,\nwe used flutter technology, so the application is platform independent.\nThe diploma thesis includes the definition of stroke, and it is recognition based on heart\nrate, design, implementation and development of telephone and smartwatch applications, as well\nas testing the system in real conditions.",
        "keywords": [
            "stroke",
            "monitoring",
            "mobile app",
            "smartwatch app"
        ],
        "hash_code": 6448857901,
        "department": "cs"
    },
    {
        "author": "Udvari Balázs",
        "supervisor": "Ș.l.dr.ing. Szabó László Zsolt",
        "year": "2021",
        "abstract": "The main subject of my thesis are Class Response Systems, software applications created\nin order to help real time teaching methods. During the last years one of my main interest was the\ntransformation of high school or university lectures by introducing interactivity and creating a\nbetter learning experience for the students. Consequently, my scope was the creation of a freely\nusable, low cost, platform independent CRS application, usable during traditional and online\nclasses also. Creating the application, my long distance goal is to measure the efficiency of\nclassroom teaching. Nowadays educational institutions frequently face problems caused by the\ndistraction of students attention during classes by Internet connected smart devices. But smart\ndevices, like mobile phones owned by almost all students could be used also for raising the\nefficiency of understanding during classes. Here are CRS systems coming in. In my thesis I present\nthe basic concepts of CRS applications, compare some of widely used CRS systems, afterwards I\npresent the project phases of my own CRS system, including testing and it’s usage in schools. My\nCRS application, called answeRS is a Node.js based web application which includes the basic\nfunctionalities of a CRS methods. The application assures teachers to display question queues\nduring classes in real time, student responses are collected by using their mobile phones. Teachers\ncan evaluate responses instantly, and consider the result for the next part of the lecture. Testing of\nthe application with multiple users was made under real online condition and requirements were\nfulfilled.",
        "keywords": [
            "Class Response System",
            "clicker device",
            "classroom real time methods"
        ],
        "hash_code": 8410466855,
        "department": "cs"
    },
    {
        "author": "László Ujfalvi Csongor-Robert",
        "supervisor": "Prof Dr. habil Szilágyi",
        "year": "2021",
        "abstract": "Even todaydeathscausedbybraintumorsareinthe scaleofhundredsof thousandsglobally.\nThanks to the rapid improvement of medical sciences and other branches of science nowadays\nthere are numerous different systems helping medical professionals to diagnose brain tumors\nfaster than before they have started using them. After the diagnosis, on average brain tumor\npatients live only a few more months than a year, so it’s essential to accelerate the process of\ndiagnosing the tumors to start treating the patientsbefore it’s too late.\nThe topic of my thesis is a software that makes the development and testing of algorithms\nwhich are segmenting and mapping brain tumors from volumetric MRI data. The application is\nable to display in 4K resolution the segmented andmappedbrainrecordsalongsidewiththekey\nindicators, results and statistical data on screen. Also it can store these data in a database and\nmake it readily available to query it later for futureuses.\nDuring the process of designing the software I’ve used many software design patterns and\nprinciples. While developing the application I’ve used many open source and free Microsoft\nproducts, including frameworks, developer tools andlibraries.",
        "keywords": [
            "MRI record",
            "User interface",
            "Software development"
        ],
        "hash_code": 2552954288,
        "department": "cs"
    }
]